import {
  axios_default,
  moment_default
} from "./chunk-F2LHAXEV.js";
import {
  computed,
  getCurrentInstance,
  h,
  inject,
  markRaw,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  provide,
  reactive,
  ref,
  toRefs,
  watch
} from "./chunk-YXU3ALOZ.js";
import "./chunk-PR4QN5HX.js";

// node_modules/@vueform/vueform/dist/index.mjs
function asyncGeneratorStep(n2, t2, e2, r2, o2, a, c) {
  try {
    var i = n2[a](c), u = i.value;
  } catch (n3) {
    return void e2(n3);
  }
  i.done ? t2(u) : Promise.resolve(u).then(r2, o2);
}
function _asyncToGenerator(n2) {
  return function() {
    var t2 = this, e2 = arguments;
    return new Promise(function(r2, o2) {
      var a = n2.apply(t2, e2);
      function _next(n3) {
        asyncGeneratorStep(a, r2, o2, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a, r2, o2, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
function _defineProperty$2(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var each$1 = { exports: {} };
function arrayEach$2(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var _arrayEach = arrayEach$2;
function createBaseFor$1(fromRight) {
  return function(object9, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object9), props = keysFunc(object9), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object9;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$2 = createBaseFor();
var _baseFor = baseFor$2;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$7 = root$7.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
var nativeObjectToString$1 = objectProto$g.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$f = Object.prototype;
var nativeObjectToString = objectProto$f.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$7(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$7;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$6 = _baseGetTag;
var isObjectLike$9 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$9(value) && baseGetTag$6(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$8 = isObjectLike_1;
var objectProto$e = Object.prototype;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
var isArguments$5 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$8(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$5;
var isArray$k = Array.isArray;
var isArray_1 = isArray$k;
var isBuffer$6 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$6, isBuffer$6.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$5 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$7 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
var arrayTag$2 = "[object Array]";
var boolTag$3 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$2 = "[object Error]";
var funcTag$2 = "[object Function]";
var mapTag$6 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$4 = "[object Object]";
var regexpTag$3 = "[object RegExp]";
var setTag$6 = "[object Set]";
var stringTag$4 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]";
var dataViewTag$4 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$7(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$5(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$5;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$4 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary$4(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseTimes = _baseTimes;
var isArguments$4 = isArguments_1;
var isArray$j = isArray_1;
var isBuffer$5 = isBuffer$6.exports;
var isIndex$3 = _isIndex;
var isTypedArray$3 = isTypedArray_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$j(value), isArg = !isArr && isArguments$4(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$c = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
  return value === proto;
}
var _isPrototype = isPrototype$4;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$3 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$b = objectProto$b.hasOwnProperty;
function baseKeys$2(object9) {
  if (!isPrototype$3(object9)) {
    return nativeKeys(object9);
  }
  var result = [];
  for (var key in Object(object9)) {
    if (hasOwnProperty$b.call(object9, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
function isObject$b(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$b;
var baseGetTag$4 = _baseGetTag;
var isObject$a = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$a(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var isFunction$3 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$9(value) {
  return value != null && isLength$1(value.length) && !isFunction$3(value);
}
var isArrayLike_1 = isArrayLike$9;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys$1 = _baseKeys;
var isArrayLike$8 = isArrayLike_1;
function keys$7(object9) {
  return isArrayLike$8(object9) ? arrayLikeKeys$1(object9) : baseKeys$1(object9);
}
var keys_1 = keys$7;
var baseFor$1 = _baseFor;
var keys$6 = keys_1;
function baseForOwn$2(object9, iteratee) {
  return object9 && baseFor$1(object9, iteratee, keys$6);
}
var _baseForOwn = baseForOwn$2;
var isArrayLike$7 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$7(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn$1 = _baseForOwn;
var createBaseEach = _createBaseEach;
var baseEach$5 = createBaseEach(baseForOwn$1);
var _baseEach = baseEach$5;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var identity$4 = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$4;
}
var _castFunction = castFunction$1;
var arrayEach$1 = _arrayEach;
var baseEach$4 = _baseEach;
var castFunction = _castFunction;
var isArray$i = isArray_1;
function forEach(collection, iteratee) {
  var func = isArray$i(collection) ? arrayEach$1 : baseEach$4;
  return func(collection, castFunction(iteratee));
}
var forEach_1 = forEach;
(function(module2) {
  module2.exports = forEach_1;
})(each$1);
var each = getDefaultExportFromCjs(each$1.exports);
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$5;
var eq$4 = eq_1;
function assocIndexOf$4(array4, key) {
  var length = array4.length;
  while (length--) {
    if (eq$4(array4[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$9 = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$a = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$9(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object9, key) {
  return object9 == null ? void 0 : object9[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object9, key) {
  var value = getValue(object9, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$5 = _root;
var Map$4 = getNative$6(root$5, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache;
var Map$2 = _Map;
var MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$4(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$4.prototype.clear = stackClear;
Stack$4.prototype["delete"] = stackDelete;
Stack$4.prototype.get = stackGet;
Stack$4.prototype.has = stackHas;
Stack$4.prototype.set = stackSet;
var _Stack = Stack$4;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$1 = defineProperty$2;
var defineProperty$1 = _defineProperty$1;
function baseAssignValue$4(object9, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object9, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object9[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$4;
var baseAssignValue$3 = _baseAssignValue;
var eq$3 = eq_1;
function assignMergeValue$2(object9, key, value) {
  if (value !== void 0 && !eq$3(object9[key], value) || value === void 0 && !(key in object9)) {
    baseAssignValue$3(object9, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
var _cloneBuffer = { exports: {} };
(function(module2, exports2) {
  var root2 = _root;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root$4 = _root;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$3(source, array4) {
  var index2 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source[index2];
  }
  return array4;
}
var _copyArray = copyArray$3;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object9() {
  }
  return function(proto) {
    if (!isObject$8(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object9.prototype = proto;
    var result = new object9();
    object9.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var baseCreate = _baseCreate;
var getPrototype$2 = _getPrototype;
var isPrototype$2 = _isPrototype;
function initCloneObject$2(object9) {
  return typeof object9.constructor == "function" && !isPrototype$2(object9) ? baseCreate(getPrototype$2(object9)) : {};
}
var _initCloneObject = initCloneObject$2;
var isArrayLike$6 = isArrayLike_1;
var isObjectLike$6 = isObjectLike_1;
function isArrayLikeObject$4(value) {
  return isObjectLike$6(value) && isArrayLike$6(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$4;
var baseGetTag$3 = _baseGetTag;
var getPrototype$1 = _getPrototype;
var isObjectLike$5 = isObjectLike_1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object9, key) {
  if (key === "constructor" && typeof object9[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object9[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function assignValue$3(object9, key, value) {
  var objValue = object9[key];
  if (!(hasOwnProperty$6.call(object9, key) && eq$2(objValue, value)) || value === void 0 && !(key in object9)) {
    baseAssignValue$2(object9, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object9, customizer) {
  var isNew = !object9;
  object9 || (object9 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object9[key], source[key], key, object9, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object9, key, newValue);
    } else {
      assignValue$2(object9, key, newValue);
    }
  }
  return object9;
}
var _copyObject = copyObject$6;
function nativeKeysIn$1(object9) {
  var result = [];
  if (object9 != null) {
    for (var key in Object(object9)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$7 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeysIn$1(object9) {
  if (!isObject$7(object9)) {
    return nativeKeysIn(object9);
  }
  var isProto = isPrototype$1(object9), result = [];
  for (var key in object9) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object9, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$5 = isArrayLike_1;
function keysIn$5(object9) {
  return isArrayLike$5(object9) ? arrayLikeKeys(object9, true) : baseKeysIn(object9);
}
var keysIn_1 = keysIn$5;
var copyObject$5 = _copyObject;
var keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$5(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer$1 = _cloneBuffer.exports;
var cloneTypedArray$1 = _cloneTypedArray;
var copyArray$2 = _copyArray;
var initCloneObject$1 = _initCloneObject;
var isArguments$3 = isArguments_1;
var isArray$h = isArray_1;
var isArrayLikeObject$3 = isArrayLikeObject_1;
var isBuffer$4 = isBuffer$6.exports;
var isFunction$1 = isFunction_1;
var isObject$6 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray$2 = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object9, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object9, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object9, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object9, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$h(srcValue), isBuff = !isArr && isBuffer$4(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$h(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject$3(objValue)) {
        newValue = copyArray$2(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$3(srcValue)) {
      newValue = objValue;
      if (isArguments$3(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$6(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object9, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$3 = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$5 = isObject_1;
var keysIn$3 = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object9, source, srcIndex, customizer, stack) {
  if (object9 === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack$3());
    if (isObject$5(srcValue)) {
      baseMergeDeep(object9, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object9, key), srcValue, key + "", object9, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object9, key, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax$3 = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$3(args.length - start, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array4);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1;
var defineProperty = _defineProperty$1;
var identity$3 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$3 : function(func, string2) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string2),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var identity$2 = identity_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function baseRest$5(func, start) {
  return setToString$1(overRest$1(func, start, identity$2), func + "");
}
var _baseRest = baseRest$5;
var eq$1 = eq_1;
var isArrayLike$4 = isArrayLike_1;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
function isIterateeCall$3(value, index2, object9) {
  if (!isObject$4(object9)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$4(object9) && isIndex$2(index2, object9.length) : type == "string" && index2 in object9) {
    return eq$1(object9[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$3;
var baseRest$4 = _baseRest;
var isIterateeCall$2 = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest$4(function(object9, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object9 = Object(object9);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object9, source, index2, customizer);
      }
    }
    return object9;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object9, source, srcIndex) {
  baseMerge(object9, source, srcIndex);
});
var merge_1 = merge;
function arraySome$2(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache;
var setCacheAdd = _setCacheAdd;
var setCacheHas = _setCacheHas;
function SetCache$3(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache$3.prototype.add = SetCache$3.prototype.push = setCacheAdd;
SetCache$3.prototype.has = setCacheHas;
var _SetCache = SetCache$3;
function cacheHas$3(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$3;
var SetCache$2 = _SetCache;
var arraySome$1 = _arraySome;
var cacheHas$2 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1;
var COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$2() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$4 = _Symbol;
var Uint8Array = _Uint8Array;
var eq = eq_1;
var equalArrays$1 = _equalArrays;
var mapToArray = _mapToArray;
var setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1;
var COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$2 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var errorTag$1 = "[object Error]";
var mapTag$5 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$2 = "[object RegExp]";
var setTag$5 = "[object Set]";
var stringTag$3 = "[object String]";
var symbolTag$3 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag$1(object9, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object9.byteLength != other.byteLength || object9.byteOffset != other.byteOffset) {
        return false;
      }
      object9 = object9.buffer;
      other = other.buffer;
    case arrayBufferTag$2:
      if (object9.byteLength != other.byteLength || !equalFunc(new Uint8Array(object9), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$2:
    case numberTag$2:
      return eq(+object9, +other);
    case errorTag$1:
      return object9.name == other.name && object9.message == other.message;
    case regexpTag$2:
    case stringTag$3:
      return object9 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray$2);
      if (object9.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object9);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object9, other);
      var result = equalArrays$1(convert(object9), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object9);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object9) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$4(array4, values2) {
  var index2 = -1, length = values2.length, offset = array4.length;
  while (++index2 < length) {
    array4[offset + index2] = values2[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$4;
var arrayPush$3 = _arrayPush;
var isArray$g = isArray_1;
function baseGetAllKeys$2(object9, keysFunc, symbolsFunc) {
  var result = keysFunc(object9);
  return isArray$g(object9) ? result : arrayPush$3(result, symbolsFunc(object9));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$2(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter$1 = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$4 = Object.prototype;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object9) {
  if (object9 == null) {
    return [];
  }
  object9 = Object(object9);
  return arrayFilter$1(nativeGetSymbols$1(object9), function(symbol) {
    return propertyIsEnumerable.call(object9, symbol);
  });
};
var _getSymbols = getSymbols$3;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols$2 = _getSymbols;
var keys$5 = keys_1;
function getAllKeys$2(object9) {
  return baseGetAllKeys$1(object9, keys$5, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function equalObjects$1(object9, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object9), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object9);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object9;
  }
  var result = true;
  stack.set(object9, other);
  stack.set(other, object9);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object9[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object9, stack) : customizer(objValue, othValue, key, object9, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object9.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object9 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object9);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative;
var root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative;
var root = _root;
var WeakMap$1 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map$1 = _Map;
var Promise$1 = _Promise;
var Set$1 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$2 = _baseGetTag;
var toSource = _toSource;
var mapTag$4 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$4 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap);
var getTag$5 = baseGetTag$2;
if (DataView && getTag$5(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$5(new Map$1()) != mapTag$4 || Promise$1 && getTag$5(Promise$1.resolve()) != promiseTag || Set$1 && getTag$5(new Set$1()) != setTag$4 || WeakMap && getTag$5(new WeakMap()) != weakMapTag$1) {
  getTag$5 = function(value) {
    var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$5;
var Stack$2 = _Stack;
var equalArrays = _equalArrays;
var equalByTag = _equalByTag;
var equalObjects = _equalObjects;
var getTag$4 = _getTag;
var isArray$f = isArray_1;
var isBuffer$3 = isBuffer$6.exports;
var isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var objectTag$1 = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep$1(object9, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$f(object9), othIsArr = isArray$f(other), objTag = objIsArr ? arrayTag$1 : getTag$4(object9), othTag = othIsArr ? arrayTag$1 : getTag$4(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object9)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$2());
    return objIsArr || isTypedArray$1(object9) ? equalArrays(object9, other, bitmask, customizer, equalFunc, stack) : equalByTag(object9, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object9, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object9.value() : object9, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$2());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$2());
  return equalObjects(object9, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep;
var isObjectLike$4 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$1 = _Stack;
var baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object9, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object9 == null) {
    return !length;
  }
  object9 = Object(object9);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object9[data[0]] : !(data[0] in object9)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object9[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object9)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object9, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$3 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$3(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable;
var keys$4 = keys_1;
function getMatchData$1(object9) {
  var result = keys$4(object9), length = result.length;
  while (length--) {
    var key = result[length], value = object9[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object9) {
    if (object9 == null) {
      return false;
    }
    return object9[key] === srcValue && (srcValue !== void 0 || key in Object(object9));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch;
var getMatchData = _getMatchData;
var matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object9) {
    return object9 === source || baseIsMatch(object9, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag$1 = _baseGetTag;
var isObjectLike$3 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$5;
var isArray$e = isArray_1;
var isSymbol$4 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$3(value, object9) {
  if (isArray$e(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object9 != null && value in Object(object9);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$6(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var _arrayMap = arrayMap$6;
var Symbol$3 = _Symbol;
var arrayMap$5 = _arrayMap;
var isArray$d = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$4 = 1 / 0;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$4(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$d(value)) {
    return arrayMap$5(value, baseToString$4) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
var _baseToString = baseToString$4;
var baseToString$3 = _baseToString;
function toString$9(value) {
  return value == null ? "" : baseToString$3(value);
}
var toString_1 = toString$9;
var isArray$c = isArray_1;
var isKey$2 = _isKey;
var stringToPath = _stringToPath;
var toString$8 = toString_1;
function castPath$6(value, object9) {
  if (isArray$c(value)) {
    return value;
  }
  return isKey$2(value, object9) ? [value] : stringToPath(toString$8(value));
}
var _castPath = castPath$6;
var isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
function toKey$6(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _toKey = toKey$6;
var castPath$5 = _castPath;
var toKey$5 = _toKey;
function baseGet$5(object9, path) {
  path = castPath$5(path, object9);
  var index2 = 0, length = path.length;
  while (object9 != null && index2 < length) {
    object9 = object9[toKey$5(path[index2++])];
  }
  return index2 && index2 == length ? object9 : void 0;
}
var _baseGet = baseGet$5;
var baseGet$4 = _baseGet;
function get$1(object9, path, defaultValue) {
  var result = object9 == null ? void 0 : baseGet$4(object9, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
function baseHasIn$1(object9, key) {
  return object9 != null && key in Object(object9);
}
var _baseHasIn = baseHasIn$1;
var castPath$4 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$b = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$4 = _toKey;
function hasPath$1(object9, path, hasFunc) {
  path = castPath$4(path, object9);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$4(path[index2]);
    if (!(result = object9 != null && hasFunc(object9, key))) {
      break;
    }
    object9 = object9[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object9 == null ? 0 : object9.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$b(object9) || isArguments$2(object9));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$2(object9, path) {
  return object9 != null && hasPath(object9, path, baseHasIn);
}
var hasIn_1 = hasIn$2;
var baseIsEqual$1 = _baseIsEqual;
var get = get_1;
var hasIn$1 = hasIn_1;
var isKey$1 = _isKey;
var isStrictComparable = _isStrictComparable;
var matchesStrictComparable = _matchesStrictComparable;
var toKey$3 = _toKey;
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$3(path), srcValue);
  }
  return function(object9) {
    var objValue = get(object9, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object9, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object9) {
    return object9 == null ? void 0 : object9[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$3 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object9) {
    return baseGet$3(object9, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty;
var basePropertyDeep = _basePropertyDeep;
var isKey = _isKey;
var toKey$2 = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches;
var baseMatchesProperty = _baseMatchesProperty;
var identity$1 = identity_1;
var isArray$a = isArray_1;
var property = property_1;
function baseIteratee$9(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$a(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$9;
var baseEach$3 = _baseEach;
function baseSome$1(collection, predicate) {
  var result;
  baseEach$3(collection, function(value, index2, collection2) {
    result = predicate(value, index2, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var arraySome = _arraySome;
var baseIteratee$8 = _baseIteratee;
var baseSome = _baseSome;
var isArray$9 = isArray_1;
var isIterateeCall$1 = _isIterateeCall;
function some(collection, predicate, guard) {
  var func = isArray$9(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall$1(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$8(predicate));
}
var some_1 = some;
var baseKeys = _baseKeys;
var getTag$3 = _getTag;
var isArguments$1 = isArguments_1;
var isArray$8 = isArray_1;
var isArrayLike$3 = isArrayLike_1;
var isBuffer$2 = isBuffer$6.exports;
var isPrototype = _isPrototype;
var isTypedArray = isTypedArray_1;
var mapTag$3 = "[object Map]";
var setTag$3 = "[object Set]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$3(value) && (isArray$8(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$2(value) || isTypedArray(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$3(value);
  if (tag == mapTag$3 || tag == setTag$3) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty;
function baseSlice$2(array4, start, end) {
  var index2 = -1, length = array4.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array4[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$2(array4, start, end) {
  var length = array4.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array4 : baseSlice$1(array4, start, end);
}
var _castSlice = castSlice$2;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode$2(string2) {
  return reHasUnicode.test(string2);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string2) {
  return string2.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]";
var rsCombo$2 = "[" + rsComboRange$2 + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$1 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$1 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray$1(string2) {
  return string2.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$2(string2) {
  return hasUnicode$1(string2) ? unicodeToArray(string2) : asciiToArray(string2);
}
var _stringToArray = stringToArray$2;
var castSlice$1 = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray$1 = _stringToArray;
var toString$7 = toString_1;
function createCaseFirst$2(methodName) {
  return function(string2) {
    string2 = toString$7(string2);
    var strSymbols = hasUnicode(string2) ? stringToArray$1(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice$1(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$2;
var createCaseFirst$1 = _createCaseFirst;
var upperFirst$1 = createCaseFirst$1("toUpperCase");
var upperFirst_1 = upperFirst$1;
var baseEach$2 = _baseEach;
function baseFilter$1(collection, predicate) {
  var result = [];
  baseEach$2(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter$1;
var arrayFilter = _arrayFilter;
var baseFilter = _baseFilter;
var baseIteratee$7 = _baseIteratee;
var isArray$7 = isArray_1;
function filter(collection, predicate) {
  var func = isArray$7(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee$7(predicate));
}
var filter_1 = filter;
var copyObject$4 = _copyObject;
var keys$3 = keys_1;
function baseAssign$1(object9, source) {
  return object9 && copyObject$4(source, keys$3(source), object9);
}
var _baseAssign = baseAssign$1;
var copyObject$3 = _copyObject;
var keysIn$2 = keysIn_1;
function baseAssignIn$1(object9, source) {
  return object9 && copyObject$3(source, keysIn$2(source), object9);
}
var _baseAssignIn = baseAssignIn$1;
var copyObject$2 = _copyObject;
var getSymbols$1 = _getSymbols;
function copySymbols$1(source, object9) {
  return copyObject$2(source, getSymbols$1(source), object9);
}
var _copySymbols = copySymbols$1;
var arrayPush$2 = _arrayPush;
var getPrototype = _getPrototype;
var getSymbols = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object9) {
  var result = [];
  while (object9) {
    arrayPush$2(result, getSymbols(object9));
    object9 = getPrototype(object9);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object9) {
  return copyObject$1(source, getSymbolsIn$1(source), object9);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$1 = keysIn_1;
function getAllKeysIn$2(object9) {
  return baseGetAllKeys(object9, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array4) {
  var length = array4.length, result = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty$1.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$2 = _Symbol;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object9, tag, isDeep) {
  var Ctor = object9.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object9);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object9);
    case dataViewTag$1:
      return cloneDataView(object9, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object9, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$2:
      return new Ctor(object9);
    case regexpTag$1:
      return cloneRegExp(object9);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object9);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag;
var isObjectLike$2 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$3 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$3(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$1 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$2 = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary$2(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer = _cloneBuffer.exports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject = _initCloneObject;
var isArray$6 = isArray_1;
var isBuffer$1 = isBuffer$6.exports;
var isMap = isMap_1;
var isObject$2 = isObject_1;
var isSet = isSet_1;
var keys$2 = keys_1;
var keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$3 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$3(value, bitmask, customizer, key, object9, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$3;
  if (customizer) {
    result = object9 ? customizer(value, key, object9, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$6(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object9) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object9 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$3(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys$2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$3;
var baseClone$2 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$2 = 4;
function cloneDeep(value) {
  return baseClone$2(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
}
var cloneDeep_1 = cloneDeep;
var assignValue = _assignValue;
var castPath$3 = _castPath;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
var toKey$1 = _toKey;
function baseSet$2(object9, path, value, customizer) {
  if (!isObject$1(object9)) {
    return object9;
  }
  path = castPath$3(path, object9);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object9;
  while (nested != null && ++index2 < length) {
    var key = toKey$1(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object9;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object9;
}
var _baseSet = baseSet$2;
var baseSet$1 = _baseSet;
function set(object9, path, value) {
  return object9 == null ? object9 : baseSet$1(object9, path, value);
}
var set_1 = set;
var Symbol$1 = _Symbol;
var isArguments = isArguments_1;
var isArray$5 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$6(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$6(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$6;
function baseFindIndex$3(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$3;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$2 = _baseFindIndex;
var baseIsNaN = _baseIsNaN;
var strictIndexOf = _strictIndexOf;
function baseIndexOf$4(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex$2(array4, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$4;
var baseIndexOf$3 = _baseIndexOf;
function arrayIncludes$2(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf$3(array4, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$2;
function arrayIncludesWith$2(array4, value, comparator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$2;
function noop$1() {
}
var noop_1 = noop$1;
var Set = _Set;
var noop = noop_1;
var setToArray$1 = _setToArray;
var INFINITY$2 = 1 / 0;
var createSet$1 = !(Set && 1 / setToArray$1(new Set([, -0]))[1] == INFINITY$2) ? noop : function(values2) {
  return new Set(values2);
};
var _createSet = createSet$1;
var SetCache$1 = _SetCache;
var arrayIncludes$1 = _arrayIncludes;
var arrayIncludesWith$1 = _arrayIncludesWith;
var cacheHas$1 = _cacheHas;
var createSet = _createSet;
var setToArray = _setToArray;
var LARGE_ARRAY_SIZE$1 = 200;
function baseUniq$1(array4, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes$1, length = array4.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith$1;
  } else if (length >= LARGE_ARRAY_SIZE$1) {
    var set2 = iteratee ? null : createSet(array4);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes2 = cacheHas$1;
    seen = new SetCache$1();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result.push(value);
      } else if (!includes2(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseFlatten$5 = _baseFlatten;
var baseRest$3 = _baseRest;
var baseUniq = _baseUniq;
var isArrayLikeObject$2 = isArrayLikeObject_1;
var union = baseRest$3(function(arrays) {
  return baseUniq(baseFlatten$5(arrays, 1, isArrayLikeObject$2, true));
});
var union_1 = union;
var baseFlatten$4 = _baseFlatten;
var INFINITY$1 = 1 / 0;
function flattenDeep(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten$4(array4, INFINITY$1) : [];
}
var flattenDeep_1 = flattenDeep;
var MERGE_KEYS = ["presets", "usePresets", "addClasses", "prependClasses", "removeClasses", "replaceClasses", "overrideClasses"];
var LOCALS_KEYS = ["addClass", "removeClass", "replaceClass", "overrideClass"];
var MergeClasses = class {
  constructor() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.options = options;
    if (this.shouldMergeTemplateClasses) {
      this.componentClasses = this.templateClasses;
      this.merge({
        overrideClasses: {
          [this.component]: this.themeClasses
        }
      });
    } else {
      this.componentClasses = this.templateClasses;
    }
    this.merge(this.config);
    each(options.merge, (merge2) => {
      this.merge(merge2);
    });
    this.merge(this.locals || this.component$.value, true);
    if (this.config.classHelpers && this.config.env !== "production") {
      this.merge({
        prependClasses: {
          [this.component]: this.getClassHelpers(this.componentClasses, [this.component])
        }
      });
    }
  }
  get classes() {
    return new Proxy(this.componentClasses, {
      get: (target, prop) => {
        if (typeof prop !== "string") {
          return target[prop];
        }
        return this.getDynamicClasses(target, prop);
      }
    });
  }
  get config() {
    return this.options.config || {};
  }
  get component() {
    return this.options.component;
  }
  get component$() {
    return this.options.component$;
  }
  get locals() {
    return this.options.locals;
  }
  get view() {
    return this.options.view;
  }
  get theme() {
    return this.options.theme;
  }
  get presets() {
    return this.config.presets;
  }
  get templates() {
    return this.options.templates || {};
  }
  get template() {
    return this.view && this.templates["".concat(this.component, "_").concat(this.view)] ? this.templates["".concat(this.component, "_").concat(this.view)] : this.templates[this.component] || {};
  }
  get themeClasses() {
    return cloneDeep_1(this.toArray(this.view && this.theme.classes["".concat(this.component, "_").concat(this.view)] ? this.theme.classes["".concat(this.component, "_").concat(this.view)] : this.theme.classes[this.component]));
  }
  get templateClasses() {
    return cloneDeep_1(this.toArray(this.defaultClasses));
  }
  get shouldMergeTemplateClasses() {
    var merge2 = typeof this.template.data === "function" && this.template.data().merge !== void 0 ? this.template.data().merge : this.component$.value.merge;
    return merge2 !== void 0 ? merge2 : false;
  }
  get defaultClasses() {
    return typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
  }
  get mainClass() {
    var defaultClasses = typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
    return Object.keys(defaultClasses)[0];
  }
  merge(merge2) {
    var locals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    each(this.pick(merge2, locals ? LOCALS_KEYS : MERGE_KEYS), (mergables, key) => {
      if (typeof mergables === "function") {
        mergables = mergables(this.component$.value.form$, "el$" in this.component$.value && typeof this.component$.value.el$ === "object" ? this.component$.value.el$ : void 0, this.component$.value);
      }
      switch (key) {
        case "addClasses":
        case "prependClasses":
        case "overrideClasses":
          if (!mergables || mergables[this.component] === void 0) {
            return;
          }
          this.mergeComponentClasses(this.toArray(mergables[this.component]), key);
          break;
        case "removeClasses":
        case "replaceClasses":
          if (!mergables || mergables[this.component] === void 0) {
            return;
          }
          this.mergeComponentClasses(mergables[this.component], key);
          break;
        case "addClass":
        case "removeClass":
        case "replaceClass":
        case "overrideClass":
          if (!mergables) {
            return;
          }
          if (typeof mergables === "string" || Array.isArray(mergables)) {
            if (!Array.isArray(mergables)) {
              mergables = mergables.length > 0 ? mergables.split(" ") : [];
            }
            this.mergeComponentClasses({
              [this.mainClass]: mergables
            }, "".concat(key, "es"));
          } else if (key === "replaceClass") {
            this.mergeComponentClasses(mergables, "".concat(key, "es"));
          } else if (isPlainObject_1(mergables)) {
            this.mergeComponentClasses(this.toArray(mergables), "".concat(key, "es"));
          } else ;
          break;
        case "presets":
        case "usePresets":
          if (!Array.isArray(mergables)) {
            return;
          }
          each(mergables, (presetName) => {
            this.merge(this.presets[presetName]);
          });
          break;
      }
    });
  }
  mergeComponentClasses(componentClasses, key) {
    each(componentClasses, (classes, className) => {
      this[key](classes, [className]);
    });
  }
  addClasses(add, levels) {
    var base81 = get_1(this.componentClasses, levels.join("."));
    if (add.length == 1 && !add[0]) {
      return;
    }
    if (isPlainObject_1(base81)) {
      each(add, (subclasses, subclassName) => {
        this.addClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), union_1(base81, add));
    }
  }
  prependClasses(prepend, levels) {
    var base81 = get_1(this.componentClasses, levels.join("."));
    if (prepend.length == 1 && !prepend[0]) {
      return;
    }
    if (isPlainObject_1(base81)) {
      each(prepend, (subclasses, subclassName) => {
        this.prependClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), union_1(prepend, base81));
    }
  }
  removeClasses(remove, levels) {
    var base81 = get_1(this.componentClasses, levels.join("."));
    if (isPlainObject_1(base81)) {
      each(remove, (subclasses, subclassName) => {
        this.removeClasses(subclasses, levels.concat(subclassName));
      });
    } else if (Array.isArray(base81)) {
      set_1(this.componentClasses, levels.join("."), base81.filter((c) => {
        return typeof c !== "string" || remove.indexOf(c) === -1;
      }));
    }
  }
  replaceClasses(replace, levels) {
    var base81 = get_1(this.componentClasses, levels.join("."));
    if (Array.isArray(replace)) {
      var tempReplace = {};
      replace.forEach((r2) => {
        tempReplace = _objectSpread2$1(_objectSpread2$1({}, tempReplace), r2);
      });
      replace = tempReplace;
    }
    if (isPlainObject_1(base81)) {
      each(replace, (subclasses, subclassName) => {
        this.replaceClasses(subclasses, levels.concat(subclassName));
      });
    } else if (Array.isArray(base81)) {
      set_1(this.componentClasses, levels.join("."), base81.map((c) => {
        return typeof c !== "string" || Object.keys(replace).indexOf(c) === -1 ? c : replace[c];
      }));
    }
  }
  overrideClasses(override, levels) {
    var base81 = get_1(this.componentClasses, levels.join("."));
    if (isPlainObject_1(base81)) {
      each(override, (subclasses, subclassName) => {
        this.overrideClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), override);
    }
  }
  toArray(componentClasses) {
    var arrayClasses = {};
    each(componentClasses, (classes, className) => {
      arrayClasses[className] = this.classesToArray(classes, [className]);
    });
    return arrayClasses;
  }
  classesToArray(classes, path) {
    var _classes$constructor;
    var arrayClasses = classes;
    var base81 = path ? get_1(this.componentClasses, path.join(".")) : void 0;
    if (typeof classes === "string") {
      arrayClasses = classes.length > 0 ? classes.split(" ") : [];
    } else if (isPlainObject_1(classes)) {
      if (base81 && Array.isArray(base81)) {
        arrayClasses = [classes];
      } else if (!base81 || isPlainObject_1(base81)) {
        arrayClasses = {};
        each(classes, (subclasses, subclassName) => {
          arrayClasses[subclassName] = this.classesToArray(subclasses, path.concat([subclassName]));
        });
      }
    } else if (typeof classes === "boolean" || typeof classes === "object" && ["ComputedRefImpl", "RefImpl"].indexOf(classes === null || classes === void 0 || (_classes$constructor = classes.constructor) === null || _classes$constructor === void 0 ? void 0 : _classes$constructor.name) !== -1) {
      throw Error("Cannot add conditional class to ".concat(this.component, ": '").concat(path.join("."), "'"));
    }
    return arrayClasses;
  }
  getDynamicClasses(target, prop, mainTarget) {
    if (!mainTarget) {
      mainTarget = target;
    }
    var classes = Array.isArray(target[prop]) ? flattenDeep_1(target[prop]) : target[prop];
    if (target["$".concat(prop)]) {
      var propVal = target["$".concat(prop)](mainTarget, this.component$.value);
      return typeof propVal === "function" ? propVal : flattenDeep_1(propVal);
    }
    if (isPlainObject_1(classes)) {
      classes = cloneDeep_1(classes);
      each(classes, (classList, className) => {
        classes[className] = this.getDynamicClasses(classes, className, target);
      });
    }
    return classes;
  }
  getClassHelpers(componentClasses, path) {
    var classHelpers = {};
    each(componentClasses, (classes, className) => {
      if (className.match(/[$]/)) {
        return;
      }
      if (isPlainObject_1(classes)) {
        classHelpers[className] = this.getClassHelpers(componentClasses[className], path.concat([className]));
      } else {
        classHelpers[className] = ["".concat(path.join("."), ".").concat(className, "-->")];
      }
    });
    return classHelpers;
  }
  pick(from, picks) {
    var picked = {};
    if (!from) {
      return picked;
    }
    each(picks, (pick2) => {
      if (pick2 in from) {
        picked[pick2] = from[pick2];
      }
    });
    return picked;
  }
};
var _getFormData = function getFormData(data, formData, namespace) {
  if (formData === void 0) {
    formData = new FormData();
  }
  if (namespace === void 0) {
    namespace = "";
  }
  if (isArray_1(data)) {
    each(data, (value, key) => {
      _getFormData(value, formData, namespace + "[" + key + "]");
    });
  } else if (isPlainObject_1(data)) {
    each(data, (value, key) => {
      _getFormData(value, formData, namespace ? namespace + "[" + key + "]" : key);
    });
  } else {
    formData.append(namespace, data === null ? "" : data);
  }
  return formData;
};
var arrayMap$4 = _arrayMap;
function baseValues$1(object9, props) {
  return arrayMap$4(props, function(key) {
    return object9[key];
  });
}
var _baseValues = baseValues$1;
var baseValues = _baseValues;
var keys$1 = keys_1;
function values$1(object9) {
  return object9 == null ? [] : baseValues(object9, keys$1(object9));
}
var values_1 = values$1;
function asyncForEach(_x, _x2) {
  return _asyncForEach.apply(this, arguments);
}
function _asyncForEach() {
  _asyncForEach = _asyncToGenerator(function* (array4, callback57) {
    for (var index2 = 0; index2 < (isPlainObject_1(array4) ? values_1(array4) : array4).length; index2++) {
      var key = isPlainObject_1(array4) ? keys_1(array4)[index2] : index2;
      yield callback57(array4[key], key, array4);
    }
  });
  return _asyncForEach.apply(this, arguments);
}
var baseAssignValue = _baseAssignValue;
var baseForOwn = _baseForOwn;
var baseIteratee$6 = _baseIteratee;
function mapValues(object9, iteratee) {
  var result = {};
  iteratee = baseIteratee$6(iteratee);
  baseForOwn(object9, function(value, key, object10) {
    baseAssignValue(result, key, iteratee(value, key, object10));
  });
  return result;
}
var mapValues_1 = mapValues;
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
var fileToObject = function fileToObject2(file6) {
  return {
    lastModified: file6.lastModified,
    name: file6.name,
    size: file6.size,
    type: file6.type
  };
};
var _dataToComperable = function dataToComperable(data) {
  if (data instanceof File) {
    return fileToObject(data);
  } else if (data instanceof Date) {
    return data.toString();
  } else if (Array.isArray(data)) {
    return data.map(_dataToComperable);
  } else if (typeof data === "object" && data !== null) {
    return mapValues_1(data, _dataToComperable);
  }
  return data;
};
function dataEquals(a, b) {
  return isEqual_1(_dataToComperable(a), _dataToComperable(b));
}
var findScrollableParent = (element2) => {
  var currentElement = element2.parentElement;
  while (currentElement && currentElement !== document.body) {
    var overflowY = window.getComputedStyle(currentElement).overflowY;
    var overflowX = window.getComputedStyle(currentElement).overflowX;
    var isScrollableY = (overflowY === "scroll" || overflowY === "auto") && currentElement.scrollHeight > currentElement.clientHeight;
    var isScrollableX = (overflowX === "scroll" || overflowX === "auto") && currentElement.scrollWidth > currentElement.clientWidth;
    if (isScrollableY || isScrollableX) {
      return currentElement;
    }
    currentElement = currentElement.parentElement;
  }
  return null;
};
var scrollIntoView = (element2, scrollableParent) => {
  if (!scrollableParent) {
    return;
  }
  var elementRect = element2.getBoundingClientRect();
  var parentRect = scrollableParent.getBoundingClientRect();
  var offsetTop = elementRect.top - parentRect.top + scrollableParent.scrollTop;
  var offsetLeft = elementRect.left - parentRect.left + scrollableParent.scrollLeft;
  scrollableParent.scrollTo({
    top: offsetTop,
    left: offsetLeft,
    behavior: "smooth"
  });
};
function isComponentRegistered(vm, component) {
  return vm.appContext !== void 0 ? typeof vm.appContext.app.component(component) !== "string" : !!vm.proxy.$root.$options.components[component];
}
var flatten$3 = (source) => {
  var collection = [];
  source.forEach((item) => {
    collection.push(item.path);
    if (item.children) {
      flatten$3(item.children).forEach((child) => {
        collection.push(child);
      });
    }
  });
  return collection;
};
var _collect = function collect(elements, pages) {
  var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  var createMember = (name2) => {
    var element2 = elements[name2];
    var path = prefix.length ? "".concat(prefix, ".").concat(name2) : name2;
    var member = {
      name: name2,
      path,
      type: element2.type
    };
    if (["group", "object"].indexOf(element2.type) !== -1 && Object.keys(element2.schema || {}).length) {
      member.children = _collect(element2.schema, null, path);
    }
    if (element2.type === "list" && Object.keys((element2 === null || element2 === void 0 ? void 0 : element2.element) || {}).length) {
      member.children = _collect({
        0: element2.element
      }, null, path);
    }
    return member;
  };
  var children = [];
  if (pages && Object.keys(pages).length) {
    Object.values(pages).forEach((page) => {
      page.elements.forEach((name2) => {
        children.push(createMember(name2));
      });
    });
  } else {
    Object.keys(elements).forEach((name2) => {
      children.push(createMember(name2));
    });
  }
  return children;
};
var toString$6 = toString_1;
var upperFirst = upperFirst_1;
function capitalize$1(string2) {
  return upperFirst(toString$6(string2).toLowerCase());
}
var capitalize_1 = capitalize$1;
function arrayReduce$2(array4, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  if (initAccum && length) {
    accumulator = array4[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array4[index2], index2, array4);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$2;
function basePropertyOf$1(object9) {
  return function(key) {
    return object9 == null ? void 0 : object9[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr$1(string2) {
  string2 = toString$5(string2);
  return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string2) {
  return string2.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string2) {
  return reHasUnicodeWord.test(string2);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string2) {
  return string2.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string2, pattern, guard) {
  string2 = toString$4(string2);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
  }
  return string2.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce$1 = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder$1(callback57) {
  return function(string2) {
    return arrayReduce$1(words(deburr(string2).replace(reApos, "")), callback57, "");
  };
}
var _createCompounder = createCompounder$1;
var capitalize = capitalize_1;
var createCompounder = _createCompounder;
var camelCase = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
var base$1e = function base(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (!options.events) {
    throw new Error("`events` option is required for useEvents");
  }
  var events = ref(options.events);
  var listeners = ref({});
  var on2 = (evt, callback57) => {
    if (!listeners.value[evt]) {
      listeners.value[evt] = [];
    }
    listeners.value[evt].push(callback57);
  };
  var off2 = (evt) => {
    delete listeners.value[evt];
  };
  var fire = function fire2() {
    var evt = arguments[0];
    var args = [].slice.call(arguments).splice(1);
    each(listeners.value[evt], (callback57) => {
      callback57(...args);
    });
    if (!listeners.value[evt] || !listeners.value[evt].length) {
      context.emit(...[evt].concat(args));
    }
  };
  each(events.value, (evt) => {
    var callback57 = props["on" + upperFirst_1(camelCase_1(evt))];
    if (callback57) {
      on2(evt, callback57);
    }
  });
  return {
    events,
    listeners,
    on: on2,
    off: off2,
    fire
  };
};
function useModel(props, context, dependencies2) {
  var {
    value: v,
    modelValue: mv,
    sync
  } = toRefs(props);
  var $this = dependencies2.$this;
  var externalValue = $this.$vueform.vueVersion === 3 ? mv : v;
  var internalData = ref({});
  var intermediaryValue = ref(externalValue && externalValue.value ? cloneDeep_1(externalValue.value) : null);
  var isSync = computed(() => {
    return sync.value && externalValue && externalValue.value !== void 0;
  });
  var model = computed(() => {
    return cloneDeep_1(externalValue.value || internalData.value);
  });
  var updateModel = (dataPath, val) => {
    if (externalValue.value) {
      if (dataPath) {
        var parts = dataPath.split(".");
        var element2 = parts.pop();
        var parent2 = parts.join(".") || null;
        var externalValueObject = parent2 ? get_1(externalValue.value, parent2) : externalValue.value;
        if (externalValueObject !== void 0) {
          $this.$set(externalValueObject, element2, val);
        }
        intermediaryValue.value = cloneDeep_1(externalValue.value);
      } else {
        each(val, (v2, key) => {
          if (externalValue.value !== void 0) {
            $this.$set(externalValue.value, key, v2);
          }
          if (intermediaryValue.value !== void 0) {
            $this.$set(intermediaryValue.value, key, v2);
          }
        });
      }
    } else {
      var _model = cloneDeep_1(externalValue.value || internalData.value);
      if (dataPath) {
        set_1(_model, dataPath, val);
      } else {
        _model = Object.assign({}, _model, val);
      }
      internalData.value = _model;
    }
  };
  if (externalValue && externalValue.value) {
    watch(model, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      internalData.value = n2;
    }, {
      deep: true,
      immediate: false
    });
  }
  return {
    model,
    internalData,
    intermediaryValue,
    externalValue,
    isSync,
    updateModel
  };
}
var base$1d = function base2(props, context) {
  var {
    schema,
    tabs,
    steps,
    size: size2,
    view,
    views,
    addClass,
    removeClass,
    replaceClass,
    overrideClass,
    addClasses,
    removeClasses,
    replaceClasses,
    overrideClasses,
    presets,
    templates,
    theme,
    messages,
    columns,
    languages,
    formKey,
    endpoint,
    method,
    formData,
    language,
    locale,
    validateOn,
    scrollToInvalid,
    scrollOnNext,
    showRequired,
    forceLabels,
    floatPlaceholders,
    multilingual: multilingual11,
    stepsControls,
    displayErrors,
    displayMessages,
    formatLoad,
    formatData,
    forceNumbers,
    prepare,
    default: default_,
    disabled,
    loading,
    providers,
    useProviders,
    providerOptions,
    onChange: _onChange,
    onReset: _onReset,
    onClear: _onClear,
    onSubmit: _onSubmit,
    onSuccess: _onSuccess,
    onError: _onError,
    onLanguage: _onLanguage,
    onBeforeMount: _onBeforeMount,
    onMounted: _onMounted,
    onBeforeUpdate: _onBeforeUpdate,
    onUpdated: _onUpdated,
    onBeforeUnmount: _onBeforeUnmount,
    onUnmounted: _onUnmounted
  } = toRefs(props);
  var evts = ["change", "reset", "clear", "submit", "success", "error", "language", "response", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
  var vm = getCurrentInstance();
  var $this = vm.proxy;
  var {
    events,
    listeners,
    fire,
    on: on2,
    off: off2
  } = base$1e(props, context, {
    form$: $this
  }, {
    events: evts
  });
  var {
    externalValue,
    model,
    internalData,
    intermediaryValue,
    isSync,
    updateModel
  } = useModel(props, context, {
    $this,
    fire
  });
  var elements$ = ref({});
  var tabs$ = ref(null);
  var steps$ = ref(null);
  var validation2 = ref(true);
  var conditions = ref(true);
  var messageBag2 = ref({});
  var submitting = ref(false);
  var preparing = ref(false);
  var cancelToken = ref(null);
  var selectedLanguage = ref(null);
  var userConfig = ref({});
  var mounted = ref(false);
  var messagesRegistered = ref(isComponentRegistered(vm, "FormMessages"));
  var errorsRegistered = ref(isComponentRegistered(vm, "FormErrors"));
  var languagesRegistered = ref(isComponentRegistered(vm, "FormLanguages"));
  var tabsRegistered = ref(isComponentRegistered(vm, "FormTabs"));
  var stepsRegistered = ref(isComponentRegistered(vm, "FormSteps"));
  var form$ = computed(() => {
    return $this;
  });
  var baseConfig = computed(() => {
    return $this.$vueform;
  });
  var config$ = computed(() => {
    return baseConfig.value;
  });
  var locale$ = computed(() => {
    return options.value.locale || baseConfig.value.i18n.locale;
  });
  var services = computed(() => {
    return $this.$vueform.services;
  });
  var options = computed(() => {
    var options2 = {
      schema: orderedSchema.value,
      tabs: formTabs.value,
      steps: formSteps.value
    };
    var override = {
      columns,
      languages,
      language,
      theme,
      method,
      validateOn,
      showRequired,
      messages,
      formKey,
      multilingual: multilingual11,
      formatLoad,
      formatData,
      prepare,
      default: default_,
      formData,
      templates,
      addClass,
      removeClass,
      replaceClass,
      overrideClass,
      addClasses,
      removeClasses,
      replaceClasses,
      overrideClasses,
      presets,
      size: size2,
      view,
      views,
      locale
    };
    var ifPropSet = {
      stepsControls,
      displayErrors,
      displayMessages,
      forceLabels,
      disabled,
      loading,
      floatPlaceholders,
      endpoint,
      forceNumbers,
      scrollOnNext,
      scrollToInvalid,
      onChange: _onChange.value,
      onReset: _onReset.value,
      onClear: _onClear.value,
      onSubmit: _onSubmit.value,
      onSuccess: _onSuccess.value,
      onError: _onError.value,
      onLanguage: _onLanguage.value,
      onBeforeMount: _onBeforeMount.value,
      onMounted: _onMounted.value,
      onBeforeUpdate: _onBeforeUpdate.value,
      onUpdated: _onUpdated.value,
      onBeforeUnmount: _onBeforeUnmount.value,
      onUnmounted: _onUnmounted.value
    };
    var toMerge = {
      useProviders,
      providers,
      providerOptions
    };
    var defaults2 = {
      providers: baseConfig.value.config.providers,
      useProviders: baseConfig.value.config.useProviders,
      providerOptions: baseConfig.value.config.providerOptions,
      languages: baseConfig.value.config.languages,
      language: baseConfig.value.config.language,
      endpoint: typeof baseConfig.value.config.endpoints.submit === "function" ? baseConfig.value.config.endpoints.submit : baseConfig.value.config.endpoints.submit.url,
      method: typeof baseConfig.value.config.endpoints.submit === "function" ? null : baseConfig.value.config.endpoints.submit.method,
      validateOn: baseConfig.value.config.validateOn,
      scrollToInvalid: baseConfig.value.config.scrollToInvalid,
      scrollOnNext: baseConfig.value.config.scrollOnNext,
      showRequired: baseConfig.value.config.showRequired,
      displayErrors: baseConfig.value.config.displayErrors,
      displayMessages: baseConfig.value.config.displayMessages,
      forceLabels: baseConfig.value.config.forceLabels,
      floatPlaceholders: baseConfig.value.config.floatPlaceholders,
      formData: baseConfig.value.config.formData,
      theme: baseConfig.value.theme,
      view: baseConfig.value.config.view,
      views: {},
      columns: {},
      size: null,
      addClass: null,
      removeClass: null,
      replaceClass: null,
      overrideClass: null,
      addClasses: {},
      removeClasses: {},
      replaceClasses: {},
      overrideClasses: {},
      presets: [],
      templates: {},
      messages: {},
      default: {},
      formKey: null,
      formatLoad: null,
      formatData: null,
      forceNumbers: null,
      prepare: null,
      multilingual: false,
      stepsControls: true,
      disabled: false,
      loading: false
    };
    each(override, (val, key) => {
      options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : (val && val.value ? val.value : void 0) || defaults2[key];
    });
    each(ifPropSet, (val, key) => {
      options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : val && val.value !== null ? val.value : defaults2[key];
    });
    each(toMerge, (val, key) => {
      options2[key] = merge_1({}, defaults2[key], userConfig.value[key] || {}, val && val.value ? val.value : {});
    });
    return options2;
  });
  var orderedSchema = computed(() => {
    var blocks;
    var orderedSchema2 = formSchema.value;
    if (Object.keys(formSteps.value).length > 0) {
      blocks = formSteps.value;
    }
    if (Object.keys(formTabs.value).length > 0) {
      blocks = formTabs.value;
    }
    if (blocks) {
      orderedSchema2 = {};
      each(blocks, (block) => {
        each(block.elements, (name2) => {
          if (formSchema.value[name2]) {
            orderedSchema2[name2] = formSchema.value[name2];
          }
        });
      });
      each(Object.keys(formSchema.value), (name2) => {
        if (orderedSchema2[name2] === void 0) {
          orderedSchema2[name2] = formSchema.value[name2];
        }
      });
    }
    return orderedSchema2;
  });
  var formSchema = computed(() => {
    return merge_1({}, schema && schema.value ? schema.value : {}, userConfig.value.schema || {});
  });
  var formTabs = computed(() => {
    return merge_1({}, tabs && tabs.value ? tabs.value : {}, userConfig.value.tabs || {});
  });
  var formSteps = computed(() => {
    return merge_1({}, steps && steps.value ? steps.value : {}, userConfig.value.steps || {});
  });
  var tree = computed(() => {
    return _collect(formSchema.value, hasTabs.value ? formTabs.value : formSteps.value);
  });
  var flatTree = computed(() => {
    return flatten$3(tree.value);
  });
  var data = computed(() => {
    var data2 = {};
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      data2 = Object.assign({}, data2, e$.data);
    });
    return data2;
  });
  var requestData = computed(() => {
    var requestData2 = {};
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, e$.requestData);
    });
    return formatData.value ? formatData.value(requestData2) : requestData2;
  });
  var dirty = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.dirty === true;
    });
  });
  var invalid = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.invalid === true;
    });
  });
  var debouncing = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.debouncing === true;
    });
  });
  var pending = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.pending === true;
    });
  });
  var validated = computed(() => {
    return !some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.validated === false;
    });
  });
  var busy = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.busy === true;
    }) || submitting.value || preparing.value || isLoading.value;
  });
  var elementErrors = computed(() => {
    var errors = [];
    each(filter_1(elements$.value, {
      available: true,
      isStatic: false
    }), (element$) => {
      each(element$.errors, (error) => {
        errors.push(error);
      });
    });
    return errors;
  });
  var formErrors = computed(() => {
    return messageBag2.value.errors;
  });
  var hasErrors = computed(() => {
    return formErrors.value.length > 0;
  });
  var showErrors = computed(() => {
    return hasErrors.value && options.value.displayErrors && errorsRegistered.value;
  });
  var formMessages = computed(() => {
    return messageBag2.value.messages;
  });
  var hasMessages = computed(() => {
    return formMessages.value.length > 0;
  });
  var showMessages = computed(() => {
    return hasMessages.value && options.value.displayMessages && messagesRegistered.value;
  });
  var isMultilingual = computed(() => {
    return options.value.multilingual;
  });
  var showLanguages = computed(() => {
    return isMultilingual.value && languagesRegistered.value;
  });
  var isDisabled = computed(() => {
    if (invalid.value && shouldValidateOnChange.value || busy.value) {
      return true;
    }
    if (typeof options.value.disabled === "boolean") {
      return options.value.disabled;
    }
    if (typeof options.value.disabled === "object" && options.value.disabled && options.value.disabled.value !== void 0) {
      return options.value.disabled.value;
    }
    if (typeof options.value.disabled === "function") {
      return options.value.disabled(form$.value);
    }
    if (Array.isArray(options.value.disabled)) {
      return options.value.disabled.every((condition2) => {
        return $this.$vueform.services.condition.check(condition2, null, form$.value);
      });
    }
  });
  var isLoading = computed(() => {
    return options.value.loading;
  });
  var shouldValidateOnChange = computed(() => {
    return options.value.validateOn.split("|").indexOf("change") !== -1;
  });
  var shouldValidateOnStep = computed(() => {
    return options.value.validateOn.split("|").indexOf("step") !== -1;
  });
  var hasSteps = computed(() => {
    return !isEmpty_1(options.value.steps);
  });
  var showSteps = computed(() => {
    return hasSteps.value && stepsRegistered.value;
  });
  var showStepsControls = computed(() => {
    return hasSteps.value && options.value.stepsControls && stepsRegistered.value;
  });
  var hasTabs = computed(() => {
    return !isEmpty_1(options.value.tabs);
  });
  var showTabs = computed(() => {
    return hasTabs.value && tabsRegistered.value;
  });
  var extendedTheme = computed(() => {
    var presetTemplates = {};
    each(baseConfig.value.config.usePresets.concat(options.value.presets), (presetName) => {
      var preset = baseConfig.value.config.presets[presetName];
      if (!preset || !preset.templates) {
        return;
      }
      presetTemplates = Object.assign({}, presetTemplates, preset.templates);
    });
    return Object.assign({}, options.value.theme, {
      // Add registered component to theme (or overwrite)
      templates: Object.assign({}, options.value.theme.templates, baseConfig.value.templates, presetTemplates, options.value.templates || {})
    });
  });
  var Templates = computed(() => {
    return extendedTheme.value.templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["Vueform_".concat(View.value)] ? Templates.value["Vueform_".concat(View.value)] : Templates.value.Vueform;
  });
  var classes = computed(() => {
    return new MergeClasses({
      component: "Vueform",
      component$: form$,
      theme: extendedTheme.value,
      config: baseConfig.value.config,
      templates: Templates.value,
      view: View.value,
      locals: options.value,
      merge: [options.value]
    }).classes;
  });
  var Size = computed(() => {
    var Size2;
    if (options.value.size) {
      Size2 = options.value.size;
    } else {
      each(baseConfig.value.config.usePresets.concat(options.value.presets), (presetName) => {
        var preset = baseConfig.value.config.presets[presetName];
        if (!preset || !preset.size) {
          return;
        }
        Size2 = preset.size;
      });
    }
    if (!Size2) {
      Size2 = baseConfig.value.config.size;
    }
    return Size2;
  });
  var Views = computed(() => {
    var Views2 = baseConfig.value.config.views;
    each(baseConfig.value.config.usePresets.concat(options.value.presets), (presetName) => {
      var preset = baseConfig.value.config.presets[presetName];
      if (!preset || !preset.views) {
        return;
      }
      Views2 = Object.assign({}, Views2, preset.views);
    });
    Views2 = Object.assign({}, Views2, options.value.views);
    return Views2;
  });
  var View = computed(() => {
    if (options.value.view) {
      return options.value.view;
    }
    return Views.value.Vueform;
  });
  var translations = computed(() => {
    var i18n2 = $this.$vueform.i18n;
    var locales = i18n2.locales;
    var currentLocale = locale.value || i18n2.locale;
    var fallbackLocale = i18n2.fallbackLocale || "en";
    return currentLocale ? merge_1({}, locales[fallbackLocale], locales[currentLocale]) : locales[fallbackLocale];
  });
  var update = function update2(data2) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (path) {
      el$2(path).update(data2);
      return;
    }
    each(elements$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (data2[element$.name] === void 0 && !element$.flat) {
        return;
      }
      element$.update(element$.flat ? data2 : data2[element$.name]);
    });
  };
  var load = function() {
    var _ref = _asyncToGenerator(function* (data2) {
      var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (steps$.value !== null) {
        steps$.value.enableAllSteps();
      }
      var formatted = format && options.value.formatLoad !== null ? options.value.formatLoad(data2) : data2;
      yield asyncForEach(elements$.value, function() {
        var _ref2 = _asyncToGenerator(function* (e$) {
          if (e$.isStatic) {
            return;
          }
          var loadValue = e$.flat ? formatted : formatted[e$.name];
          if (loadValue === void 0) {
            e$.clear();
            return;
          }
          yield e$.load(loadValue, format);
        });
        return function(_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    });
    return function load2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var reset = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.reset();
    });
    if (steps$.value !== null) {
      steps$.value.reset();
    }
    if (tabs$.value !== null) {
      tabs$.value.reset();
    }
    fire("reset");
  };
  var clear = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clear();
    });
    if (steps$.value !== null) {
      steps$.value.reset();
    }
    if (tabs$.value !== null) {
      tabs$.value.reset();
    }
    fire("clear");
  };
  var clean = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clean();
    });
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clearMessages();
    });
  };
  var validate = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (!invalid.value && validated.value && shouldValidateOnChange.value) {
        return;
      }
      var validatableElements = Object.values(elements$.value).filter((e$) => {
        return e$.available && !e$.isStatic && (!e$.validated || !shouldValidateOnChange.value);
      });
      yield asyncForEach(validatableElements, function() {
        var _ref4 = _asyncToGenerator(function* (e$) {
          yield e$.validate();
        });
        return function(_x3) {
          return _ref4.apply(this, arguments);
        };
      }());
    });
    return function validate2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.resetValidators();
    });
  };
  var scrollToFirstInvalid = () => {
    if (!options.value.scrollToInvalid) {
      return;
    }
    var _findFirstInvalid$ = function findFirstInvalid$(schema2) {
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var firstInvalid$2;
      Object.keys(schema2).forEach((key) => {
        if (firstInvalid$2) {
          return;
        }
        var path = prefix ? "".concat(prefix, ".").concat(key) : key;
        var e$ = el$2(path);
        if (e$ && !e$.isStatic && e$.available && e$.invalid) {
          if (e$.isObjectType || e$.isGroupType) {
            firstInvalid$2 = _findFirstInvalid$(e$.schema, path);
          } else if (e$.isListType) {
            firstInvalid$2 = _findFirstInvalid$(e$.children$, path);
          } else {
            firstInvalid$2 = e$;
          }
        }
      });
      return firstInvalid$2;
    };
    var firstInvalid$ = _findFirstInvalid$(orderedSchema.value);
    var scrollableParent = findScrollableParent(firstInvalid$.$el);
    if (firstInvalid$) {
      if (scrollableParent) {
        scrollIntoView(firstInvalid$.$el, scrollableParent);
      } else if (firstInvalid$.$el.scrollIntoView) {
        firstInvalid$.$el.scrollIntoView({
          behavior: "smooth"
        });
      }
    }
  };
  var submit = function() {
    var _ref5 = _asyncToGenerator(function* () {
      if (isDisabled.value) {
        return;
      }
      yield validate();
      if (invalid.value) {
        scrollToFirstInvalid();
        return;
      }
      preparing.value = true;
      try {
        yield prepareElements();
        if (typeof options.value.prepare === "function") {
          yield options.value.prepare(form$.value);
        }
        if (typeof $this.$vueform.config.beforeSend === "function") {
          yield $this.$vueform.config.beforeSend(form$.value);
        }
      } catch (error) {
        fire("error", error, {
          type: "prepare"
        }, form$.value);
        console.error(error);
        return;
      } finally {
        preparing.value = false;
      }
      var data2 = options.value.formData(form$.value);
      fire("submit", form$.value, data2);
      if (!options.value.endpoint) {
        return;
      }
      send();
    });
    return function submit2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var send = function() {
    var _ref6 = _asyncToGenerator(function* () {
      submitting.value = true;
      var response = {};
      try {
        var _response2, _response3;
        resetValidators();
        var _data = options.value.formData(form$.value);
        if (typeof options.value.endpoint === "function") {
          response = yield options.value.endpoint(_data, form$.value);
        } else {
          var _$this$$vueform$confi, _$this$$vueform$confi2;
          cancelToken.value = services.value.axios.CancelToken.source();
          var url2 = ((_$this$$vueform$confi = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi === void 0 ? void 0 : _$this$$vueform$confi.url) || options.value.endpoint;
          var _method = ((_$this$$vueform$confi2 = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi2 === void 0 ? void 0 : _$this$$vueform$confi2.method) || options.value.method;
          response = yield services.value.axios.request({
            url: url2,
            method: _method.toLowerCase(),
            [_method.toLowerCase() === "get" ? "params" : "data"]: _data,
            cancelToken: cancelToken.value.token
          });
        }
        if (response && !(response instanceof Promise)) {
          var _response;
          if ((_response = response) !== null && _response !== void 0 && (_response = _response.data) !== null && _response !== void 0 && (_response = _response.payload) !== null && _response !== void 0 && _response.updates) {
            update(response.data.payload.updates);
          }
        }
        if (((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.status) >= 200 && ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3.status) < 300) {
          fire("success", response, form$.value);
        } else {
          fire("error", {
            response
          }, {
            type: "submit"
          }, form$.value);
        }
      } catch (error) {
        if (error.response) {
          fire("error", error, {
            type: "submit"
          }, form$.value);
          fire("response", error.response, form$.value);
        } else if (services.value.axios.isCancel(error)) {
          fire("error", error, {
            type: "cancel"
          }, form$.value);
        } else {
          fire("error", error, {
            type: "other"
          }, form$.value);
        }
        console.error(error);
        return;
      } finally {
        cancelToken.value = null;
        submitting.value = false;
      }
      fire("response", response, form$.value);
    });
    return function send2() {
      return _ref6.apply(this, arguments);
    };
  }();
  var cancel = () => {
    if (!cancelToken.value) {
      return;
    }
    cancelToken.value.cancel();
  };
  var prepareElements = function() {
    var _ref7 = _asyncToGenerator(function* () {
      try {
        yield asyncForEach(elements$.value, function() {
          var _ref8 = _asyncToGenerator(function* (e$) {
            if (e$.prepare) {
              yield e$.prepare();
            }
          });
          return function(_x4) {
            return _ref8.apply(this, arguments);
          };
        }());
      } catch (e2) {
        throw new Error(e2);
      }
    });
    return function prepareElements2() {
      return _ref7.apply(this, arguments);
    };
  }();
  var disableValidation = () => {
    validation2.value = false;
  };
  var enableValidation = () => {
    validation2.value = true;
  };
  var enableConditions = () => {
    conditions.value = true;
  };
  var disableConditions = () => {
    conditions.value = false;
  };
  var setLanguage = (code) => {
    selectedLanguage.value = code;
    fire("language", code);
  };
  var handleSubmit = () => {
    submit();
  };
  var convertFormData = (data2) => {
    return _getFormData(data2);
  };
  var el$2 = (path, elements) => {
    if (elements === void 0) {
      elements = elements$.value;
    }
    if (isEmpty_1(elements) || !path) {
      return null;
    }
    var matches2 = String(path).match(/^[^.]+\./);
    if (matches2) {
      var current = matches2[0].replace(".", "");
      if (!elements[current]) {
        return null;
      }
      return el$2(path.replace(matches2[0], ""), elements[current].children$);
    } else if (elements[path] !== void 0) {
      return elements[path];
    }
    return null;
  };
  var siblings$ = (path) => {
    var _el$;
    if (!/\.+/.test(path)) {
      return elements$.value;
    }
    return ((_el$ = el$2(path.match(/.*(?=\.)/)[0])) === null || _el$ === void 0 ? void 0 : _el$.children$) || {};
  };
  var initMessageBag = () => {
    messageBag2.value = new services.value.messageBag(elementErrors);
  };
  provide("form$", form$);
  provide("theme", extendedTheme);
  provide("Size", Size);
  provide("Views", Views);
  provide("translations", translations);
  provide("config$", config$);
  initMessageBag();
  setLanguage(options.value.language);
  onBeforeMount(() => {
    userConfig.value = $this.vueform || {};
    each(evts, (evt) => {
      var callback57 = options.value["on" + upperFirst_1(evt)];
      if (callback57) {
        on2(evt, callback57);
      }
    });
    fire("beforeMount", $this);
  });
  onMounted(() => {
    mounted.value = true;
    watch(data, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, $this);
      if (externalValue && externalValue.value !== void 0) {
        context.emit("input", n2);
        context.emit("update:modelValue", n2);
      }
    }, {
      deep: true,
      immediate: false
    });
    if (externalValue && externalValue.value !== void 0 && JSON.stringify(externalValue.value) !== JSON.stringify(data.value)) {
      context.emit("input", data.value);
      context.emit("update:modelValue", data.value);
    }
    fire("mounted", $this);
  });
  onBeforeUpdate(() => fire("beforeUpdate", $this));
  onUpdated(() => fire("updated", $this));
  onBeforeUnmount(() => fire("beforeUnmount", $this));
  onUnmounted(() => fire("unmounted", $this));
  watch(computed(() => options.value.language), (n2, o2) => {
    if (n2) {
      setLanguage(n2);
    }
  });
  return {
    tabs$,
    steps$,
    elements$,
    options,
    validation: validation2,
    conditions,
    messageBag: messageBag2,
    selectedLanguage,
    submitting,
    preparing,
    cancelToken,
    events,
    listeners,
    internalData,
    data,
    requestData,
    dirty,
    invalid,
    debouncing,
    pending,
    validated,
    busy,
    formErrors,
    formMessages,
    isDisabled,
    isLoading,
    shouldValidateOnChange,
    shouldValidateOnStep,
    hasSteps,
    hasTabs,
    hasErrors,
    hasMessages,
    isMultilingual,
    showErrors,
    showMessages,
    showLanguages,
    showSteps,
    showTabs,
    showStepsControls,
    classes,
    Templates,
    template,
    extendedTheme,
    Size,
    View,
    Views,
    form$,
    model,
    intermediaryValue,
    userConfig,
    isSync,
    tree,
    flatTree,
    translations,
    locale$,
    prepareElements,
    updateModel,
    update,
    load,
    reset,
    clear,
    clean,
    clearMessages,
    validate,
    resetValidators,
    convertFormData,
    submit,
    scrollToFirstInvalid,
    send,
    cancel,
    disableValidation,
    enableValidation,
    enableConditions,
    disableConditions,
    setLanguage,
    handleSubmit,
    el$: el$2,
    siblings$,
    initMessageBag,
    fire,
    on: on2,
    off: off2,
    messagesRegistered,
    errorsRegistered,
    languagesRegistered,
    tabsRegistered,
    stepsRegistered
  };
};
var base$1c = function base3(props, context, dependencies2) {
  var componentName = context.name;
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var component$ = dependencies2.component$ || dependencies2.el$;
  var theme = dependencies2.theme;
  var Templates = dependencies2.Templates;
  var View = dependencies2.View;
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options, el$2.value]
    });
  });
  var classes = computed(() => {
    var _classesInstance$valu;
    return _objectSpread2$1({}, (_classesInstance$valu = classesInstance.value) === null || _classesInstance$valu === void 0 ? void 0 : _classesInstance$valu.classes);
  });
  return {
    classes,
    classesInstance
  };
};
var VueformComponent = {
  name: "Vueform",
  emits: ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  slots: ["default", "empty"],
  setup: (props, context) => {
    context.emits = ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
    context.name = ref("Vueform");
    var {
      tabs$,
      steps$,
      elements$,
      options,
      validation: validation2,
      conditions,
      messageBag: messageBag2,
      selectedLanguage,
      submitting,
      preparing,
      cancelToken,
      events,
      listeners,
      internalData,
      data,
      requestData,
      dirty,
      invalid,
      debouncing,
      pending,
      validated,
      busy,
      formErrors,
      formMessages,
      isDisabled,
      isLoading,
      shouldValidateOnChange,
      shouldValidateOnStep,
      hasSteps,
      hasTabs,
      hasErrors,
      hasMessages,
      isMultilingual,
      showErrors,
      showMessages,
      showLanguages,
      showSteps,
      showTabs,
      showStepsControls,
      classes,
      Templates,
      template,
      extendedTheme,
      Size,
      View,
      Views,
      form$,
      model,
      intermediaryValue,
      userConfig,
      isSync,
      tree,
      flatTree,
      translations,
      locale$,
      prepareElements,
      updateModel,
      update,
      load,
      reset,
      clear,
      clean,
      clearMessages,
      validate,
      resetValidators,
      convertFormData,
      submit,
      scrollToFirstInvalid,
      scrollOnNext,
      send,
      cancel,
      disableValidation,
      enableValidation,
      enableConditions,
      disableConditions,
      setLanguage,
      handleSubmit,
      el$: el$2,
      siblings$,
      initMessageBag,
      fire,
      on: on2,
      off: off2,
      messagesRegistered,
      errorsRegistered,
      languagesRegistered,
      tabsRegistered,
      stepsRegistered
    } = base$1d(props, context);
    return {
      tabs$,
      steps$,
      elements$,
      options,
      validation: validation2,
      conditions,
      messageBag: messageBag2,
      selectedLanguage,
      submitting,
      preparing,
      cancelToken,
      events,
      listeners,
      internalData,
      data,
      requestData,
      dirty,
      invalid,
      debouncing,
      pending,
      validated,
      busy,
      formErrors,
      formMessages,
      isDisabled,
      isLoading,
      shouldValidateOnChange,
      shouldValidateOnStep,
      hasSteps,
      hasTabs,
      hasErrors,
      hasMessages,
      isMultilingual,
      showErrors,
      showMessages,
      showLanguages,
      showSteps,
      showTabs,
      showStepsControls,
      classes,
      Templates,
      template,
      extendedTheme,
      Size,
      View,
      Views,
      form$,
      model,
      intermediaryValue,
      userConfig,
      isSync,
      tree,
      flatTree,
      translations,
      locale$,
      prepareElements,
      updateModel,
      update,
      load,
      reset,
      clear,
      clean,
      clearMessages,
      validate,
      resetValidators,
      convertFormData,
      submit,
      scrollToFirstInvalid,
      scrollOnNext,
      send,
      cancel,
      disableValidation,
      enableValidation,
      enableConditions,
      disableConditions,
      setLanguage,
      handleSubmit,
      el$: el$2,
      siblings$,
      initMessageBag,
      fire,
      on: on2,
      off: off2,
      messagesRegistered,
      errorsRegistered,
      languagesRegistered,
      tabsRegistered,
      stepsRegistered
    };
  },
  props: {
    schema: {
      type: Object,
      required: false,
      default: null
    },
    name: {
      type: String,
      required: false,
      default: null,
      private: true
    },
    tabs: {
      type: Object,
      required: false,
      default: null
    },
    steps: {
      type: Object,
      required: false,
      default: null
    },
    stepsControls: {
      type: Boolean,
      required: false,
      default: null,
      "@default": true
    },
    scrollOnNext: {
      type: Boolean,
      required: false,
      default: null
    },
    validateOn: {
      type: String,
      required: false,
      default: null
    },
    scrollToInvalid: {
      type: Boolean,
      required: false,
      default: null
    },
    showRequired: {
      type: Array,
      required: false,
      default: null
    },
    displayErrors: {
      type: Boolean,
      required: false,
      default: null
    },
    displayMessages: {
      type: Boolean,
      required: false,
      default: null
    },
    messages: {
      type: Object,
      required: false,
      default: null
    },
    endpoint: {
      type: [String, Boolean, Function, Promise],
      required: false,
      default: null
    },
    method: {
      type: String,
      required: false,
      default: null
    },
    prepare: {
      type: Function,
      required: false,
      default: null
    },
    formKey: {
      type: [String, Number],
      required: false,
      default: null
    },
    formData: {
      type: Function,
      required: false,
      default: null
    },
    value: {
      type: Object,
      required: false,
      default: void 0
    },
    modelValue: {
      type: Object,
      required: false,
      default: void 0
    },
    sync: {
      type: Boolean,
      required: false,
      default: false
    },
    default: {
      type: Object,
      required: false,
      default: null
    },
    forceNumbers: {
      required: false,
      type: [Boolean],
      default: null
    },
    formatData: {
      type: Function,
      required: false,
      default: null
    },
    formatLoad: {
      type: Function,
      required: false,
      default: null
    },
    loading: {
      type: Boolean,
      required: false,
      default: null
    },
    disabled: {
      type: [Boolean, Function, Object, Array],
      required: false,
      default: null
    },
    columns: {
      type: Object,
      required: false,
      default: null
    },
    forceLabels: {
      type: Boolean,
      required: false,
      default: null
    },
    floatPlaceholders: {
      type: Boolean,
      required: false,
      default: null
    },
    size: {
      required: false,
      type: [String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: null
    },
    views: {
      required: false,
      type: [Object],
      default: null
    },
    addClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    addClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    removeClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object, Function],
      default: null
    },
    replaceClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    templates: {
      type: Object,
      required: false,
      default: null
    },
    presets: {
      required: false,
      type: [Array],
      default: null
    },
    multilingual: {
      type: Boolean,
      required: false,
      default: null
    },
    languages: {
      type: Object,
      required: false,
      default: null
    },
    language: {
      type: String,
      required: false,
      default: null
    },
    locale: {
      type: String,
      required: false,
      default: null
    },
    providers: {
      type: [Object],
      required: false,
      default: null
    },
    useProviders: {
      type: [Object],
      required: false,
      default: null
    },
    providerOptions: {
      type: [Object],
      required: false,
      default: null
    },
    onChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onReset: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSubmit: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onResponse: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSuccess: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onLanguage: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeMount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onMounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUpdate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUpdated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUnmount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUnmounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  render() {
    return this.template.render.apply(this, arguments);
  }
  // staticRenderFns() {
  //   return this.templates.Vueform.staticRenderFns
  // }
};
var baseEach$1 = _baseEach;
var isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$3 = _arrayMap;
var baseIteratee$5 = _baseIteratee;
var baseMap$1 = _baseMap;
var isArray$4 = isArray_1;
function map(collection, iteratee) {
  var func = isArray$4(collection) ? arrayMap$3 : baseMap$1;
  return func(collection, baseIteratee$5(iteratee));
}
var map_1 = map;
var baseGetTag = _baseGetTag;
var isArray$3 = isArray_1;
var isObjectLike = isObjectLike_1;
var stringTag = "[object String]";
function isString$1(value) {
  return typeof value == "string" || !isArray$3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
var isString_1 = isString$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$2(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
}
var _baseTrim = baseTrim$2;
var baseIndexOf$2 = _baseIndexOf;
function charsEndIndex$1(strSymbols, chrSymbols) {
  var index2 = strSymbols.length;
  while (index2-- && baseIndexOf$2(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var _charsEndIndex = charsEndIndex$1;
var baseIndexOf$1 = _baseIndexOf;
function charsStartIndex$1(strSymbols, chrSymbols) {
  var index2 = -1, length = strSymbols.length;
  while (++index2 < length && baseIndexOf$1(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var _charsStartIndex = charsStartIndex$1;
var baseToString$2 = _baseToString;
var baseTrim$1 = _baseTrim;
var castSlice = _castSlice;
var charsEndIndex = _charsEndIndex;
var charsStartIndex = _charsStartIndex;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function trim(string2, chars, guard) {
  string2 = toString$3(string2);
  if (string2 && (guard || chars === void 0)) {
    return baseTrim$1(string2);
  }
  if (!string2 || !(chars = baseToString$2(chars))) {
    return string2;
  }
  var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
  return castSlice(strSymbols, start, end).join("");
}
var trim_1 = trim;
var Validator = class {
  constructor(rule, props) {
    var _props$element$;
    this.rule = rule;
    this.attributes = rule.attributes || {};
    this.conditions = rule.conditions || [];
    this.dependents = rule.dependents || [];
    this.element$ = props.element$;
    this.form$ = ((_props$element$ = props.element$) === null || _props$element$ === void 0 ? void 0 : _props$element$.form$) || {};
    this.numeric = props.numeric || false;
    this.elementMessages = props.element$.messages;
    this.invalid = false;
    this.pending = false;
    this.debouncer = null;
    this.lastValue = null;
    this.watchers = {};
    this.dependents.forEach((dependent) => {
      watch(computed(() => get_1(this.form$.data, dependent)), () => {
        if (this.element$.validated) {
          if (this.name === "nullable") {
            this.element$.validate();
          } else {
            this.revalidate();
          }
        }
      });
    });
    watch(computed(() => props.element$.messages), (n2, o2) => {
      if (isEqual_1(n2, o2)) {
        return;
      }
      this.elementMessages = props.element$.messages;
    }, {
      deep: true
    });
    this.init();
  }
  get moment() {
    return this.form$.$vueform.services.moment;
  }
  get name() {
    return this.rule.name;
  }
  get failing() {
    return this.invalid;
  }
  get defaultMessage() {
    return this.form$.translations.vueform.defaultMessage;
  }
  get message() {
    var _this$form$$translati;
    var message = "";
    if (this.msg) {
      message = this.msg;
    } else if (this.elementMessages[this.name]) {
      message = this.elementMessages[this.name];
    } else if (this.form$.options.messages[this.name]) {
      message = this.form$.options.messages[this.name];
    } else if (this.name !== "_class" && ((_this$form$$translati = this.form$.translations.validation) === null || _this$form$$translati === void 0 ? void 0 : _this$form$$translati[this.name]) !== void 0) {
      message = this.form$.translations.validation[this.name];
      if (isPlainObject_1(message)) {
        message = message[this.messageType];
      }
    } else {
      message = this.defaultMessage;
    }
    each(map_1(message.match(/:\w+/g), (p) => p.replace(":", "")), (param) => {
      message = message.replace(":".concat(param), this.messageParams[param]);
    });
    each(map_1(message.match(/{[^}]+/g), (p) => p.replace("{", "")), (param) => {
      message = message.replace("{".concat(param, "}"), this.messageParams[param]);
    });
    return message;
  }
  get messageType() {
    if (this.isNumeric) {
      return "numeric";
    } else if (this.isFile) {
      return "file";
    } else if (this.isArray) {
      return "array";
    }
    return "string";
  }
  get messageParams() {
    return {
      attribute: this.attributeName
    };
  }
  get attributeName() {
    return this.element$.genericName;
  }
  get type() {
    if (this.isNumeric) {
      return "numeric";
    } else if (this.isFile) {
      return "file";
    } else if (this.isArray) {
      return "array";
    }
    return "string";
  }
  get isNumeric() {
    return some_1(this.element$.Validators, {
      name: "numeric"
    }) || some_1(this.element$.Validators, {
      name: "integer"
    });
  }
  get isNullable() {
    var nullable2 = false;
    each(this.element$.Validators, (Validator2) => {
      if (Validator2.name !== "nullable") {
        return;
      }
      if (!Validator2.conditions.length) {
        nullable2 = true;
        return;
      }
      nullable2 = Validator2.conditions(this.form$, this, this.element$);
    });
    return nullable2;
  }
  get isFile() {
    return this.element$.isFileType;
  }
  get isArray() {
    return this.element$.isArrayType;
  }
  get isAsync() {
    return false;
  }
  get debounce() {
    if (this.attributes.debounce) {
      return this.attributes.debounce;
    }
    if (this.element$.debounce) {
      return this.element$.debounce;
    }
    return false;
  }
  get debouncing() {
    return this.debouncer !== null;
  }
  init() {
  }
  validate(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (value === void 0) {
        var _this$element$;
        value = (_this$element$ = _this.element$) === null || _this$element$ === void 0 ? void 0 : _this$element$.value;
      }
      if (!_this.form$.validation) {
        return;
      }
      if (_this.isNullable && !_this.filled(value)) {
        _this.invalid = false;
        return;
      }
      if (_this.conditions.length) {
        if (!_this.conditions(_this.form$, _this, _this.element$)) {
          _this.invalid = false;
          return;
        }
      }
      if (_this.debounce && _this.filled(value)) {
        yield _this._validateWithDebounce(value);
      } else {
        if (_this.debounce && _this.debouncer) {
          clearTimeout(_this.debouncer);
        }
        yield _this._validate(value);
      }
    })();
  }
  replaceParams(message) {
    each(map_1(message.match(/:\w+/g), (p) => p.replace(":", "")), (param) => {
      message = message.replace(":".concat(param), this.messageParams[param]);
    });
    each(map_1(message.match(/{[^}]+/g), (p) => p.replace("{", "")), (param) => {
      message = message.replace("{".concat(param, "}"), this.messageParams[param]);
    });
    return message;
  }
  reset() {
    this.invalid = false;
  }
  watch(variables) {
    if (!Array.isArray(variables)) {
      variables = [variables];
    }
    variables.forEach((variable) => {
      this.addWatcher(variable);
    });
  }
  addWatcher(variable) {
    if (this.watchers[variable]) {
      return;
    }
    this.watchers[variable] = watch(computed(() => get_1(this.form$.data, variable)), () => {
      this.revalidate();
    });
  }
  revalidate() {
    this.element$.Validators.forEach((Validator2) => {
      if (Validator2.rule.name === this.rule.name) {
        Validator2.validate();
      }
    });
  }
  watchOther() {
    this.form$.$nextTick(() => {
      if (!this.other$) {
        return;
      }
      this.form$.$watch(() => {
        var _this$other$;
        return (_this$other$ = this.other$) === null || _this$other$ === void 0 ? void 0 : _this$other$.value;
      }, () => {
        if (this.element$.validated) {
          this.element$.validate();
        }
      });
    });
  }
  size(value) {
    if (this.isNumeric) {
      if (!isNaN(value)) {
        var num = parseFloat(value);
        if (Number.isInteger(num)) {
          return parseInt(value);
        }
        return num;
      }
      return null;
    } else if (this.isFile) {
      return value ? value.size / 1e3 : 0;
    } else if (this.isArray) {
      return value.length;
    } else if (value === null) {
      return 0;
    } else if (value === void 0) {
      return 0;
    } else if (value === "") {
      return 0;
    }
    return String(value).length;
  }
  filled(value) {
    if (value === void 0 || value === null && value !== this.element$.trueValue || value === this.element$.falseValue) {
      return false;
    } else if (this.isNumeric && trim_1(value) === "") {
      return false;
    } else if (isString_1(value) && trim_1(value) === "") {
      return false;
    } else if (isArray_1(value) && value.length < 1) {
      return false;
    } else if (value instanceof File && value.name === "") {
      return false;
    }
    return true;
  }
  _validate(value) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.isAsync) {
        yield _this2._validateAsync(value);
      } else {
        _this2._validateSync(value);
      }
    })();
  }
  _validateAsync(value) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      _this3.lastValue = value;
      _this3.pending = true;
      var valid = yield _this3.check(value);
      if (dataEquals(_this3.lastValue, value)) {
        _this3.invalid = !valid;
        _this3.pending = false;
      }
    })();
  }
  _validateSync(value) {
    this.invalid = !this.check(value);
  }
  _validateWithDebounce(value) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      return new Promise((resolve, reject) => {
        if (_this4.debouncer) {
          resolve();
          clearTimeout(_this4.debouncer);
        }
        _this4.debouncer = setTimeout(_asyncToGenerator(function* () {
          yield _this4._validate(value);
          _this4.debouncer = null;
          resolve();
        }), _this4.debounce);
      });
    })();
  }
};
function last$1(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? array4[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet$2 = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object9, path) {
  return path.length < 2 ? object9 : baseGet$2(object9, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$2 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object9, path) {
  path = castPath$2(path, object9);
  object9 = parent(object9, path);
  return object9 == null || delete object9[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var baseFlatten$3 = _baseFlatten;
function flatten$2(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten$3(array4, 1) : [];
}
var flatten_1 = flatten$2;
var flatten$1 = flatten_1;
var overRest = _overRest;
var setToString = _setToString;
function flatRest$2(func) {
  return setToString(overRest(func, void 0, flatten$1), func + "");
}
var _flatRest = flatRest$2;
var arrayMap$2 = _arrayMap;
var baseClone$1 = _baseClone;
var baseUnset = _baseUnset;
var castPath$1 = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest$1 = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG$1 = 4;
var omit = flatRest$1(function(object9, paths) {
  var result = {};
  if (object9 == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$2(paths, function(path) {
    path = castPath$1(path, object9);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object9, getAllKeysIn(object9), result);
  if (isDeep) {
    result = baseClone$1(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath = _castPath;
function basePickBy$1(object9, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet$1(object9, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object9), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object9, paths) {
  return basePickBy(object9, paths, function(value, path) {
    return hasIn(object9, path);
  });
}
var _basePick = basePick$1;
var basePick = _basePick;
var flatRest = _flatRest;
var pick = flatRest(function(object9, paths) {
  return object9 == null ? {} : basePick(object9, paths);
});
var pick_1 = pick;
var SetCache = _SetCache;
var arrayIncludes = _arrayIncludes;
var arrayIncludesWith = _arrayIncludesWith;
var arrayMap$1 = _arrayMap;
var baseUnary$1 = _baseUnary;
var cacheHas = _cacheHas;
var LARGE_ARRAY_SIZE = 200;
function baseDifference$2(array4, values2, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array4.length, result = [], valuesLength = values2.length;
  if (!length) {
    return result;
  }
  if (iteratee) {
    values2 = arrayMap$1(values2, baseUnary$1(iteratee));
  }
  if (comparator) {
    includes2 = arrayIncludesWith;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE) {
    includes2 = cacheHas;
    isCommon = false;
    values2 = new SetCache(values2);
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed2) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(values2, computed2, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var _baseDifference = baseDifference$2;
var baseDifference$1 = _baseDifference;
var baseRest$2 = _baseRest;
var isArrayLikeObject$1 = isArrayLikeObject_1;
var without = baseRest$2(function(array4, values2) {
  return isArrayLikeObject$1(array4) ? baseDifference$1(array4, values2) : [];
});
var without_1 = without;
function isBuffer(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key) {
  return key;
}
function flatten(target, opts) {
  opts = opts || {};
  var delimiter = opts.delimiter || ".";
  var maxDepth = opts.maxDepth;
  var transformKey = opts.transformKey || keyIdentity;
  var output = {};
  function step(object9, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object9).forEach(function(key) {
      var value = object9[key];
      var isarray = opts.safe && Array.isArray(value);
      var type = Object.prototype.toString.call(value);
      var isbuffer = isBuffer(value);
      var isobject = type === "[object Object]" || type === "[object Array]";
      var newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
var baseDifference = _baseDifference;
var baseFlatten$2 = _baseFlatten;
var baseRest$1 = _baseRest;
var isArrayLikeObject = isArrayLikeObject_1;
var difference = baseRest$1(function(array4, values2) {
  return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten$2(values2, 1, isArrayLikeObject, true)) : [];
});
var difference_1 = difference;
function shouldApplyPlugin(name2, plugin) {
  if (!plugin.apply && difference_1(Object.keys(plugin), ["config", "install"]).length > 0) {
    return true;
  }
  var apply2 = plugin.apply;
  if (!Array.isArray(apply2)) {
    apply2 = [apply2];
  }
  var shouldApply = false;
  each(apply2, (condition2) => {
    if (typeof condition2 === "string" && condition2 === name2) {
      shouldApply = true;
      return false;
    } else if (typeof condition2 === "object" && condition2 instanceof RegExp && name2.match(condition2)) {
      shouldApply = true;
      return false;
    }
  });
  return shouldApply;
}
var name = "@vueform/vueform";
var version$1 = "1.10.10";
var description = "Open-Source Form Framework for Vue";
var homepage = "https://vueform.com";
var license = "MIT";
var authors = [
  {
    name: "Adam Berecz",
    email: "adam@vueform.com"
  }
];
var sideEffects = [
  "./themes/tailwind/templates/**/*.css",
  "./themes/vueform/templates/**/*.css"
];
var main = "./dist/index.mjs";
var module = "./dist/index.mjs";
var types = "./types/index.d.ts";
var exports = {
  ".": {
    types: "./types/index.d.ts",
    "default": "./dist/index.mjs"
  },
  "./core": {
    types: "./types/index.d.ts",
    "default": "./dist/core.mjs"
  },
  "./core.js": {
    types: "./types/index.d.ts",
    "default": "./dist/core.mjs"
  },
  "./element": "./element.mjs",
  "./element.js": "./element.mjs",
  "./plugin": "./plugin.mjs",
  "./plugin.js": "./plugin.mjs",
  "./locales/*.js": "./locales/*/index.mjs",
  "./locales/*": "./locales/*/index.mjs",
  "./src/*": "./src/*",
  "./src/components": "./src/components/index.js",
  "./src/services/validation/rules": "./src/services/validation/rules/index.js",
  "./types/*": "./types/*",
  "./dist/*.js": "./dist/*.mjs",
  "./dist/*": "./dist/*.mjs",
  "./dist/*.css": "./dist/*.css",
  "./tailwind": "./tailwind.js",
  "./tailwind.js": "./tailwind.js",
  "./vite": "./vite.js",
  "./vite.js": "./vite.js",
  "./vite.d.ts": "./vite.d.ts",
  "./tailwind-prefixer": "./tailwind-prefixer.js",
  "./tailwind-prefixer.js": "./tailwind-prefixer.js",
  "./postcss.config": "./postcss.config.js",
  "./postcss.config.js": "./postcss.config.js",
  "./tailwind.config": "./tailwind.config.js",
  "./tailwind.config.js": "./tailwind.config.js",
  "./package.json": "./package.json",
  "./themes/blank/templates/*": "./themes/blank/templates/*",
  "./themes/blank/*": "./themes/blank/*.mjs",
  "./themes/blank/*.js": "./themes/blank/*.mjs",
  "./themes/bootstrap/css/*": "./themes/bootstrap/css/*",
  "./themes/bootstrap/scss/*": "./themes/bootstrap/scss/*",
  "./themes/bootstrap/*": "./themes/bootstrap/*.mjs",
  "./themes/bootstrap/*.js": "./themes/bootstrap/*.mjs",
  "./themes/bootstrap.js": "./themes/bootstrap/index.mjs",
  "./themes/material/css/*": "./themes/material/css/*",
  "./themes/material/scss/*": "./themes/material/scss/*",
  "./themes/material/*": "./themes/material/*.mjs",
  "./themes/material/*.js": "./themes/material/*.mjs",
  "./themes/material.js": "./themes/material/index.mjs",
  "./themes/tailwind/templates/*": "./themes/tailwind/templates/*",
  "./themes/tailwind/*": "./themes/tailwind/*.mjs",
  "./themes/tailwind/*.js": "./themes/tailwind/*.mjs",
  "./themes/tailwind.js": "./themes/tailwind/index.mjs",
  "./themes/tailwind-material/css/*": "./themes/tailwind-material/css/*",
  "./themes/tailwind-material/scss/*": "./themes/tailwind-material/scss/*",
  "./themes/tailwind-material/*": "./themes/tailwind-material/*.mjs",
  "./themes/tailwind-material/*.js": "./themes/tailwind-material/*.mjs",
  "./themes/tailwind-material.js": "./themes/tailwind-material/index.mjs",
  "./themes/vueform/css/*": "./themes/vueform/css/*",
  "./themes/vueform/scss/*": "./themes/vueform/scss/*",
  "./themes/vueform/templates/*": "./themes/vueform/templates/*",
  "./themes/vueform/*": "./themes/vueform/*.mjs",
  "./themes/vueform/*.js": "./themes/vueform/*.mjs",
  "./themes/vueform.js": "./themes/vueform/index.mjs",
  "./themes/*": {
    types: "./dist/*.d.mts",
    "default": "./themes/*/index.mjs"
  }
};
var scripts = {
  build: "npm run build3 && npm run build2 && npm run generate",
  build2: "node ./scripts/pre-build-vue2 && rollup --config build/rollup.vue2.config.js && node ./scripts/post-build-vue2",
  build3: "rollup --config build/rollup.config.js",
  test: 'npm run generate:elements-base && NODE_OPTIONS="--max_old_space_size=5120 --no-experimental-fetch" VUE=3 jest --config=./tests/jest.config.js',
  "generate:types": "npx babel-node  scripts/generate-types.js --presets @babel/preset-env",
  "generate:common-features": "npx babel-node scripts/generate-common-features.js --presets @babel/preset-env",
  "generate:element-features": "npx babel-node scripts/generate-element-features.js --presets @babel/preset-env",
  "generate:elements-base": "npx babel-node scripts/generate-elements-base.js --presets @babel/preset-env",
  "generate:elements": "npx babel-node scripts/generate-elements.js --presets @babel/preset-env",
  "generate:components": "npx babel-node scripts/generate-components.js --presets @babel/preset-env",
  generate: "npm run generate:common-features; npm run generate:element-features; npm run generate:elements-base; npm run generate:elements; npm run generate:components; npm run generate:types; npm run fix-locales",
  "fix-locales": "npx babel-node --presets @babel/preset-env ./scripts/fix-locales.js"
};
var devDependencies = {
  "@babel/core": "^7.2.2",
  "@babel/node": "^7.12.10",
  "@babel/preset-env": "^7.3.1",
  "@rollup/plugin-alias": "^5.1.0",
  "@rollup/plugin-babel": "^5.3.0",
  "@rollup/plugin-commonjs": "^22.0.1",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "@testing-library/jest-dom": "^5.11.5",
  "@vue/compiler-sfc": "^3.0.0",
  "@vue/test-utils": "2.0.0-rc.16",
  autoprefixer: "^9",
  autosize: "^6.0.1",
  "babel-core": "^7.0.0-bridge.0",
  "babel-loader": "^8.0.5",
  "core-js": "^3.10.1",
  "css-loader": "^2.1.0",
  flatpickr: "^4.6.13",
  "flush-promises": "^1.0.2",
  "html-loader": "^1.3.2",
  jest: "^27.3.1",
  "jest-canvas-mock": "^2.3.1",
  "jest-environment-jsdom-sixteen": "^1.0.3",
  "jest-transform-stub": "^2.0.0",
  "json-loader": "^0.5.7",
  locutus: "^2.0.16",
  "module-alias": "^2.2.3",
  moxios: "^0.4.0",
  "mutationobserver-shim": "^0.3.7",
  ncp: "^2.0.0",
  "rollup-plugin-license": "^3.2.0",
  "rollup-plugin-postcss": "^4.0.1",
  "rollup-plugin-terser": "^7.0.2",
  "rollup-plugin-vue": "^6.0.0",
  "rollup-plugin-vue2": "npm:rollup-plugin-vue@^5.1.9",
  "sass-loader": "^7.1.0",
  signature_pad: "^5.0.2",
  sortablejs: "^1.15.0",
  tailwindcss: "npm:@tailwindcss/postcss7-compat@^2.0.2",
  vue: "3.3.13",
  "vue-jest": "npm:@vue/vue3-jest@^27.0.0-alpha.1",
  "vue-loader": "^15.10.0",
  "vue-template-compiler": "^2.7.8",
  vue2: "npm:vue@^2.7.0"
};
var dependencies = {
  "@popperjs/core": "^2.11.8",
  "@vueform/country-phones": "^1.0.3",
  "@vueform/multiselect": "^2.6.10",
  "@vueform/slider": "^2.1.10",
  "@vueform/toggle": "^2.1.4",
  axios: "^1.7.2",
  color: "^4.2.3",
  lodash: "^4.17.21",
  "mini-svg-data-uri": "^1.4.4",
  moment: "^2.30.1",
  nouislider: "^15.8.0",
  sass: "^1.66.1",
  trix: "^2.1.1",
  wnumb: "^1.2.0"
};
var packageJson = {
  "private": false,
  name,
  version: version$1,
  description,
  homepage,
  license,
  authors,
  sideEffects,
  main,
  module,
  types,
  exports,
  scripts,
  devDependencies,
  dependencies
};
var normalize = function normalize2(value) {
  if (value === void 0 || typeof value != "string") {
    return value;
  }
  if (value.match(/^-*\d+$/)) {
    return parseInt(value, 10);
  } else if (value.match(/^\d+\.\d+$/)) {
    return parseFloat(value);
  } else {
    return value;
  }
};
var parse = (string2) => {
  var parseRule = () => {
    return string2.split(":")[0];
  };
  var parseAttributes = () => {
    var parts = string2.split(":");
    if (parts.length <= 1) {
      return null;
    }
    var attributes = {};
    var rule = parts[0];
    parts.shift();
    var params = parts.join(":");
    if (["regex", "not_regex"].indexOf(rule) !== -1) {
      attributes[0] = params;
      return attributes;
    }
    each(params.split(","), (attribute, index2) => {
      var attrParts = attribute.split("=");
      if (attrParts.length <= 1) {
        attributes[index2] = normalize(attribute);
      } else {
        attributes[attrParts[0]] = normalize(attrParts[1]);
      }
    });
    return attributes;
  };
  return {
    name: parseRule(),
    attributes: parseAttributes()
  };
};
function replaceWildcards(fillable, fill) {
  if (!fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g)) {
    return fillable;
  }
  fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g).forEach((match) => {
    fillable = fillable.replace(".*", match);
  });
  return fillable;
}
var baseTrim = _baseTrim;
var isObject = isObject_1;
var isSymbol$1 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$5(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$5;
var baseIndexOf = _baseIndexOf;
var isArrayLike$1 = isArrayLike_1;
var isString = isString_1;
var toInteger$4 = toInteger_1;
var values = values_1;
var nativeMax$2 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike$1(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger$4(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$2(length + fromIndex, 0);
  }
  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}
var includes_1 = includes;
function baseClamp$2(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$2;
var baseClamp$1 = _baseClamp;
var baseToString$1 = _baseToString;
var toInteger$3 = toInteger_1;
var toString$2 = toString_1;
function startsWith(string2, target, position) {
  string2 = toString$2(string2);
  position = position == null ? 0 : baseClamp$1(toInteger$3(position), 0, string2.length);
  target = baseToString$1(target);
  return string2.slice(position, position + target.length) == target;
}
var startsWith_1 = startsWith;
var baseClamp = _baseClamp;
var baseToString = _baseToString;
var toInteger$2 = toInteger_1;
var toString$1 = toString_1;
function endsWith(string2, target, position) {
  string2 = toString$1(string2);
  target = baseToString(target);
  var length = string2.length;
  position = position === void 0 ? length : baseClamp(toInteger$2(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string2.slice(position, end) == target;
}
var endsWith_1 = endsWith;
function compare(actual, operator, expected, el$2, form$) {
  if (!operator) {
    return false;
  }
  actual = Array.isArray(actual) ? actual.map((e2) => normalize(e2)) : normalize(actual);
  expected = Array.isArray(expected) ? expected.map((e2) => normalize(e2)) : normalize(expected);
  var moment = form$.$vueform.services.moment;
  switch (operator.toLowerCase()) {
    case ">":
      return isArray_1(actual) ? actual.every((a) => a > expected) : actual > expected;
    case ">=":
      return isArray_1(actual) ? actual.every((a) => a >= expected) : actual >= expected;
    case "<":
      return isArray_1(actual) ? actual.every((a) => a < expected) : actual < expected;
    case "<=":
      return isArray_1(actual) ? actual.every((a) => a <= expected) : actual <= expected;
    case "between":
      return actual > expected[0] && actual < expected[1];
    case "empty":
      if (isArray_1(actual)) {
        return !actual.length;
      } else if (actual && actual instanceof File) {
        return false;
      } else if (actual && actual instanceof Blob) {
        return false;
      } else if (actual && typeof actual === "object") {
        var values2 = Object.values(actual);
        return !values2.length || values2.every((v) => ["", null, void 0].indexOf(v) !== -1);
      } else {
        return ["", null, void 0].indexOf(actual) !== -1;
      }
    case "not_empty":
      if (isArray_1(actual)) {
        return !!actual.length;
      } else if (actual && actual instanceof File) {
        return true;
      } else if (actual && actual instanceof Blob) {
        return true;
      } else if (actual && typeof actual === "object") {
        var _values = Object.values(actual);
        return _values.length && _values.some((v) => ["", null, void 0].indexOf(v) === -1);
      } else {
        return ["", null, void 0].indexOf(actual) === -1;
      }
    case "==":
    case "in":
      if (isArray_1(expected)) {
        if (isArray_1(actual)) {
          return !expected.length ? !actual.length : actual.filter((a) => includes_1(expected, a)).length > 0;
        } else {
          return expected.indexOf(actual) !== -1;
        }
      } else {
        if (isArray_1(actual)) {
          return actual.indexOf(expected) !== -1;
        } else {
          return actual == expected;
        }
      }
    case "!=":
    case "not_in":
      if (isArray_1(expected)) {
        if (isArray_1(actual)) {
          return !expected.length ? !!actual.length : actual.filter((e2) => includes_1(expected, e2)).length == 0;
        } else {
          return expected.indexOf(actual) === -1;
        }
      } else {
        if (isArray_1(actual)) {
          return actual.indexOf(expected) === -1;
        } else {
          return actual != expected;
        }
      }
    case "today":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => moment(a, el$2.valueDateFormat).isSame(moment(), "day"));
    case "before":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => {
        var date6 = moment(a, el$2.valueDateFormat);
        return date6.isValid() && date6.isBefore(moment(expected === "today" ? void 0 : expected), "day");
      });
    case "after":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => {
        var date6 = moment(a, el$2.valueDateFormat);
        return date6.isValid() && date6.isAfter(moment(expected === "today" ? void 0 : expected), "day");
      });
    case "^":
      return startsWith_1(actual, expected);
    case "$":
      return endsWith_1(actual, expected);
    case "*":
      return includes_1(actual, expected);
    default:
      var customOperators = form$.$vueform.config.operators || {};
      if (customOperators[operator]) {
        return customOperators[operator](actual, expected, el$2, form$);
      }
  }
}
var Factory = class {
  constructor(path, form$) {
    this.form$ = form$;
    this.element$ = form$.el$(path);
  }
  get rules() {
    var rules2 = Object.assign({}, this.form$.$vueform.services.validation.rules, this.form$.$vueform.rules);
    if (!rules2.in && rules2.in_) {
      rules2.in = rules2.in_;
    }
    return rules2;
  }
  makeAll(rules2) {
    var parsedRules = this.parseRules(rules2);
    if (parsedRules.length == 0) {
      return [];
    }
    return map_1(parsedRules, (rule) => {
      return this.make(rule);
    });
  }
  make(rule) {
    var ruleClass = typeof rule == "function" ? rule : Array.isArray(rule) ? rule[0] : this.rules[rule.name];
    if (!ruleClass) {
      throw new Error("Unknown rule: '".concat(rule.name, "'"));
    }
    return new ruleClass(rule !== null && rule !== void 0 && rule.name ? rule : {
      name: "custom_rule_".concat(Math.floor(Math.random() * 9e6) + 1e6),
      attributes: Array.isArray(rule) && rule[1] ? rule[1] : []
    }, {
      element$: this.element$
    });
  }
  parseRules(rules2) {
    if (!isArray_1(rules2)) {
      rules2 = rules2.split("|");
    }
    return rules2.map((rule) => {
      if (typeof rule == "function" || Array.isArray(rule)) {
        return rule;
      }
      return this.isConditional(rule) ? this.parseConditional(rule) : this.parse(rule);
    });
  }
  parse(rule) {
    return parse(rule);
  }
  isConditional(rule) {
    return isPlainObject_1(rule);
  }
  parseConditional(rule) {
    var _conditions = values_1(rule)[0];
    if (!Array.isArray(_conditions[0])) {
      _conditions = [_conditions];
    }
    var parsed = _objectSpread2$1(_objectSpread2$1({}, parse(keys_1(rule)[0])), {}, {
      conditions: (form$, Validator2, el$2) => {
        return _conditions.every((condition2) => {
          if (isArray_1(condition2)) {
            if (isArray_1(condition2[0])) {
              return condition2.some((subcondition) => {
                if (isArray_1(subcondition)) {
                  return this.createConditionFromArray(subcondition)(form$, Validator2, el$2);
                } else {
                  return condition2(form$, Validator2, el$2);
                }
              });
            } else {
              return this.createConditionFromArray(condition2)(form$, Validator2, el$2);
            }
          } else {
            return condition2(form$, Validator2, el$2);
          }
        });
      },
      dependents: []
    });
    _conditions.forEach((condition2) => {
      if (isArray_1(condition2)) {
        if (isArray_1(condition2[0])) {
          condition2.forEach((subcondition) => {
            if (isArray_1(subcondition)) {
              parsed.dependents.push(replaceWildcards(subcondition[0], this.element$.path));
            }
          });
        } else {
          parsed.dependents.push(replaceWildcards(condition2[0], this.element$.path));
        }
      }
    });
    return parsed;
  }
  createConditionFromArray(condition2) {
    var field = replaceWildcards(condition2[0], this.element$.path);
    var operator = condition2.length == 3 || ["empty", "not_empty", "today"].indexOf(condition2[1]) !== -1 ? condition2[1] : "==";
    var value = condition2.length == 3 ? condition2[2] : ["empty", "not_empty", "today"].indexOf(condition2[1]) === -1 ? condition2[1] : true;
    return (form$, Validator2, el$2) => {
      var actual = get_1(form$.requestData, field);
      var expected = value;
      return compare(actual, operator, expected, this.element$, form$);
    };
  }
};
var accepted = class extends Validator {
  check(value) {
    return ["yes", "on", "1", 1, true, "true"].indexOf(value) !== -1;
  }
};
var active_url = class extends Validator {
  get isAsync() {
    return true;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var endpoint = _this.form$.$vueform.config.endpoints.activeUrl;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            url: value
          }
        });
      }
      return res.data;
    })();
  }
};
var after = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      date: this.date.format(this.format)
    };
  }
  get param() {
    return this.attributes[0];
  }
  get format() {
    return ["date", "dates"].indexOf(this.element$.type) !== -1 && this.element$.valueFormat ? this.element$.valueFormat : "YYYY-MM-DD";
  }
  get otherFormat() {
    if (this.dateType != "element") {
      return this.format;
    }
    return ["date", "dates"].indexOf(this.other$.type) !== -1 && this.other$.valueFormat ? this.other$.valueFormat : this.format;
  }
  get otherPath() {
    if (this.dateType != "element") {
      return null;
    }
    return this.param;
  }
  get other$() {
    if (this.dateType != "element") {
      return {};
    }
    return this.form$.el$(this.param);
  }
  get date() {
    var date6 = "";
    switch (this.dateType) {
      case "relative":
        if (this.param === "today") {
          date6 = this.moment().startOf("day");
        }
        if (this.param === "tomorrow") {
          date6 = this.moment().startOf("day").add(1, "days");
        }
        if (this.param === "yesterday") {
          date6 = this.moment().startOf("day").subtract(1, "days");
        }
        break;
      case "element":
        date6 = this.moment(this.other$.value, this.otherFormat);
        break;
      case "absolute":
        date6 = this.moment(this.param, this.format);
        break;
    }
    return date6;
  }
  get dateType() {
    if (["today", "tomorrow", "yesterday"].indexOf(this.param) !== -1) {
      return "relative";
    } else if (this.form$.el$(this.param)) {
      return "element";
    } else {
      return "absolute";
    }
  }
  init() {
    this.form$.$nextTick(() => {
      if (this.dateType == "element") {
        this.watchOther();
      }
    });
  }
  check(value) {
    if (isArray_1(value)) {
      var valid = true;
      each(value, (date6) => {
        if (!this.checkDate(date6)) {
          valid = false;
        }
      });
      return valid;
    }
    return this.checkDate(value);
  }
  checkDate(value) {
    return this.moment(value, this.format).isAfter(this.moment(this.date, this.otherFormat));
  }
};
var after_or_equal = class extends after {
  checkDate(value) {
    return this.moment(value, this.format).isSameOrAfter(this.moment(this.date, this.otherFormat));
  }
};
var alpha = class extends Validator {
  check(value) {
    return /^[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var alpha_dash = class extends Validator {
  check(value) {
    return /^[0-9-_\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var alpha_num = class extends Validator {
  check(value) {
    return /^[0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var array$2 = class extends Validator {
  check(value) {
    return isArray_1(value);
  }
};
var before = class extends after {
  checkDate(value) {
    return this.moment(value, this.format).isBefore(this.moment(this.date, this.otherFormat));
  }
};
var before_or_equal = class extends after {
  checkDate(value) {
    return this.moment(value, this.format).isSameOrBefore(this.moment(this.date, this.otherFormat));
  }
};
var between = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min,
      max: this.max
    };
  }
  get min() {
    return this.attributes[0];
  }
  get max() {
    return this.attributes[1];
  }
  check(value) {
    if (typeof value !== "number" && !value) {
      return true;
    }
    var size2 = this.size(value);
    return size2 >= this.min && size2 <= this.max;
  }
};
var boolean$1 = class extends Validator {
  check(value) {
    var accepted2 = [true, false, 0, 1, "0", "1"];
    return accepted2.indexOf(value) !== -1;
  }
};
var captcha$2 = class extends Validator {
  get isAsync() {
    return true;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (!_this.element$.shouldVerify) {
        return true;
      }
      return yield _this.element$.Provider.validate(_this.element$.Provider.getResponse());
    })();
  }
};
var completed = class extends Validator {
  get debounce() {
    if (this.attributes.debounce !== void 0) {
      return this.attributes.debounce;
    }
    if (this.element$.debounce !== null) {
      return this.element$.debounce;
    }
    return 1e3;
  }
  check(value) {
    var _this$element$$Mask$m;
    if (!this.element$.Mask) {
      return this.filled(value);
    }
    var isComplete = (_this$element$$Mask$m = this.element$.Mask.masked.currentMask) === null || _this$element$$Mask$m === void 0 ? void 0 : _this$element$$Mask$m.isComplete;
    return isComplete === void 0 || this.element$.empty ? true : isComplete;
  }
};
var confirmed = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get otherPath() {
    return "".concat(this.element$.path, "_confirmation");
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(this.other$.value)) {
      return true;
    }
    return value == this.other$.value;
  }
};
var reSpace = "[ \\t]+";
var reSpaceOpt = "[ \\t]*";
var reMeridian = "(?:([ap])\\.?m\\.?([\\t ]|$))";
var reHour24 = "(2[0-4]|[01]?[0-9])";
var reHour24lz = "([01][0-9]|2[0-4])";
var reHour12 = "(0?[1-9]|1[0-2])";
var reMinute = "([0-5]?[0-9])";
var reMinutelz = "([0-5][0-9])";
var reSecond = "(60|[0-5]?[0-9])";
var reSecondlz = "(60|[0-5][0-9])";
var reFrac = "(?:\\.([0-9]+))";
var reDayfull = "sunday|monday|tuesday|wednesday|thursday|friday|saturday";
var reDayabbr = "sun|mon|tue|wed|thu|fri|sat";
var reDaytext = reDayfull + "|" + reDayabbr + "|weekdays?";
var reReltextnumber = "first|second|third|fourth|fifth|sixth|seventh|eighth?|ninth|tenth|eleventh|twelfth";
var reReltexttext = "next|last|previous|this";
var reReltextunit = "(?:second|sec|minute|min|hour|day|fortnight|forthnight|month|year)s?|weeks|" + reDaytext;
var reYear = "([0-9]{1,4})";
var reYear2 = "([0-9]{2})";
var reYear4 = "([0-9]{4})";
var reYear4withSign = "([+-]?[0-9]{4})";
var reMonth = "(1[0-2]|0?[0-9])";
var reMonthlz = "(0[0-9]|1[0-2])";
var reDay = "(?:(3[01]|[0-2]?[0-9])(?:st|nd|rd|th)?)";
var reDaylz = "(0[0-9]|[1-2][0-9]|3[01])";
var reMonthFull = "january|february|march|april|may|june|july|august|september|october|november|december";
var reMonthAbbr = "jan|feb|mar|apr|may|jun|jul|aug|sept?|oct|nov|dec";
var reMonthroman = "i[vx]|vi{0,3}|xi{0,2}|i{1,3}";
var reMonthText = "(" + reMonthFull + "|" + reMonthAbbr + "|" + reMonthroman + ")";
var reTzCorrection = "((?:GMT)?([+-])" + reHour24 + ":?" + reMinute + "?)";
var reTzAbbr = "\\(?([a-zA-Z]{1,6})\\)?";
var reDayOfYear = "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])";
var reWeekOfYear = "(0[1-9]|[1-4][0-9]|5[0-3])";
var reDateNoYear = reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]*";
function processMeridian(hour, meridian) {
  meridian = meridian && meridian.toLowerCase();
  switch (meridian) {
    case "a":
      hour += hour === 12 ? -12 : 0;
      break;
    case "p":
      hour += hour !== 12 ? 12 : 0;
      break;
  }
  return hour;
}
function processYear(yearStr) {
  var year = +yearStr;
  if (yearStr.length < 4 && year < 100) {
    year += year < 70 ? 2e3 : 1900;
  }
  return year;
}
function lookupMonth(monthStr) {
  return {
    jan: 0,
    january: 0,
    i: 0,
    feb: 1,
    february: 1,
    ii: 1,
    mar: 2,
    march: 2,
    iii: 2,
    apr: 3,
    april: 3,
    iv: 3,
    may: 4,
    v: 4,
    jun: 5,
    june: 5,
    vi: 5,
    jul: 6,
    july: 6,
    vii: 6,
    aug: 7,
    august: 7,
    viii: 7,
    sep: 8,
    sept: 8,
    september: 8,
    ix: 8,
    oct: 9,
    october: 9,
    x: 9,
    nov: 10,
    november: 10,
    xi: 10,
    dec: 11,
    december: 11,
    xii: 11
  }[monthStr.toLowerCase()];
}
function lookupWeekday(dayStr) {
  var desiredSundayNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var dayNumbers = {
    mon: 1,
    monday: 1,
    tue: 2,
    tuesday: 2,
    wed: 3,
    wednesday: 3,
    thu: 4,
    thursday: 4,
    fri: 5,
    friday: 5,
    sat: 6,
    saturday: 6,
    sun: 0,
    sunday: 0
  };
  return dayNumbers[dayStr.toLowerCase()] || desiredSundayNumber;
}
function lookupRelative(relText) {
  var relativeNumbers = {
    last: -1,
    previous: -1,
    this: 0,
    first: 1,
    next: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eight: 8,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12
  };
  var relativeBehavior = {
    this: 1
  };
  var relTextLower = relText.toLowerCase();
  return {
    amount: relativeNumbers[relTextLower],
    behavior: relativeBehavior[relTextLower] || 0
  };
}
function processTzCorrection(tzOffset, oldValue) {
  var reTzCorrectionLoose = /(?:GMT)?([+-])(\d+)(:?)(\d{0,2})/i;
  tzOffset = tzOffset && tzOffset.match(reTzCorrectionLoose);
  if (!tzOffset) {
    return oldValue;
  }
  var sign = tzOffset[1] === "-" ? -1 : 1;
  var hours = +tzOffset[2];
  var minutes = +tzOffset[4];
  if (!tzOffset[4] && !tzOffset[3]) {
    minutes = Math.floor(hours % 100);
    hours = Math.floor(hours / 100);
  }
  return sign * (hours * 60 + minutes) * 60;
}
var tzAbbrOffsets = {
  acdt: 37800,
  acst: 34200,
  addt: -7200,
  adt: -10800,
  aedt: 39600,
  aest: 36e3,
  ahdt: -32400,
  ahst: -36e3,
  akdt: -28800,
  akst: -32400,
  amt: -13840,
  apt: -10800,
  ast: -14400,
  awdt: 32400,
  awst: 28800,
  awt: -10800,
  bdst: 7200,
  bdt: -36e3,
  bmt: -14309,
  bst: 3600,
  cast: 34200,
  cat: 7200,
  cddt: -14400,
  cdt: -18e3,
  cemt: 10800,
  cest: 7200,
  cet: 3600,
  cmt: -15408,
  cpt: -18e3,
  cst: -21600,
  cwt: -18e3,
  chst: 36e3,
  dmt: -1521,
  eat: 10800,
  eddt: -10800,
  edt: -14400,
  eest: 10800,
  eet: 7200,
  emt: -26248,
  ept: -14400,
  est: -18e3,
  ewt: -14400,
  ffmt: -14660,
  fmt: -4056,
  gdt: 39600,
  gmt: 0,
  gst: 36e3,
  hdt: -34200,
  hkst: 32400,
  hkt: 28800,
  hmt: -19776,
  hpt: -34200,
  hst: -36e3,
  hwt: -34200,
  iddt: 14400,
  idt: 10800,
  imt: 25025,
  ist: 7200,
  jdt: 36e3,
  jmt: 8440,
  jst: 32400,
  kdt: 36e3,
  kmt: 5736,
  kst: 30600,
  lst: 9394,
  mddt: -18e3,
  mdst: 16279,
  mdt: -21600,
  mest: 7200,
  met: 3600,
  mmt: 9017,
  mpt: -21600,
  msd: 14400,
  msk: 10800,
  mst: -25200,
  mwt: -21600,
  nddt: -5400,
  ndt: -9052,
  npt: -9e3,
  nst: -12600,
  nwt: -9e3,
  nzdt: 46800,
  nzmt: 41400,
  nzst: 43200,
  pddt: -21600,
  pdt: -25200,
  pkst: 21600,
  pkt: 18e3,
  plmt: 25590,
  pmt: -13236,
  ppmt: -17340,
  ppt: -25200,
  pst: -28800,
  pwt: -25200,
  qmt: -18840,
  rmt: 5794,
  sast: 7200,
  sdmt: -16800,
  sjmt: -20173,
  smt: -13884,
  sst: -39600,
  tbmt: 10751,
  tmt: 12344,
  uct: 0,
  utc: 0,
  wast: 7200,
  wat: 3600,
  wemt: 7200,
  west: 3600,
  wet: 0,
  wib: 25200,
  wita: 28800,
  wit: 32400,
  wmt: 5040,
  yddt: -25200,
  ydt: -28800,
  ypt: -28800,
  yst: -32400,
  ywt: -28800,
  a: 3600,
  b: 7200,
  c: 10800,
  d: 14400,
  e: 18e3,
  f: 21600,
  g: 25200,
  h: 28800,
  i: 32400,
  k: 36e3,
  l: 39600,
  m: 43200,
  n: -3600,
  o: -7200,
  p: -10800,
  q: -14400,
  r: -18e3,
  s: -21600,
  t: -25200,
  u: -28800,
  v: -32400,
  w: -36e3,
  x: -39600,
  y: -43200,
  z: 0
};
var formats$1 = {
  yesterday: {
    regex: /^yesterday/i,
    name: "yesterday",
    callback: function callback() {
      this.rd -= 1;
      return this.resetTime();
    }
  },
  now: {
    regex: /^now/i,
    name: "now"
    // do nothing
  },
  noon: {
    regex: /^noon/i,
    name: "noon",
    callback: function callback2() {
      return this.resetTime() && this.time(12, 0, 0, 0);
    }
  },
  midnightOrToday: {
    regex: /^(midnight|today)/i,
    name: "midnight | today",
    callback: function callback3() {
      return this.resetTime();
    }
  },
  tomorrow: {
    regex: /^tomorrow/i,
    name: "tomorrow",
    callback: function callback4() {
      this.rd += 1;
      return this.resetTime();
    }
  },
  timestamp: {
    regex: /^@(-?\d+)/i,
    name: "timestamp",
    callback: function callback5(match, timestamp) {
      this.rs += +timestamp;
      this.y = 1970;
      this.m = 0;
      this.d = 1;
      this.dates = 0;
      return this.resetTime() && this.zone(0);
    }
  },
  firstOrLastDay: {
    regex: /^(first|last) day of/i,
    name: "firstdayof | lastdayof",
    callback: function callback6(match, day) {
      if (day.toLowerCase() === "first") {
        this.firstOrLastDayOfMonth = 1;
      } else {
        this.firstOrLastDayOfMonth = -1;
      }
    }
  },
  backOrFrontOf: {
    regex: RegExp("^(back|front) of " + reHour24 + reSpaceOpt + reMeridian + "?", "i"),
    name: "backof | frontof",
    callback: function callback7(match, side, hours, meridian) {
      var back = side.toLowerCase() === "back";
      var hour = +hours;
      var minute = 15;
      if (!back) {
        hour -= 1;
        minute = 45;
      }
      hour = processMeridian(hour, meridian);
      return this.resetTime() && this.time(hour, minute, 0, 0);
    }
  },
  weekdayOf: {
    regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reDayfull + "|" + reDayabbr + ")" + reSpace + "of", "i"),
    name: "weekdayof"
    // todo
  },
  mssqltime: {
    regex: RegExp("^" + reHour12 + ":" + reMinutelz + ":" + reSecondlz + "[:.]([0-9]+)" + reMeridian, "i"),
    name: "mssqltime",
    callback: function callback8(match, hour, minute, second, frac, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, +frac.substr(0, 3));
    }
  },
  oracledate: {
    regex: /^(\d{2})-([A-Z]{3})-(\d{2})$/i,
    name: "d-M-y",
    callback: function callback9(match, day, monthText, year) {
      var month = {
        JAN: 0,
        FEB: 1,
        MAR: 2,
        APR: 3,
        MAY: 4,
        JUN: 5,
        JUL: 6,
        AUG: 7,
        SEP: 8,
        OCT: 9,
        NOV: 10,
        DEC: 11
      }[monthText.toUpperCase()];
      return this.ymd(2e3 + parseInt(year, 10), month, parseInt(day, 10));
    }
  },
  timeLong12: {
    regex: RegExp("^" + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
    name: "timelong12",
    callback: function callback10(match, hour, minute, second, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, 0);
    }
  },
  timeShort12: {
    regex: RegExp("^" + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
    name: "timeshort12",
    callback: function callback11(match, hour, minute, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, 0, 0);
    }
  },
  timeTiny12: {
    regex: RegExp("^" + reHour12 + reSpaceOpt + reMeridian, "i"),
    name: "timetiny12",
    callback: function callback12(match, hour, meridian) {
      return this.time(processMeridian(+hour, meridian), 0, 0, 0);
    }
  },
  soap: {
    regex: RegExp("^" + reYear4 + "-" + reMonthlz + "-" + reDaylz + "T" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reFrac + reTzCorrection + "?", "i"),
    name: "soap",
    callback: function callback13(match, year, month, day, hour, minute, second, frac, tzCorrection) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, +frac.substr(0, 3)) && this.zone(processTzCorrection(tzCorrection));
    }
  },
  wddx: {
    regex: RegExp("^" + reYear4 + "-" + reMonth + "-" + reDay + "T" + reHour24 + ":" + reMinute + ":" + reSecond),
    name: "wddx",
    callback: function callback14(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  exif: {
    regex: RegExp("^" + reYear4 + ":" + reMonthlz + ":" + reDaylz + " " + reHour24lz + ":" + reMinutelz + ":" + reSecondlz, "i"),
    name: "exif",
    callback: function callback15(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  xmlRpc: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "T" + reHour24 + ":" + reMinutelz + ":" + reSecondlz),
    name: "xmlrpc",
    callback: function callback16(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  xmlRpcNoColon: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "[Tt]" + reHour24 + reMinutelz + reSecondlz),
    name: "xmlrpcnocolon",
    callback: function callback17(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  clf: {
    regex: RegExp("^" + reDay + "/(" + reMonthAbbr + ")/" + reYear4 + ":" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reSpace + reTzCorrection, "i"),
    name: "clf",
    callback: function callback18(match, day, month, year, hour, minute, second, tzCorrection) {
      return this.ymd(+year, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0) && this.zone(processTzCorrection(tzCorrection));
    }
  },
  iso8601long: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond + reFrac, "i"),
    name: "iso8601long",
    callback: function callback19(match, hour, minute, second, frac) {
      return this.time(+hour, +minute, +second, +frac.substr(0, 3));
    }
  },
  dateTextual: {
    regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]+" + reYear, "i"),
    name: "datetextual",
    callback: function callback20(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  pointedDate4: {
    regex: RegExp("^" + reDay + "[.\\t-]" + reMonth + "[.-]" + reYear4),
    name: "pointeddate4",
    callback: function callback21(match, day, month, year) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  pointedDate2: {
    regex: RegExp("^" + reDay + "[.\\t]" + reMonth + "\\." + reYear2),
    name: "pointeddate2",
    callback: function callback22(match, day, month, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  timeLong24: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond),
    name: "timelong24",
    callback: function callback23(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },
  dateNoColon: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz),
    name: "datenocolon",
    callback: function callback24(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  pgydotd: {
    regex: RegExp("^" + reYear4 + "\\.?" + reDayOfYear),
    name: "pgydotd",
    callback: function callback25(match, year, day) {
      return this.ymd(+year, 0, +day);
    }
  },
  timeShort24: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute, "i"),
    name: "timeshort24",
    callback: function callback26(match, hour, minute) {
      return this.time(+hour, +minute, 0, 0);
    }
  },
  iso8601noColon: {
    regex: RegExp("^t?" + reHour24lz + reMinutelz + reSecondlz, "i"),
    name: "iso8601nocolon",
    callback: function callback27(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },
  iso8601dateSlash: {
    // eventhough the trailing slash is optional in PHP
    // here it's mandatory and inputs without the slash
    // are handled by dateslash
    regex: RegExp("^" + reYear4 + "/" + reMonthlz + "/" + reDaylz + "/"),
    name: "iso8601dateslash",
    callback: function callback28(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  dateSlash: {
    regex: RegExp("^" + reYear4 + "/" + reMonth + "/" + reDay),
    name: "dateslash",
    callback: function callback29(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  american: {
    regex: RegExp("^" + reMonth + "/" + reDay + "/" + reYear),
    name: "american",
    callback: function callback30(match, month, day, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  americanShort: {
    regex: RegExp("^" + reMonth + "/" + reDay),
    name: "americanshort",
    callback: function callback31(match, month, day) {
      return this.ymd(this.y, month - 1, +day);
    }
  },
  gnuDateShortOrIso8601date2: {
    // iso8601date2 is complete subset of gnudateshort
    regex: RegExp("^" + reYear + "-" + reMonth + "-" + reDay),
    name: "gnudateshort | iso8601date2",
    callback: function callback32(match, year, month, day) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  iso8601date4: {
    regex: RegExp("^" + reYear4withSign + "-" + reMonthlz + "-" + reDaylz),
    name: "iso8601date4",
    callback: function callback33(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  gnuNoColon: {
    regex: RegExp("^t?" + reHour24lz + reMinutelz, "i"),
    name: "gnunocolon",
    callback: function callback34(match, hour, minute) {
      switch (this.times) {
        case 0:
          return this.time(+hour, +minute, 0, this.f);
        case 1:
          this.y = hour * 100 + +minute;
          this.times++;
          return true;
        default:
          return false;
      }
    }
  },
  gnuDateShorter: {
    regex: RegExp("^" + reYear4 + "-" + reMonth),
    name: "gnudateshorter",
    callback: function callback35(match, year, month) {
      return this.ymd(+year, month - 1, 1);
    }
  },
  pgTextReverse: {
    // note: allowed years are from 32-9999
    // years below 32 should be treated as days in datefull
    regex: RegExp("^(\\d{3,4}|[4-9]\\d|3[2-9])-(" + reMonthAbbr + ")-" + reDaylz, "i"),
    name: "pgtextreverse",
    callback: function callback36(match, year, month, day) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateFull: {
    regex: RegExp("^" + reDay + "[ \\t.-]*" + reMonthText + "[ \\t.-]*" + reYear, "i"),
    name: "datefull",
    callback: function callback37(match, day, month, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateNoDay: {
    regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reYear4, "i"),
    name: "datenoday",
    callback: function callback38(match, month, year) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },
  dateNoDayRev: {
    regex: RegExp("^" + reYear4 + "[ .\\t-]*" + reMonthText, "i"),
    name: "datenodayrev",
    callback: function callback39(match, year, month) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },
  pgTextShort: {
    regex: RegExp("^(" + reMonthAbbr + ")-" + reDaylz + "-" + reYear, "i"),
    name: "pgtextshort",
    callback: function callback40(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateNoYear: {
    regex: RegExp("^" + reDateNoYear, "i"),
    name: "datenoyear",
    callback: function callback41(match, month, day) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },
  dateNoYearRev: {
    regex: RegExp("^" + reDay + "[ .\\t-]*" + reMonthText, "i"),
    name: "datenoyearrev",
    callback: function callback42(match, day, month) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },
  isoWeekDay: {
    regex: RegExp("^" + reYear4 + "-?W" + reWeekOfYear + "(?:-?([0-7]))?"),
    name: "isoweekday | isoweek",
    callback: function callback43(match, year, week, day) {
      day = day ? +day : 1;
      if (!this.ymd(+year, 0, 1)) {
        return false;
      }
      var dayOfWeek = new Date(this.y, this.m, this.d).getDay();
      dayOfWeek = 0 - (dayOfWeek > 4 ? dayOfWeek - 7 : dayOfWeek);
      this.rd += dayOfWeek + (week - 1) * 7 + day;
    }
  },
  relativeText: {
    regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reReltextunit + ")", "i"),
    name: "relativetext",
    callback: function callback44(match, relValue, relUnit) {
      var _lookupRelative = lookupRelative(relValue), amount = _lookupRelative.amount;
      switch (relUnit.toLowerCase()) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
          this.rs += amount;
          break;
        case "min":
        case "mins":
        case "minute":
        case "minutes":
          this.ri += amount;
          break;
        case "hour":
        case "hours":
          this.rh += amount;
          break;
        case "day":
        case "days":
          this.rd += amount;
          break;
        case "fortnight":
        case "fortnights":
        case "forthnight":
        case "forthnights":
          this.rd += amount * 14;
          break;
        case "week":
        case "weeks":
          this.rd += amount * 7;
          break;
        case "month":
        case "months":
          this.rm += amount;
          break;
        case "year":
        case "years":
          this.ry += amount;
          break;
        case "mon":
        case "monday":
        case "tue":
        case "tuesday":
        case "wed":
        case "wednesday":
        case "thu":
        case "thursday":
        case "fri":
        case "friday":
        case "sat":
        case "saturday":
        case "sun":
        case "sunday":
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
      }
    }
  },
  relative: {
    regex: RegExp("^([+-]*)[ \\t]*(\\d+)" + reSpaceOpt + "(" + reReltextunit + "|week)", "i"),
    name: "relative",
    callback: function callback45(match, signs, relValue, relUnit) {
      var minuses = signs.replace(/[^-]/g, "").length;
      var amount = +relValue * Math.pow(-1, minuses);
      switch (relUnit.toLowerCase()) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
          this.rs += amount;
          break;
        case "min":
        case "mins":
        case "minute":
        case "minutes":
          this.ri += amount;
          break;
        case "hour":
        case "hours":
          this.rh += amount;
          break;
        case "day":
        case "days":
          this.rd += amount;
          break;
        case "fortnight":
        case "fortnights":
        case "forthnight":
        case "forthnights":
          this.rd += amount * 14;
          break;
        case "week":
        case "weeks":
          this.rd += amount * 7;
          break;
        case "month":
        case "months":
          this.rm += amount;
          break;
        case "year":
        case "years":
          this.ry += amount;
          break;
        case "mon":
        case "monday":
        case "tue":
        case "tuesday":
        case "wed":
        case "wednesday":
        case "thu":
        case "thursday":
        case "fri":
        case "friday":
        case "sat":
        case "saturday":
        case "sun":
        case "sunday":
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
      }
    }
  },
  dayText: {
    regex: RegExp("^(" + reDaytext + ")", "i"),
    name: "daytext",
    callback: function callback46(match, dayText) {
      this.resetTime();
      this.weekday = lookupWeekday(dayText, 0);
      if (this.weekdayBehavior !== 2) {
        this.weekdayBehavior = 1;
      }
    }
  },
  relativeTextWeek: {
    regex: RegExp("^(" + reReltexttext + ")" + reSpace + "week", "i"),
    name: "relativetextweek",
    callback: function callback47(match, relText) {
      this.weekdayBehavior = 2;
      switch (relText.toLowerCase()) {
        case "this":
          this.rd += 0;
          break;
        case "next":
          this.rd += 7;
          break;
        case "last":
        case "previous":
          this.rd -= 7;
          break;
      }
      if (isNaN(this.weekday)) {
        this.weekday = 1;
      }
    }
  },
  monthFullOrMonthAbbr: {
    regex: RegExp("^(" + reMonthFull + "|" + reMonthAbbr + ")", "i"),
    name: "monthfull | monthabbr",
    callback: function callback48(match, month) {
      return this.ymd(this.y, lookupMonth(month), this.d);
    }
  },
  tzCorrection: {
    regex: RegExp("^" + reTzCorrection, "i"),
    name: "tzcorrection",
    callback: function callback49(tzCorrection) {
      return this.zone(processTzCorrection(tzCorrection));
    }
  },
  tzAbbr: {
    regex: RegExp("^" + reTzAbbr),
    name: "tzabbr",
    callback: function callback50(match, abbr) {
      var offset = tzAbbrOffsets[abbr.toLowerCase()];
      if (isNaN(offset)) {
        return false;
      }
      return this.zone(offset);
    }
  },
  ago: {
    regex: /^ago/i,
    name: "ago",
    callback: function callback51() {
      this.ry = -this.ry;
      this.rm = -this.rm;
      this.rd = -this.rd;
      this.rh = -this.rh;
      this.ri = -this.ri;
      this.rs = -this.rs;
      this.rf = -this.rf;
    }
  },
  year4: {
    regex: RegExp("^" + reYear4),
    name: "year4",
    callback: function callback52(match, year) {
      this.y = +year;
      return true;
    }
  },
  whitespace: {
    regex: /^[ .,\t]+/,
    name: "whitespace"
    // do nothing
  },
  dateShortWithTimeLong: {
    regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond, "i"),
    name: "dateshortwithtimelong",
    callback: function callback53(match, month, day, hour, minute, second) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  dateShortWithTimeLong12: {
    regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
    name: "dateshortwithtimelong12",
    callback: function callback54(match, month, day, hour, minute, second, meridian) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, +second, 0);
    }
  },
  dateShortWithTimeShort: {
    regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute, "i"),
    name: "dateshortwithtimeshort",
    callback: function callback55(match, month, day, hour, minute) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, 0, 0);
    }
  },
  dateShortWithTimeShort12: {
    regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
    name: "dateshortwithtimeshort12",
    callback: function callback56(match, month, day, hour, minute, meridian) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, 0, 0);
    }
  }
};
var resultProto = {
  // date
  y: NaN,
  m: NaN,
  d: NaN,
  // time
  h: NaN,
  i: NaN,
  s: NaN,
  f: NaN,
  // relative shifts
  ry: 0,
  rm: 0,
  rd: 0,
  rh: 0,
  ri: 0,
  rs: 0,
  rf: 0,
  // weekday related shifts
  weekday: NaN,
  weekdayBehavior: 0,
  // first or last day of month
  // 0 none, 1 first, -1 last
  firstOrLastDayOfMonth: 0,
  // timezone correction in minutes
  z: NaN,
  // counters
  dates: 0,
  times: 0,
  zones: 0,
  // helper functions
  ymd: function ymd(y, m, d) {
    if (this.dates > 0) {
      return false;
    }
    this.dates++;
    this.y = y;
    this.m = m;
    this.d = d;
    return true;
  },
  time: function time(h2, i, s, f) {
    if (this.times > 0) {
      return false;
    }
    this.times++;
    this.h = h2;
    this.i = i;
    this.s = s;
    this.f = f;
    return true;
  },
  resetTime: function resetTime() {
    this.h = 0;
    this.i = 0;
    this.s = 0;
    this.f = 0;
    this.times = 0;
    return true;
  },
  zone: function zone(minutes) {
    if (this.zones <= 1) {
      this.zones++;
      this.z = minutes;
      return true;
    }
    return false;
  },
  toDate: function toDate(relativeTo) {
    if (this.dates && !this.times) {
      this.h = this.i = this.s = this.f = 0;
    }
    if (isNaN(this.y)) {
      this.y = relativeTo.getFullYear();
    }
    if (isNaN(this.m)) {
      this.m = relativeTo.getMonth();
    }
    if (isNaN(this.d)) {
      this.d = relativeTo.getDate();
    }
    if (isNaN(this.h)) {
      this.h = relativeTo.getHours();
    }
    if (isNaN(this.i)) {
      this.i = relativeTo.getMinutes();
    }
    if (isNaN(this.s)) {
      this.s = relativeTo.getSeconds();
    }
    if (isNaN(this.f)) {
      this.f = relativeTo.getMilliseconds();
    }
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        this.d = 1;
        break;
      case -1:
        this.d = 0;
        this.m += 1;
        break;
    }
    if (!isNaN(this.weekday)) {
      var date6 = new Date(relativeTo.getTime());
      date6.setFullYear(this.y, this.m, this.d);
      date6.setHours(this.h, this.i, this.s, this.f);
      var dow = date6.getDay();
      if (this.weekdayBehavior === 2) {
        if (dow === 0 && this.weekday !== 0) {
          this.weekday = -6;
        }
        if (this.weekday === 0 && dow !== 0) {
          this.weekday = 7;
        }
        this.d -= dow;
        this.d += this.weekday;
      } else {
        var diff = this.weekday - dow;
        if (this.rd < 0 && diff < 0 || this.rd >= 0 && diff <= -this.weekdayBehavior) {
          diff += 7;
        }
        if (this.weekday >= 0) {
          this.d += diff;
        } else {
          this.d -= 7 - (Math.abs(this.weekday) - dow);
        }
        this.weekday = NaN;
      }
    }
    this.y += this.ry;
    this.m += this.rm;
    this.d += this.rd;
    this.h += this.rh;
    this.i += this.ri;
    this.s += this.rs;
    this.f += this.rf;
    this.ry = this.rm = this.rd = 0;
    this.rh = this.ri = this.rs = this.rf = 0;
    var result = new Date(relativeTo.getTime());
    result.setFullYear(this.y, this.m, this.d);
    result.setHours(this.h, this.i, this.s, this.f);
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        result.setDate(1);
        break;
      case -1:
        result.setMonth(result.getMonth() + 1, 0);
        break;
    }
    if (!isNaN(this.z) && result.getTimezoneOffset() !== this.z) {
      result.setUTCFullYear(result.getFullYear(), result.getMonth(), result.getDate());
      result.setUTCHours(result.getHours(), result.getMinutes(), result.getSeconds() - this.z, result.getMilliseconds());
    }
    return result;
  }
};
var strtotime = function strtotime2(str, now) {
  if (now == null) {
    now = Math.floor(Date.now() / 1e3);
  }
  var rules2 = [
    formats$1.yesterday,
    formats$1.now,
    formats$1.noon,
    formats$1.midnightOrToday,
    formats$1.tomorrow,
    formats$1.timestamp,
    formats$1.firstOrLastDay,
    formats$1.backOrFrontOf,
    // formats.weekdayOf, // not yet implemented
    formats$1.timeTiny12,
    formats$1.timeShort12,
    formats$1.timeLong12,
    formats$1.mssqltime,
    formats$1.oracledate,
    formats$1.timeShort24,
    formats$1.timeLong24,
    formats$1.iso8601long,
    formats$1.gnuNoColon,
    formats$1.iso8601noColon,
    formats$1.americanShort,
    formats$1.american,
    formats$1.iso8601date4,
    formats$1.iso8601dateSlash,
    formats$1.dateSlash,
    formats$1.gnuDateShortOrIso8601date2,
    formats$1.gnuDateShorter,
    formats$1.dateFull,
    formats$1.pointedDate4,
    formats$1.pointedDate2,
    formats$1.dateNoDay,
    formats$1.dateNoDayRev,
    formats$1.dateTextual,
    formats$1.dateNoYear,
    formats$1.dateNoYearRev,
    formats$1.dateNoColon,
    formats$1.xmlRpc,
    formats$1.xmlRpcNoColon,
    formats$1.soap,
    formats$1.wddx,
    formats$1.exif,
    formats$1.pgydotd,
    formats$1.isoWeekDay,
    formats$1.pgTextShort,
    formats$1.pgTextReverse,
    formats$1.clf,
    formats$1.year4,
    formats$1.ago,
    formats$1.dayText,
    formats$1.relativeTextWeek,
    formats$1.relativeText,
    formats$1.monthFullOrMonthAbbr,
    formats$1.tzCorrection,
    formats$1.tzAbbr,
    formats$1.dateShortWithTimeShort12,
    formats$1.dateShortWithTimeLong12,
    formats$1.dateShortWithTimeShort,
    formats$1.dateShortWithTimeLong,
    formats$1.relative,
    formats$1.whitespace
  ];
  var result = Object.create(resultProto);
  while (str.length) {
    var longestMatch = null;
    var finalRule = null;
    for (var i = 0, l = rules2.length; i < l; i++) {
      var format = rules2[i];
      var match = str.match(format.regex);
      if (match) {
        if (!longestMatch || match[0].length > longestMatch[0].length) {
          longestMatch = match;
          finalRule = format;
        }
      }
    }
    if (!finalRule || finalRule.callback && finalRule.callback.apply(result, longestMatch) === false) {
      return false;
    }
    str = str.substr(longestMatch[0].length);
    finalRule = null;
    longestMatch = null;
  }
  return Math.floor(result.toDate(new Date(now * 1e3)) / 1e3);
};
var date$4 = class extends Validator {
  check(value) {
    return !!strtotime(value);
  }
};
var date_equals = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      date: this.date
    };
  }
  get date() {
    return this.attributes[0];
  }
  check(value) {
    return value === this.date;
  }
};
var date_format = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      format: this.format
    };
  }
  get format() {
    return this.attributes[0];
  }
  check(value) {
    return value && this.moment(value, this.format).format(this.format) === value;
  }
};
var different = class extends Validator {
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(value) && !this.filled(this.other$.value)) {
      return true;
    }
    return value != this.other$.value;
  }
};
var digits = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      digits: this.digits
    };
  }
  get digits() {
    return this.attributes[0];
  }
  check(value) {
    return /^\d+$/.test(value) && value.toString().length == this.digits;
  }
};
var digits_between = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min,
      max: this.max
    };
  }
  get min() {
    return this.attributes[0];
  }
  get max() {
    return this.attributes[1];
  }
  check(value) {
    var length = value.toString().length;
    return /^\d+$/.test(value) && length >= this.min && length <= this.max;
  }
};
var dimensions = class extends Validator {
  get isAsync() {
    return true;
  }
  readImage(inputFile) {
    return _asyncToGenerator(function* () {
      var reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onerror = () => {
          temporaryFileReader.abort();
          reject(new DOMException("File cannot be parsed."));
        };
        reader.onloadend = (event) => {
          resolve(event.target.result);
        };
        reader.readAsDataURL(inputFile);
      });
    })();
  }
  loadImage(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var source = yield _this.readImage(value);
      var image2 = new Image();
      return new Promise((resolve, reject) => {
        image2.onerror = () => {
          reject(new DOMException("Image could not be loaded."));
        };
        image2.onload = (event) => {
          resolve(event.target);
        };
        image2.src = source;
      });
    })();
  }
  hasAttribute(attribute) {
    return Object.keys(this.attributes).map((a) => a.toLowerCase()).indexOf(attribute) !== -1;
  }
  check(value) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.isFile && !value) {
        return true;
      }
      if (!_this2.isFile || !(value instanceof File)) {
        return false;
      }
      var image2 = yield _this2.loadImage(value);
      if (_this2.hasAttribute("min_width")) {
        if (image2.width < _this2.attributes["min_width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("max_width")) {
        if (image2.width > _this2.attributes["max_width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("min_height")) {
        if (image2.height < _this2.attributes["min_height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("max_height")) {
        if (image2.height > _this2.attributes["max_height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("width")) {
        if (image2.width != _this2.attributes["width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("height")) {
        if (image2.height != _this2.attributes["height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("ratio")) {
        var ratio = _this2.attributes["ratio"];
        var precision = 1 / (Math.min(image2.width, image2.height) + 1);
        var numerator = /\//.test(ratio) ? ratio.split("/")[0] : ratio;
        var denominator = /\//.test(ratio) ? ratio.split("/")[1] : 1;
        if (Math.abs(numerator / denominator - image2.width / image2.height) > precision) {
          return false;
        }
      }
      return true;
    })();
  }
};
function pregQuote(str, delimiter) {
  return (str + "").replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\" + (delimiter || "") + "-]", "g"), "\\$&");
}
function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
var _baseReduce = baseReduce$1;
var arrayReduce = _arrayReduce;
var baseEach = _baseEach;
var baseIteratee$4 = _baseIteratee;
var baseReduce = _baseReduce;
var isArray$2 = isArray_1;
function reduce(collection, iteratee, accumulator) {
  var func = isArray$2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection, baseIteratee$4(iteratee), accumulator, initAccum, baseEach);
}
var reduce_1 = reduce;
var _flattenKeys = function flattenKeys(obj) {
  var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return !isObject_1(obj) ? {
    [path.join(".")]: obj
  } : reduce_1(obj, (cum, next, key) => merge_1(cum, _flattenKeys(next, [...path, key])), {});
};
var distinct = class extends Validator {
  check(value) {
    var attribute = this.element$.path;
    var attributeName = attribute.replace(/\d+(?!\d+)/, "*");
    var rootVariable = attribute.match(/^[\w-]+/)[0];
    var attributeData = {
      [rootVariable]: this.form$.data[rootVariable]
    };
    var pattern = pregQuote(attributeName, "#").replace("\\*", "[^.]+");
    var data = {};
    each(_flattenKeys(attributeData), (v, k) => {
      if (k != attribute && k.match("^" + pattern + "$") !== null) {
        data[k] = v;
      }
    });
    return !(values_1(data).indexOf(value) !== -1);
  }
};
var email = class extends Validator {
  check(value) {
    var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(value).toLowerCase());
  }
};
var exists = class extends Validator {
  get isAsync() {
    return true;
  }
  get requestParams() {
    var params = {};
    each(this.attributes, (param, key) => {
      var requestParam = key;
      if (!isNaN(key)) {
        requestParam = param;
      }
      if (requestParam == "debounce") {
        return;
      }
      var el = this.form$.el$(requestParam);
      params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
    });
    return params;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var name2 = _this.element$.name;
      var endpoint = _this.form$.$vueform.config.endpoints.exists;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            params: _this.requestParams,
            [name2]: value,
            vueformFieldName: name2,
            value,
            name: name2
          }
        });
        res = res.data;
      }
      return res;
    })();
  }
};
var file$5 = class extends Validator {
  check(value) {
    return (!value || value instanceof File) && this.isFile;
  }
};
var filled = class extends Validator {
  check(value) {
    return this.filled(value);
  }
};
var gt = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      value: this.other$.value != null ? this.size(this.other$.value) : 0
    };
  }
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    var otherValue = this.other$.value;
    return this.compare(value, otherValue);
  }
  compare(value, otherValue) {
    var otherSize = this.size(otherValue);
    return otherSize == 0 || this.size(value) > otherSize;
  }
};
var gte = class extends gt {
  compare(value, otherValue) {
    var otherSize = this.size(otherValue);
    return otherSize == 0 || this.size(value) >= otherSize;
  }
};
var image = class extends Validator {
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.name) {
      return false;
    }
    var extension = value.name.split(".").pop();
    return ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].indexOf(extension) !== -1;
  }
};
var in_ = class extends Validator {
  check(value) {
    return values_1(this.attributes).indexOf(normalize(String(value).trim())) !== -1;
  }
};
var in_array = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  get otherPath() {
    var matches2 = this.attributes[0].match(/.*(?=\.\*)/);
    if (matches2 === null) {
      throw new Error("in_array rule's other attribute should end with .*");
    }
    return matches2[0];
  }
  init() {
    this.watchOther();
  }
  check(value) {
    var data = this.other$.value;
    if (!data) {
      return false;
    }
    return data.indexOf(value) !== -1;
  }
};
var integer = class extends Validator {
  check(value) {
    var normalized = normalize(String(value).trim());
    return normalized === parseInt(normalized, 10);
  }
};
var checker$1 = function checker(value) {
  var re = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\/([0-9]|[1-2][0-9]|3[0-2]))?$/;
  return re.test(value);
};
var ipv4 = class extends Validator {
  check(value) {
    return checker$1(value);
  }
};
var checker2 = function checker3(value) {
  var re = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*(\/(\d|\d\d|1[0-1]\d|12[0-8]))?$/;
  return re.test(value);
};
var ipv6 = class extends Validator {
  check(value) {
    return checker2(value);
  }
};
var ip = class extends Validator {
  check(value) {
    return checker$1(value) || checker2(value);
  }
};
function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e2) {
    return false;
  }
  return true;
}
var json = class extends Validator {
  check(value) {
    return isJson(value);
  }
};
var lt = class extends gt {
  compare(value, otherValue) {
    var size2 = this.size(value);
    var otherSize = this.size(otherValue);
    return otherSize == 0 && size2 == 0 || this.size(value) < otherSize;
  }
};
var lte = class extends gt {
  compare(value, otherValue) {
    var size2 = this.size(value);
    var otherSize = this.size(otherValue);
    return otherSize == 0 && size2 == 0 || this.size(value) <= otherSize;
  }
};
var max = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      max: this.max
    };
  }
  get max() {
    return this.attributes[0];
  }
  check(value) {
    if (typeof value !== "number" && !value) {
      return true;
    }
    return this.size(value) <= this.max;
  }
};
var mimes = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      values: this.accepted.join(", ")
    };
  }
  get accepted() {
    return Object.values(this.attributes).map((a) => a.toLowerCase());
  }
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.name) {
      return false;
    }
    var extension = value.name.split(".").pop();
    return this.accepted.indexOf(extension.toLowerCase()) !== -1;
  }
};
var mimetypes = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      values: this.accepted.join(", ")
    };
  }
  get accepted() {
    return Object.values(this.attributes).map((a) => a.toLowerCase());
  }
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.type) {
      return false;
    }
    return this.accepted.indexOf(value.type.toLowerCase()) !== -1;
  }
};
var min$1 = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min
    };
  }
  get min() {
    return this.attributes[0];
  }
  check(value) {
    if (typeof value !== "number" && !value) {
      return true;
    }
    return this.size(value) >= this.min;
  }
};
var not_in = class extends Validator {
  check(value) {
    return values_1(this.attributes).indexOf(value) === -1;
  }
};
var not_regex = class extends Validator {
  check(value) {
    var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
    return !regex2.test(value);
  }
};
var nullable = class extends Validator {
  check(value) {
    return true;
  }
};
var numeric = class extends Validator {
  check(value) {
    return !isNaN(parseFloat(value)) && isFinite(value) && !/\s/.test(String(value)) && !Boolean(String(value).match(/^0x[0-9a-f]+$/i));
  }
};
var regex = class extends Validator {
  check(value) {
    var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
    return regex2.test(value);
  }
};
var required = class extends Validator {
  check(value) {
    return this.filled(value);
  }
};
var same = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(value) && !this.filled(this.other$.value)) {
      return true;
    }
    return value == this.other$.value;
  }
};
var size = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      size: this.size_
    };
  }
  get size_() {
    return this.attributes[0];
  }
  check(value) {
    if (typeof value !== "number" && !value) {
      return true;
    }
    return this.size(value) == this.size_;
  }
};
var string = class extends Validator {
  check(value) {
    return isString_1(value);
  }
};
var timezone = class extends Validator {
  check(value) {
    try {
      Intl.DateTimeFormat(void 0, {
        timeZone: value
      });
      return true;
    } catch (ex) {
      return false;
    }
  }
};
var unique = class extends Validator {
  get isAsync() {
    return true;
  }
  get requestParams() {
    var params = {};
    each(this.attributes, (param, key) => {
      var requestParam = key;
      if (!isNaN(key)) {
        requestParam = param;
      }
      if (requestParam == "debounce") {
        return;
      }
      var el = this.form$.el$(requestParam);
      params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
    });
    return params;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var name2 = _this.element$.name;
      var endpoint = _this.form$.$vueform.config.endpoints.unique;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            params: _this.requestParams,
            name: name2,
            value
          }
        });
        res = res.data;
      }
      return res;
    })();
  }
};
var url = class extends Validator {
  check(value) {
    var regex2 = new RegExp("^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$", "i");
    return regex2.test(value);
  }
};
var uuid = class extends Validator {
  check(value) {
    var regex2 = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/i;
    return regex2.test(value);
  }
};
var index$2 = {
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array: array$2,
  before,
  before_or_equal,
  between,
  boolean: boolean$1,
  confirmed,
  date: date$4,
  date_equals,
  date_format,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  email,
  exists,
  file: file$5,
  filled,
  gt,
  gte,
  image,
  in: in_,
  in_array,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max,
  mimes,
  mimetypes,
  min: min$1,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  uuid
};
var rules = Object.freeze({
  __proto__: null,
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array: array$2,
  before,
  before_or_equal,
  between,
  boolean: boolean$1,
  captcha: captcha$2,
  completed,
  confirmed,
  date: date$4,
  date_equals,
  date_format,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  email,
  exists,
  file: file$5,
  filled,
  gt,
  gte,
  image,
  in_,
  in_array,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max,
  mimes,
  mimetypes,
  min: min$1,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  uuid,
  "default": index$2
});
var validation = {
  factory: Factory,
  rules: {}
};
var arrayPush = _arrayPush;
var baseFlatten$1 = _baseFlatten;
var copyArray = _copyArray;
var isArray$1 = isArray_1;
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array4 = arguments[0], index2 = length;
  while (index2--) {
    args[index2 - 1] = arguments[index2];
  }
  return arrayPush(isArray$1(array4) ? copyArray(array4) : [array4], baseFlatten$1(args, 1));
}
var concat_1 = concat;
function head(array4) {
  return array4 && array4.length ? array4[0] : void 0;
}
var head_1 = head;
var messageBag = class {
  constructor(baseErrors) {
    this.baseErrors = baseErrors;
    this.prepends = {
      errors: [],
      messages: []
    };
    this.appends = {
      errors: [],
      messages: []
    };
  }
  get errors() {
    return concat_1(this.prepends.errors, this.baseErrors, this.appends.errors);
  }
  get messages() {
    return concat_1(this.prepends.messages, this.appends.messages);
  }
  /**
   * The first error
   * 
   * @type {string}
   */
  get error() {
    return head_1(this.errors);
  }
  /**
   * The first message
   * 
   * @type {string}
   */
  get message() {
    return head_1(this.messages);
  }
  prepend(msg, type) {
    if (type === void 0) {
      type = "error";
    }
    this.prepends[type == "error" ? "errors" : "messages"].unshift(msg);
  }
  append(msg, type) {
    if (type === void 0) {
      type = "error";
    }
    this.appends[type == "error" ? "errors" : "messages"].push(msg);
  }
  remove(msg, type) {
    if (type === void 0) {
      type = "any";
    }
    if (["any", "error"].indexOf(type) !== -1) {
      each(this.prepends.errors, (error, index2) => {
        if (error == msg) {
          this.rm("prepends", "errors", index2);
        }
      });
      each(this.appends.errors, (error, index2) => {
        if (error == msg) {
          this.rm("appends", "errors", index2);
        }
      });
    }
    if (["any", "message"].indexOf(type) !== -1) {
      each(this.prepends.messages, (error, index2) => {
        if (error == msg) {
          this.rm("prepends", "messages", index2);
        }
      });
      each(this.appends.messages, (error, index2) => {
        if (error == msg) {
          this.rm("appends", "messages", index2);
        }
      });
    }
  }
  rm(group7, type, index2) {
    this[group7][type].splice(index2, 1);
  }
  clear(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.prepends = {
        errors: [],
        messages: []
      };
      this.appends = {
        errors: [],
        messages: []
      };
    } else {
      this.prepends[type] = [];
      this.appends[type] = [];
    }
  }
  clearPrepended(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.prepends = {
        errors: [],
        messages: []
      };
    } else {
      this.prepends[type] = [];
    }
  }
  clearAppended(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.appends = {
        errors: [],
        messages: []
      };
    } else {
      this.appends[type] = [];
    }
  }
};
var e = /* @__PURE__ */ new Map();
function t(t2) {
  var o2 = e.get(t2);
  o2 && o2.destroy();
}
function o(t2) {
  var o2 = e.get(t2);
  o2 && o2.update();
}
var r = null;
"undefined" == typeof window ? ((r = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, r.update = function(e2) {
  return e2;
}) : ((r = function(t2, o2) {
  return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
    return function(t4) {
      if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e.has(t4)) {
        var o3, r2 = null, n2 = window.getComputedStyle(t4), i = (o3 = t4.value, function() {
          a({ testForHeightReduction: "" === o3 || !t4.value.startsWith(o3), restoreTextAlign: null }), o3 = t4.value;
        }), l = (function(o4) {
          t4.removeEventListener("autosize:destroy", l), t4.removeEventListener("autosize:update", s), t4.removeEventListener("input", i), window.removeEventListener("resize", s), Object.keys(o4).forEach(function(e2) {
            return t4.style[e2] = o4[e2];
          }), e.delete(t4);
        }).bind(t4, { height: t4.style.height, resize: t4.style.resize, textAlign: t4.style.textAlign, overflowY: t4.style.overflowY, overflowX: t4.style.overflowX, wordWrap: t4.style.wordWrap });
        t4.addEventListener("autosize:destroy", l), t4.addEventListener("autosize:update", s), t4.addEventListener("input", i), window.addEventListener("resize", s), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e.set(t4, { destroy: l, update: s }), s();
      }
      function a(e2) {
        var o4, i2, l2 = e2.restoreTextAlign, s2 = void 0 === l2 ? null : l2, d = e2.testForHeightReduction, u = void 0 === d || d, c = n2.overflowY;
        if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u && (o4 = function(e3) {
          for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; ) e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
          return function() {
            return t5.forEach(function(e4) {
              var t6 = e4[0], o5 = e4[1];
              t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
            });
          };
        }(t4), t4.style.height = ""), i2 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i2 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i2 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i2 + "px", s2 && (t4.style.textAlign = s2), o4 && o4(), r2 !== i2 && (t4.dispatchEvent(new Event("autosize:resized", { bubbles: true })), r2 = i2), c !== n2.overflow && !s2)) {
          var v = n2.textAlign;
          "hidden" === n2.overflow && (t4.style.textAlign = "start" === v ? "end" : "start"), a({ restoreTextAlign: v, testForHeightReduction: true });
        }
      }
      function s() {
        a({ testForHeightReduction: true, restoreTextAlign: null });
      }
    }(t3);
  }), t2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t), e2;
}, r.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o), e2;
});
var n = r;
var google = class {
  constructor() {
    this.autocomplete = null;
    this.autocompleteListener = null;
    this.options = {};
  }
  init(container, onChange, options) {
    if (window.google === void 0 || window.google.maps === void 0 || window.google.maps.places === void 0 || window.google.maps.places.Autocomplete === void 0) ;
    this.options = options;
    this.autocomplete = new window.google.maps.places.Autocomplete(container, options);
    this.autocompleteListener = this.autocomplete.addListener("place_changed", () => {
      var place = this.autocomplete.getPlace();
      onChange(this.formatValue(place), place);
    });
  }
  destroy() {
    window.google.maps.event.removeListener(this.autocompleteListener);
    window.google.maps.event.clearInstanceListeners(this.autocomplete);
    var pac = document.querySelector(".pac-container");
    if (pac) {
      pac.remove();
    }
  }
  formatValue(value) {
    if (!isPlainObject_1(value)) {
      return value;
    }
    var addressComponents = value.address_components;
    var street = this.addressComponent(addressComponents, "street");
    var streetNumber = this.addressComponent(addressComponents, "street_number");
    var address = null;
    if (street !== null) {
      address = street;
    }
    if (streetNumber !== null) {
      address += (street !== null ? " " : "") + streetNumber;
    }
    return {
      country: this.addressComponent(addressComponents, "country"),
      country_code: this.addressComponent(addressComponents, "country_code"),
      state: this.addressComponent(addressComponents, "state"),
      state_code: this.addressComponent(addressComponents, "state_code"),
      city: this.addressComponent(addressComponents, "city"),
      zip: this.addressComponent(addressComponents, "zip"),
      address,
      formatted_address: value.formatted_address || null,
      lat: value.geometry.location.lat() || null,
      lng: value.geometry.location.lng() || null
    };
  }
  addressComponent(addressComponents, type) {
    var typeMap = {
      country: {
        field: "country",
        type: "long_name"
      },
      country_code: {
        field: "country",
        type: "short_name"
      },
      state: {
        field: "administrative_area_level_1",
        type: "long_name"
      },
      state_code: {
        field: "administrative_area_level_1",
        type: "short_name"
      },
      city: {
        field: "locality",
        type: "long_name"
      },
      zip: {
        field: "postal_code",
        type: "long_name"
      },
      street: {
        field: "route",
        type: "long_name"
      },
      street_number: {
        field: "street_number",
        type: "long_name"
      }
    };
    var addressComponent = null;
    each(addressComponents, (component) => {
      if (component.types.indexOf(typeMap[type].field) !== -1) {
        if (["state", "state_code"].indexOf(type) !== -1 && this.addressComponent(addressComponents, "country_code") != "US") {
          return;
        }
        addressComponent = component[typeMap[type].type] || null;
      }
    });
    return addressComponent;
  }
};
var algolia = class {
  constructor() {
    this.places = null;
    this.options = {};
  }
  init(container, onChange, options) {
    if (window.places === void 0) {
      throw new Error("Algolia Places API missing. Please include script in your project from https://community.algolia.com/places/documentation.html#cdn-script or install via npm and set to `window.places`.");
    }
    this.options = options;
    this.places = window.places(Object.assign({}, {
      container
    }, options));
    this.places.on("change", (e2) => {
      onChange(this.formatValue(e2.suggestion), e2.suggestion);
    });
  }
  destroy() {
    this.places.destroy();
  }
  formatValue(value) {
    if (!isPlainObject_1(value)) {
      return value;
    }
    return {
      country: value.country,
      country_code: value.countryCode ? value.countryCode.toUpperCase() : null,
      state: value.countryCode == "us" ? value.administrative : null,
      state_code: value.countryCode == "us" ? this.stateCode(value.administrative.toLowerCase()) : null,
      city: value.city,
      zip: value.postcode,
      address: value.name,
      formatted_address: value.value,
      lat: value.latlng.lat,
      lng: value.latlng.lng
    };
  }
  stateCode(name2) {
    var states = {
      AL: "alabama",
      AK: "alaska",
      AZ: "arizona",
      AR: "arkansas",
      CA: "california",
      CO: "colorado",
      CT: "connecticut",
      DE: "delaware",
      DC: "district of columbia",
      FL: "florida",
      GA: "georgia",
      HI: "hawaii",
      ID: "idaho",
      IL: "illinois",
      IN: "indiana",
      IA: "iowa",
      KS: "kansas",
      KY: "kentucky",
      LA: "louisiana",
      ME: "maine",
      MD: "maryland",
      MA: "massachusetts",
      MI: "michigan",
      MN: "minnesota",
      MS: "mississippi",
      MO: "missouri",
      MT: "montana",
      NE: "nebraska",
      NV: "nevada",
      NH: "new hampshire",
      NJ: "new Jersey",
      NM: "new Mexico",
      NY: "new york",
      NC: "north carolina",
      ND: "north dakota",
      OH: "ohio",
      OK: "oklahoma",
      OR: "oregon",
      PA: "pennsylvania",
      RI: "rhode Island",
      SC: "south carolina",
      SD: "south dakota",
      TN: "tennessee",
      TX: "texas",
      UT: "utah",
      VT: "vermont",
      VA: "virginia",
      WA: "washington",
      WV: "west virginia",
      WI: "wisconsin",
      WY: "wyoming"
    };
    if (values_1(states).indexOf(name2) === -1) {
      return null;
    }
    return keys_1(states)[values_1(states).indexOf(name2)];
  }
};
var location$4 = {
  google,
  algolia
};
var check = (condition2, elementPath, form$, el$2) => {
  var checkFunction = () => {
    return condition2(form$, el$2);
  };
  var checkArray = (condition3) => {
    var {
      conditionPath,
      operator,
      expected
    } = details(condition3);
    var element$ = form$.el$(conditionPath);
    var hasCircularCondition = false;
    if (element$ && elementPath) {
      each(element$.conditions, (condition4) => {
        if (!Array.isArray(condition4)) {
          return;
        }
        if (condition4[0] == elementPath) {
          hasCircularCondition = true;
        }
      });
    }
    if (!element$ || !hasCircularCondition && !element$.available) {
      return false;
    }
    return compareValues(element$.value, expected, operator);
  };
  var details = (condition3) => {
    return {
      conditionPath: elementPath ? replaceWildcards(condition3[0], elementPath) : condition3[0],
      operator: condition3.length == 3 || ["empty", "not_empty", "today"].indexOf(condition3[1]) !== -1 ? condition3[1] : "==",
      expected: condition3.length == 3 ? condition3[2] : ["empty", "not_empty", "today"].indexOf(condition3[1]) === -1 ? condition3[1] : true
    };
  };
  var compareValues = (actual, expected, operator) => {
    return compare(actual, operator, expected, el$2, form$);
  };
  if (typeof condition2 == "function") {
    return checkFunction();
  } else if (isArray_1(condition2) && isArray_1(condition2[0])) {
    return condition2.reduce((prev, curr) => {
      if (prev) {
        return prev;
      }
      if (isArray_1(curr[0])) {
        return curr.reduce((p, c) => !p ? p : checkArray(c), true);
      }
      return checkArray(curr);
    }, false);
  } else if (isArray_1(condition2)) {
    return checkArray(condition2);
  }
  throw new Error("Condition must be a function or an array");
};
var condition = {
  check
};
var i18n = class {
  constructor(options) {
    this.locales = options.locales;
    this.locale = options.locale;
    this.fallbackLocale = options.fallbackLocale;
  }
  $t(expr) {
    var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var tag = get_1(this.locales[this.locale], expr) || expr;
    if (tag === expr) {
      tag = get_1(this.locales[this.fallbackLocale], expr) || expr;
    }
    each(data, (value, key) => {
      tag = tag.replace(":" + key, value);
    });
    each(data, (value, key) => {
      tag = tag.replace("{" + key + "}", value);
    });
    return tag;
  }
};
var Columns = class {
  constructor(options, hasLabel, getClass, presets) {
    _defineProperty$2(this, "defaultBreakpoint", "default");
    this.presets = presets;
    this.configPresetColumns = this.serialize(this.columnsFromPresets(options.configPresetColumns) || {});
    this.configColumns = this.serialize(options.configColumns || {});
    this.formPresetColumns = this.serialize(this.columnsFromPresets(options.formPresetColumns) || {});
    this.formColumns = this.serialize(options.formColumns || {});
    this.presetColumns = this.serialize(this.columnsFromPresets(options.elementPresetColumns) || {});
    this.columns = this.serialize(options.elementColumns || {});
    this.hasLabel = hasLabel;
    this.getClass = getClass;
    this.cols = this.getCols();
  }
  get classes() {
    return {
      container: this.getClasses("container"),
      label: this.getClasses("label"),
      innerContainer: this.getClasses("innerContainer"),
      wrapper: this.getClasses("wrapper")
    };
  }
  serialize(columns) {
    if (["number", "string"].indexOf(typeof columns) !== -1) {
      return {
        [this.defaultBreakpoint]: {
          container: columns
        }
      };
    }
    if (typeof columns === "object" && ["container", "label", "wrapper"].indexOf(Object.keys(columns)[0]) !== -1) {
      var serialized = {};
      each(columns, (size2, type) => {
        if (["number", "string"].indexOf(typeof size2) !== -1) {
          if (serialized[this.defaultBreakpoint] === void 0) {
            serialized[this.defaultBreakpoint] = {};
          }
          serialized[this.defaultBreakpoint][type] = size2;
        } else {
          each(size2, (s, breakpoint) => {
            if (serialized[breakpoint] === void 0) {
              serialized[breakpoint] = {};
            }
            serialized[breakpoint][type] = s;
          });
        }
      });
      return serialized;
    } else {
      var _serialized = {};
      each(columns, (size2, breakpoint) => {
        if (["number", "string"].indexOf(typeof size2) !== -1) {
          if (_serialized[breakpoint] === void 0) {
            _serialized[breakpoint] = {};
          }
          _serialized[breakpoint].container = size2;
        } else {
          _serialized[breakpoint] = size2;
        }
      });
      return _serialized;
    }
  }
  columnsFromPresets(presets) {
    var columns;
    each(presets, (presetName) => {
      var preset = this.presets[presetName];
      if (!preset || !preset.columns) {
        return;
      }
      columns = preset.columns;
    });
    return columns;
  }
  getNullClass() {
    return [this.getClass(this.defaultBreakpoint, 0)];
  }
  getClasses(type) {
    var classes = [];
    Object.keys(this.cols).forEach((breakpoint) => {
      var size2;
      if (type === "innerContainer") {
        size2 = this.cols[breakpoint].label;
        size2 = size2 >= 12 || !this.hasLabel ? 12 : 12 - size2;
      } else {
        size2 = this.cols[breakpoint][type];
        if (type === "label" && !this.hasLabel) {
          size2 = 0;
        }
      }
      if (size2 !== void 0 && !isNaN(size2)) {
        classes.push(this.getClass(breakpoint, size2));
      }
    });
    return classes;
  }
  getCols() {
    return merge_1({}, {
      [this.defaultBreakpoint]: {
        container: 12,
        label: 12,
        wrapper: 12
      }
    }, this.configPresetColumns || {}, this.configColumns || {}, this.formPresetColumns || {}, this.formColumns || {}, this.presetColumns || {}, this.columns || {});
  }
};
var CaptchaProviderInterface = class {
  constructor(element2, options, el$2) {
  }
  init() {
  }
  render() {
  }
  reset() {
  }
  getResponse() {
  }
  validate(response) {
    return _asyncToGenerator(function* () {
    })();
  }
};
var Recaptcha2Provider = class extends CaptchaProviderInterface {
  constructor(element2, options, el$2) {
    super(element2, options, el$2);
    _defineProperty$2(this, "src", "https://www.google.com/recaptcha/api.js?onload=recaptcha2LoadCallback&render=explicit");
    _defineProperty$2(this, "element", void 0);
    _defineProperty$2(this, "options", {});
    _defineProperty$2(this, "el$", {});
    _defineProperty$2(this, "id", void 0);
    _defineProperty$2(this, "rendered", false);
    _defineProperty$2(this, "interval", void 0);
    this.element = element2;
    this.options = options;
    this.el$ = el$2;
    this.init();
  }
  init() {
    this.loadScript();
  }
  render() {
    this.id = window.grecaptcha.render(this.element, _objectSpread2$1({
      callback: (token) => {
        this.el$.update(token);
      },
      "expired-callback": () => {
        this.el$.clear();
      },
      "error-callback": () => {
        this.el$.clear();
      }
    }, this.options));
    this.rendered = true;
  }
  reset() {
    if (!this.rendered) {
      return;
    }
    return window.grecaptcha.reset(this.id);
  }
  getResponse() {
    return window.grecaptcha.getResponse(this.id);
  }
  validate(response) {
    return _asyncToGenerator(function* () {
      return !!response;
    })();
  }
  loadScript() {
    if (this.isCaptchaLoaded()) {
      this.render();
      return;
    }
    if (this.isScriptAdded()) {
      this.interval = setInterval(() => {
        if (this.isCaptchaLoaded()) {
          this.render();
          clearInterval(this.interval);
        }
      }, 500);
      return;
    }
    window.recaptcha2LoadCallback = () => {
      this.render();
    };
    var script = document.createElement("script");
    script.src = this.src;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
    script.onload = () => {
    };
    script.onerror = () => {
      console.error("Error loading reCAPTCHA!");
    };
  }
  isCaptchaLoaded() {
    return typeof window !== "undefined" && window.grecaptcha;
  }
  isScriptAdded() {
    var scripts2 = document.getElementsByTagName("script");
    for (var i = 0; i < scripts2.length; i++) {
      if (scripts2[i].src.includes("https://www.google.com/recaptcha/api.js")) {
        return true;
      }
    }
    return false;
  }
};
var config = {
  /**
   * General
   */
  env: "development",
  plugins: [],
  elements: [],
  /**
   * Theme & layout
   */
  theme: {},
  templates: {},
  views: {},
  size: "md",
  addClasses: {},
  removeClasses: {},
  replaceClasses: {},
  overrideClasses: {},
  presets: {},
  usePresets: [],
  classHelpers: false,
  columns: {},
  forceLabels: false,
  floatPlaceholders: true,
  displayErrors: true,
  displayMessages: true,
  breakpoints: ["sm", "md", "lg", "xl", "2xl"],
  /**
   * Localization
   */
  languages: {
    en: "English"
  },
  language: "en",
  locales: {},
  locale: null,
  fallbackLocale: "en",
  /**
   * Sorting
   */
  orderFrom: 1,
  /**
   * Validation
   */
  rules: {},
  validateOn: "change|step",
  scrollToInvalid: true,
  showRequired: [],
  /**
   * Steps
   */
  scrollOnNext: true,
  /**
   * Data
   */
  forceNumbers: false,
  /**
   * Condition
   */
  operators: {},
  /**
   * Submitting
   */
  endpoints: {
    submit: {
      url: "/vueform/process",
      method: "post"
    },
    uploadTempFile: {
      url: "/vueform/file/upload-temp",
      method: "post"
    },
    removeTempFile: {
      url: "/vueform/file/remove-temp",
      method: "post"
    },
    removeFile: {
      url: "/vueform/file/remove",
      method: "post"
    },
    attachment: {
      url: "/vueform/editor/attachment",
      method: "post"
    },
    activeUrl: {
      url: "/vueform/validators/active_url",
      method: "post"
    },
    unique: {
      url: "/vueform/validators/unique",
      method: "post"
    },
    exists: {
      url: "/vueform/validators/exists",
      method: "post"
    }
  },
  formData(form$) {
    return form$.convertFormData(_objectSpread2$1(_objectSpread2$1({}, form$.requestData), form$.formKey ? {
      formKey: form$.formKey
    } : {}));
  },
  beforeSend: null,
  axios: {},
  /**
   * Providers
   */
  locationProvider: "google",
  providers: {
    captcha: {
      recaptcha2: Recaptcha2Provider
    }
  },
  useProviders: {
    captcha: "recaptcha2"
  },
  providerOptions: {
    recaptcha2: {
      sitekey: "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI"
    }
  },
  /**
   * Services
   */
  services: {
    algolia: {
      app_id: "",
      api_key: ""
    }
  }
};
function installer() {
  var config$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : config;
  var components2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var rules2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var services = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var Vueform = class {
    constructor() {
      this.options = {
        config: omit_1(config$1, ["theme", "templates", "locales", "rules", "plugins"]),
        templates: config$1.templates || {},
        components: config$1.components || {},
        theme: config$1.theme || {},
        rules: _objectSpread2$1(_objectSpread2$1({}, rules2), config$1.rules || {}),
        locales: config$1.locales || {},
        plugins: config$1.plugins || [],
        i18n: null,
        vueVersion: null,
        services: _objectSpread2$1({
          validation,
          axios: axios_default,
          messageBag,
          autosize: n,
          location: location$4,
          condition,
          columns: Columns
        }, services),
        version: packageJson.version
      };
    }
    config(config2) {
      each(["theme", "templates", "locales", "rules"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options[attr] = Object.assign({}, this.options[attr], config2[attr]);
        }
      });
      each(["plugins", "components"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options[attr] = config2[attr];
        }
      });
      each(["languages", "services", "presets", "views", "operators"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = Object.assign({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["addClasses", "removeClasses", "replaceClasses", "overrideClasses"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = typeof config2[attr] === "function" ? config2[attr] : Object.assign({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["endpoints", "providers", "useProviders", "providerOptions"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = merge_1({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["columns", "forceLabels", "displayErrors", "floatPlaceholders", "displayErrors", "displayMessages", "language", "locale", "fallbackLocale", "orderFrom", "validateOn", "formData", "beforeSend", "locationProvider", "classHelpers", "env", "usePresets", "plugins", "size", "apiKey", "forceNumbers", "scrollToInvalid", "showRequired", "scrollOnNext"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = config2[attr];
        }
      });
      if (config2.elements) {
        config2.elements.forEach((element2) => {
          components2[element2.name] = omit_1(element2, ["render", "staticRenderFns", "components"]);
        });
        config2.elements.forEach((element2) => {
          if (this.options.templates[element2.name] === void 0) {
            this.options.templates[element2.name] = pick_1(element2, ["render", "staticRenderFns", "components"]);
          }
        });
      }
      if (config2.axios !== void 0) {
        if (typeof config2.axios === "function") {
          this.options.services.axios = config2.axios;
        } else {
          this.options.config.axios = config2.axios;
        }
      }
    }
    registerComponents(appOrVue) {
      each(components2, (comp, name2) => {
        if (comp.register === false) {
          return;
        }
        var component = _objectSpread2$1({}, comp);
        component.setup = (props, context) => {
          context = Object.assign({}, context, {
            name: ref(name2),
            emits: component.emits
          });
          var setup = comp.setup(props, context);
          this.options.plugins.forEach((p) => {
            if (typeof p === "function") {
              p = p();
            }
            p = Array.isArray(p) ? p : [p];
            p.forEach((plugin) => {
              var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
              if (pluginOptions.setup && shouldApplyPlugin(name2, pluginOptions)) {
                setup = pluginOptions.setup(props, context, setup);
              }
            });
          });
          return setup;
        };
        if (component.components === void 0) {
          var _this$options$templat, _this$options$theme$t;
          component.components = ((_this$options$templat = this.options.templates[name2]) === null || _this$options$templat === void 0 ? void 0 : _this$options$templat.components) || ((_this$options$theme$t = this.options.theme.templates[name2]) === null || _this$options$theme$t === void 0 ? void 0 : _this$options$theme$t.components) || {};
        }
        component.render = function() {
          return this.template.render.apply(this, arguments);
        };
        component.staticRenderFns = function() {
          return this.template.staticRenderFns;
        };
        this.options.plugins.forEach((p) => {
          if (typeof p === "function") {
            p = p();
          }
          p = Array.isArray(p) ? p : [p];
          p.forEach((plugin) => {
            var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
            each(without_1(Object.keys(pluginOptions), "setup", "apply", "config", "install"), (key) => {
              if (pluginOptions[key] && shouldApplyPlugin(name2, pluginOptions)) {
                if (Array.isArray(pluginOptions[key])) {
                  var base81 = component[key] || [];
                  component[key] = base81.concat(pluginOptions[key]);
                } else if (isPlainObject_1(pluginOptions[key])) {
                  component[key] = Object.assign({}, component[key] || {}, pluginOptions[key]);
                } else {
                  component[key] = pluginOptions[key];
                }
              }
            });
          });
        });
        appOrVue.component(name2, component);
      });
    }
    initAxios() {
      var $axios = this.options.services.axios;
      var axiosConfig = this.options.config.axios;
      var axiosConfigFlat = flatten(this.options.config.axios);
      Object.keys(axiosConfigFlat).forEach((key) => {
        var value = axiosConfigFlat[key];
        if (["onUnauthenticated"].indexOf(key) === -1 && key.indexOf("csrfRequest.") === -1) {
          set_1($axios.defaults, key, value);
        }
      });
      $axios.interceptors.response.use((r2) => r2, (error) => {
        if (!error.response) {
          return Promise.reject(error);
        }
        return new Promise((resolve, reject) => {
          var response = error.response;
          var originalRequest = response.config;
          if ([401, 419].indexOf(error.response.status) !== -1) {
            if (axiosConfig.csrfRequest && !originalRequest.CSRF) {
              $axios.request(_objectSpread2$1(_objectSpread2$1({}, axiosConfig.csrfRequest), {}, {
                CSRF: true
              })).then(() => {
                resolve($axios.request(_objectSpread2$1(_objectSpread2$1({}, originalRequest), {}, {
                  CSRF: true
                })));
              }).catch((error2) => {
                reject(error2);
              });
            } else if (axiosConfig.onUnauthenticated) {
              axiosConfig.onUnauthenticated(originalRequest);
            } else {
              reject(error);
            }
          } else {
            reject(error);
          }
        });
      });
    }
    initI18n() {
      this.options.i18n = new i18n({
        locales: this.options.locales,
        locale: this.options.config.locale,
        fallbackLocale: this.options.config.fallbackLocale
      });
    }
    install(appOrVue) {
      var _this$options$theme;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var version2 = parseInt(appOrVue.version.split(".")[0]);
      var minor = parseInt(appOrVue.version.split(".")[1]);
      this.options.vueVersion = version2;
      var plugins2 = options.plugins || [];
      plugins2.forEach((p) => {
        if (typeof p === "function") {
          p = p();
        }
        p = Array.isArray(p) ? p : [p];
        p.forEach((plugin) => {
          var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
          if (pluginOptions.config) {
            pluginOptions.config(options);
          }
        });
      });
      if (options) {
        this.config(options);
      }
      this.options.plugins.forEach((p) => {
        if (typeof p === "function") {
          p = p();
        }
        p = Array.isArray(p) ? p : [p];
        p.forEach((plugin) => {
          var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
          if (pluginOptions.install) {
            pluginOptions.install(appOrVue, this.options);
          }
        });
      });
      if (typeof config$1.axios !== "function") {
        this.initAxios();
      }
      this.initI18n();
      Object.keys(this.options.components).forEach((componentName) => {
        components2[componentName] = this.options.components[componentName];
      });
      this.registerComponents(appOrVue);
      var themeTemplates = ((_this$options$theme = this.options.theme) === null || _this$options$theme === void 0 ? void 0 : _this$options$theme.templates) || {};
      Object.keys(themeTemplates).forEach((componentName) => {
        themeTemplates[componentName] = markRaw(themeTemplates[componentName]);
      });
      var $vueform = ref(_objectSpread2$1(_objectSpread2$1({}, this.options), {}, {
        theme: _objectSpread2$1(_objectSpread2$1({}, this.options.theme), {}, {
          templates: themeTemplates
        })
      }));
      switch (version2) {
        case 2:
          appOrVue.config.ignoredElements = ["trix-editor"];
          appOrVue.config.unwrapInjectedRef = true;
          if (!appOrVue.prototype.$vueform) {
            appOrVue.prototype.$vueform = new Proxy($vueform, {
              get: (target, prop, receiver) => {
                return target.value[prop];
              }
            });
          }
          if (!appOrVue.__VUEFORM__) {
            appOrVue.__VUEFORM__ = true;
            appOrVue.mixin({
              methods: {
                __: (expr, data) => {
                  if (!data) {
                    console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                  }
                  return this.options.i18n.$t(expr, data);
                }
              }
            });
          }
          break;
        case 3:
          if (minor < 3) {
            appOrVue.config.unwrapInjectedRef = true;
          }
          if (!appOrVue.component("trix-editor")) {
            appOrVue.component("trix-editor", {
              render() {
                return h("trix-editor");
              }
            });
          }
          appOrVue.config.globalProperties.$vueform = new Proxy($vueform, {
            get: (target, prop, receiver) => {
              return target.value[prop];
            }
          });
          appOrVue.provide("$vueform", $vueform);
          appOrVue.mixin({
            methods: {
              $set(obj, key, value) {
                obj[key] = value;
              },
              $delete(obj, key) {
                delete obj[key];
              },
              __: (expr, data) => {
                if (!data) {
                  console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                }
                return this.options.i18n.$t(expr, data);
              }
            }
          });
          break;
      }
    }
  };
  return new Vueform();
}
var base$1b = function base4(props, context, dependencies2) {
  var form$ = inject("form$");
  return {
    form$
  };
};
var base$1a = function base5(props, context, dependencies2) {
  var theme = inject("theme");
  return {
    theme
  };
};
var base$19 = function base6(props, context, dependencies2) {
  var Size = inject("Size");
  return {
    Size
  };
};
var base$18 = function base7(props, context, dependencies2) {
  var {
    view
  } = toRefs(props);
  var componentName = context.name;
  var Views = inject("Views") || ref({});
  var ViewInject = inject("View", ref(void 0));
  var View = computed(() => {
    if (view && view.value) {
      return view.value;
    }
    if (Views.value[componentName.value]) {
      return Views.value[componentName.value];
    }
    return ViewInject.value;
  });
  return {
    View
  };
};
var base$17 = function base8(props, context, dependencies2) {
  var componentName = context.name;
  var {
    form$
  } = base$1b();
  var {
    theme
  } = base$1a();
  var {
    Size
  } = base$19();
  var {
    View
  } = base$18(props, context);
  var component$ = computed(() => {
    return getCurrentInstance().proxy;
  });
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options]
    });
  });
  var classes = computed(() => {
    return classesInstance.value.classes;
  });
  var Templates = computed(() => {
    return theme.value.templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    form$,
    theme,
    Size,
    View,
    classesInstance,
    classes,
    Templates,
    template
  };
};
var FormErrors = {
  name: "FormErrors",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var errors = computed(() => {
      return form$.value.formErrors;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      errors
    };
  }
};
var FormMessages = {
  name: "FormMessages",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var messages = computed(() => {
      return form$.value.formMessages;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      messages
    };
  }
};
var FormLanguages = {
  name: "FormLanguages",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var language = computed(() => {
      return form$.value.selectedLanguage;
    });
    var languages = computed(() => {
      return form$.value.options.languages;
    });
    var select7 = (code) => {
      form$.value.setLanguage(code);
    };
    var handleSelect = (code) => {
      select7(code);
    };
    provide("View", View);
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      language,
      languages,
      select: select7,
      handleSelect
    };
  }
};
var FormLanguage = {
  name: "FormLanguage",
  emits: ["select"],
  props: {
    language: {
      type: String,
      required: true
    },
    code: {
      type: String,
      required: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      code
    } = toRefs(props);
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var selectedLanguage = computed(() => {
      return form$.value.selectedLanguage;
    });
    var selected = computed(() => {
      return selectedLanguage.value == code.value;
    });
    var select7 = () => {
      context.emit("select", code.value);
    };
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      selectedLanguage,
      selected,
      classes,
      Templates,
      template,
      select: select7
    };
  }
};
var baseIteratee$3 = _baseIteratee;
var isArrayLike = isArrayLike_1;
var keys = keys_1;
function createFind$2(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee$3(predicate);
      collection = keys(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var _createFind = createFind$2;
var baseFindIndex$1 = _baseFindIndex;
var baseIteratee$2 = _baseIteratee;
var toInteger$1 = toInteger_1;
var nativeMax$1 = Math.max;
function findIndex$1(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger$1(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax$1(length + index2, 0);
  }
  return baseFindIndex$1(array4, baseIteratee$2(predicate), index2);
}
var findIndex_1 = findIndex$1;
var createFind$1 = _createFind;
var findIndex = findIndex_1;
var find$1 = createFind$1(findIndex);
var find_1 = find$1;
var baseFindIndex = _baseFindIndex;
var baseIteratee$1 = _baseIteratee;
var toInteger = toInteger_1;
var nativeMax = Math.max;
var nativeMin = Math.min;
function findLastIndex$1(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index2 = length - 1;
  if (fromIndex !== void 0) {
    index2 = toInteger(fromIndex);
    index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
  }
  return baseFindIndex(array4, baseIteratee$1(predicate), index2, true);
}
var findLastIndex_1 = findLastIndex$1;
var createFind = _createFind;
var findLastIndex = findLastIndex_1;
var findLast = createFind(findLastIndex);
var findLast_1 = findLast;
var FormTabs = {
  name: "FormTabs",
  emits: ["select"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1e(props, context, {
      form$
    }, {
      events: context.emits
    });
    var tabs$Array = ref([]);
    var exists2 = ref(true);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var tabs = computed(() => {
      return form$.value.options.tabs;
    });
    var tabs$ = computed(() => {
      var tabList$ = {};
      each(tabs$Array.value, (formTab$) => {
        tabList$[formTab$.name] = formTab$;
      });
      return tabList$;
    });
    var visible$ = computed(() => {
      var tabList$ = {};
      each(tabs$.value, (tab$2) => {
        if (tab$2.visible) {
          tabList$[tab$2.name] = tab$2;
        }
      });
      return tabList$;
    });
    var current$ = computed(() => {
      var current = find_1(tabs$.value, {
        active: true
      });
      return current !== void 0 ? current : {};
    });
    var first$ = computed(() => {
      return find_1(visible$.value, (tab) => {
        return tab.visible;
      });
    });
    var last$ = computed(() => {
      return Object.values(visible$.value).pop();
    });
    var next$ = computed(() => {
      return find_1(visible$.value, (tab) => {
        return tab.index > current$.value.index && tab.visible;
      });
    });
    var previous$ = computed(() => {
      return findLast_1(visible$.value, (tab) => {
        return tab.index < current$.value.index && tab.visible;
      });
    });
    var goTo = (name2) => {
      var tab$2 = visible$.value[name2];
      tab$2.select();
    };
    var select7 = (tab$2) => {
      var curr$ = current$.value;
      each(elements$.value, (element$) => {
        element$.deactivate();
      });
      each(tabs$.value, (tab$3) => {
        tab$3.deactivate();
      });
      fire("select", tab$2, curr$);
    };
    var tab$ = (name2) => {
      return find_1(tabs$.value, {
        name: name2
      });
    };
    var reset = () => {
      first$.value.select();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.tabs$ !== void 0) {
        form$.value.$set($parent, "tabs$", $this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.tabs$ !== void 0) {
        form$.value.$set($parent, "tabs$", null);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    provide("View", View);
    watch(elements$, (newValue, oldValue) => {
      var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
      each(newElements$, (newElement$) => {
        elements$.value[newElement$].deactivate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(tabs, _asyncToGenerator(function* () {
      yield nextTick();
      yield nextTick();
      if ((current$.value === void 0 || current$.value.index === void 0) && first$.value) {
        first$.value.select();
      }
    }), {
      deep: true,
      lazy: true
    });
    watch(tabs, (newValue) => {
      var newTabs$Array = [];
      each(newValue, (t2, name2) => {
        newTabs$Array.push(tabs$Array.value[tabs$Array.value.map((t$) => normalize(t$.name)).indexOf(normalize(name2))]);
      });
      tabs$Array.value = newTabs$Array;
    }, {
      flush: "post"
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeFromParent($this.$parent, removeFromParent);
    });
    onMounted(() => {
      nextTick(() => {
        if (!find_1(tabs$.value, {
          active: true
        })) {
          first$.value.select();
        }
      });
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      tabs,
      elements$,
      tabs$Array,
      events,
      listeners,
      exists: exists2,
      classes,
      Templates,
      template,
      tabs$,
      visible$,
      current$,
      first$,
      last$,
      next$,
      previous$,
      goTo,
      select: select7,
      tab$,
      reset,
      on: on2,
      off: off2,
      fire
    };
  }
};
var base$16 = function base9(props, context, dependencies2) {
  var {
    parent: parent2,
    conditions
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path || ref(null);
  var el$2 = dependencies2.el$ || ref(void 0);
  var conditionList = ref(conditions.value);
  var additionalConditions = ref({});
  var available = computed(() => {
    if (!form$.value.conditions) {
      return true;
    }
    if (parent2 && parent2.value && parent2.value.available !== void 0 && !parent2.value.available) {
      return false;
    }
    if (!conditionList.value || !conditionList.value.length) {
      return true;
    }
    return !some_1(conditionList.value, (condition2) => {
      return !form$.value.$vueform.services.condition.check(condition2, path.value, form$.value, el$2.value);
    });
  });
  var updateConditions = () => {
    conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
      return prev.concat(curr);
    }, conditions.value);
  };
  var addConditions = (key, conditions2) => {
    additionalConditions.value[key] = conditions2;
    updateConditions();
  };
  var removeConditions = (key) => {
    delete additionalConditions.value[key];
    updateConditions();
  };
  return {
    conditionList,
    available,
    additionalConditions,
    updateConditions,
    addConditions,
    removeConditions
  };
};
var list$5 = function list(props, context, dependencies2) {
  var {
    conditionList,
    available,
    additionalConditions,
    addConditions,
    removeConditions
  } = base$16(props, context, dependencies2);
  var {
    conditions
  } = toRefs(props);
  var children$Array = dependencies2.children$Array;
  var updateConditions = () => {
    conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
      return prev.concat(curr);
    }, conditions.value);
    children$Array.value.forEach((child$) => {
      child$.updateConditions();
    });
  };
  return {
    conditionList,
    available,
    updateConditions,
    addConditions,
    removeConditions
  };
};
var object$8 = list$5;
var group$8 = list$5;
var {
  hasOwnProperty,
  toString
} = Object.prototype;
function isNonEmptyString(value) {
  return typeof value === "string" && value.trim().length > 0;
}
function isFunction(value) {
  return typeof value === "function";
}
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isNonNullObject(value) {
  return !!value;
}
function isElement(value) {
  return isNonNullObject(value) && value.nodeType === 1 && toString.call(value).indexOf("Element") > -1;
}
function isVueComponent(value) {
  return isPlainObject_1(value) && (isNonEmptyString(value.template) || isFunction(value.render) || isNonEmptyString(value.el) || isElement(value.el) || isVueComponent(value.extends) || isNonEmptyArray(value.mixins) && value.mixins.some((val) => isVueComponent(val))) || typeof value === "function" && value.prototype && value.prototype.constructor.name === "VueComponent";
}
function localize(object9, $config, form$) {
  var locale = form$.locale$ || $config.i18n.locale;
  if (!locale) {
    return object9;
  }
  return object9 && typeof object9 === "object" ? (object9 === null || object9 === void 0 ? void 0 : object9[locale]) || (object9 === null || object9 === void 0 ? void 0 : object9[locale.toUpperCase()]) || (object9 === null || object9 === void 0 ? void 0 : object9[$config.i18n.fallbackLocale]) || (object9 === null || object9 === void 0 ? void 0 : object9[$config.i18n.fallbackLocale.toUpperCase()]) || (object9 === null || object9 === void 0 ? void 0 : object9[Object.keys(object9)[0]]) || "" : object9;
}
var base$15 = function base10(props, context, dependencies2) {
  var labelDefinition = dependencies2.labelDefinition;
  var component$ = dependencies2.component$ || ref(null);
  var form$ = inject("form$");
  var config$ = inject("config$");
  var baseLabel = computed(() => {
    return labelDefinition.value;
  });
  var isLabelFunction = computed(() => {
    return typeof baseLabel.value === "function" && (!baseLabel.value.prototype || !baseLabel.value.prototype.constructor || baseLabel.value.prototype.constructor && baseLabel.value.prototype.constructor.name !== "VueComponent");
  });
  var isLabelComponent = computed(() => {
    return isVueComponent(baseLabel.value);
  });
  var label = computed(() => {
    var label2 = isLabelFunction.value ? baseLabel.value(component$.value) : baseLabel.value || null;
    if (!isLabelComponent.value) {
      label2 = localize(label2, config$.value, form$.value);
    }
    return label2;
  });
  return {
    label,
    isLabelComponent
  };
};
var FormTab = {
  name: "FormTab",
  emits: ["activate", "inactivate"],
  slots: ["default"],
  props: {
    /**
     * Name of tab within [tabs](reference/frontend-form#prop-tabs) object.
     */
    name: {
      type: [String, Number],
      required: true
    },
    label: {
      type: [String, Object, Function],
      required: false,
      default: null
    },
    elements: {
      type: [Array],
      required: false,
      default: () => []
    },
    conditions: {
      type: [Array],
      required: false,
      default: () => []
    },
    addClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    onActivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onInactivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    }
  },
  setup(props, context) {
    var {
      name: name2,
      label,
      elements
    } = toRefs(props);
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var {
      available,
      conditionList,
      updateConditions
    } = base$16(props, context, {
      form$
    });
    var {
      isLabelComponent,
      label: tabLabel_
    } = base$15(props, context, {
      component$: form$,
      labelDefinition: label
    });
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1e(props, context, {
      form$
    }, {
      events: context.emits
    });
    var active = ref(false);
    var tabLabel = ref(tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var tabs$ = computed(() => {
      return form$.value.tabs$;
    });
    var index2 = computed(() => {
      var _tabs$$value;
      return Object.keys((tabs$ === null || tabs$ === void 0 || (_tabs$$value = tabs$.value) === null || _tabs$$value === void 0 ? void 0 : _tabs$$value.tabs$) || /* istanbul ignore next: tab can not stand by itself */
      {}).indexOf(name2.value);
    });
    var isFirst = computed(() => {
      return index2.value === 0;
    });
    var isLast = computed(() => {
      return tabs$.value.last$.name === name2.value;
    });
    var children$ = computed(() => {
      return filter_1(elements$.value, (element$, key) => {
        return elements.value.indexOf(key) !== -1;
      });
    });
    var visible = computed(() => {
      return available.value;
    });
    var invalid = computed(() => {
      return some_1(children$.value, {
        available: true,
        invalid: true
      });
    });
    var tab$ = computed(() => {
      return form$.value.tabs$.tabs$[name2.value];
    });
    var select7 = () => {
      var _tabs$$value2, _tabs$$value3;
      if (active.value || !((_tabs$$value2 = tabs$.value) !== null && _tabs$$value2 !== void 0 && _tabs$$value2.select)) {
        return;
      }
      (_tabs$$value3 = tabs$.value) === null || _tabs$$value3 === void 0 || _tabs$$value3.select(tab$.value);
      activate();
    };
    var activate = () => {
      if (active.value) {
        return;
      }
      active.value = true;
      each(children$.value, (element$) => {
        element$.activate();
      });
      fire("activate");
    };
    var deactivate = () => {
      if (!active.value) {
        return;
      }
      active.value = false;
      each(children$.value, (element$) => {
        element$.deactivate();
      });
      fire("inactivate");
    };
    var addChildConditions = () => {
      if (conditionList.value.length == 0) {
        return;
      }
      Object.values(children$.value).forEach((element$) => {
        element$.addConditions("tab", conditionList.value);
      });
    };
    var removeChildConditions = () => {
      Object.values(children$.value).forEach((element$) => {
        element$.removeConditions("tab");
      });
    };
    var resetChildConditions = () => {
      removeChildConditions();
      addChildConditions();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.tabs$Array) {
        $parent.tabs$Array.push($this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.tabs$Array) {
        $parent.tabs$Array.splice($parent.tabs$Array.map((t$) => normalize(t$.name)).indexOf(normalize(name2.value)), 1);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    watch(children$, () => {
      if (!active.value) {
        return;
      }
      each(children$.value, (element$) => {
        element$.activate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(tabLabel_, () => {
      tabLabel.value = tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value;
    });
    watch(conditionList, (n2, o2) => {
      if (!(n2 !== null && n2 !== void 0 && n2.length)) {
        removeChildConditions();
      } else {
        addChildConditions();
      }
    });
    onMounted(() => {
      nextTick(() => {
        addChildConditions();
      });
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeChildConditions();
      removeFromParent($this.$parent, removeFromParent);
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      elements$,
      index: index2,
      isFirst,
      isLast,
      active,
      events,
      listeners,
      children$,
      visible,
      invalid,
      classes,
      Templates,
      template,
      available,
      isLabelComponent,
      tabLabel,
      tab$,
      tabs$,
      conditionList,
      select: select7,
      activate,
      deactivate,
      on: on2,
      off: off2,
      fire,
      addChildConditions,
      removeChildConditions,
      resetChildConditions,
      updateConditions
    };
  }
};
var FormSteps = {
  name: "FormSteps",
  emits: ["select", "next", "previous", "finish"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1e(props, context, {
      form$
    }, {
      events: context.emits
    });
    var steps$Array = ref([]);
    var unwatchInvalid = ref(null);
    var exists2 = ref(true);
    var steps = computed(() => {
      return form$.value.options.steps;
    });
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var pending = computed(() => {
      return some_1(visible$.value, {
        pending: true
      });
    });
    var debouncing = computed(() => {
      return some_1(visible$.value, {
        debouncing: true
      });
    });
    var invalid = computed(() => {
      return some_1(visible$.value, {
        invalid: true
      });
    });
    var done = computed(() => {
      return !some_1(visible$.value, {
        done: false
      });
    });
    var busy = computed(() => {
      return pending.value || debouncing.value;
    });
    var steps$ = computed(() => {
      var steps$2 = {};
      each(steps$Array.value, (step$2) => {
        steps$2[step$2.name] = step$2;
      });
      return steps$2;
    });
    var visible$ = computed(() => {
      var stepList$ = {};
      each(steps$.value, (step$2) => {
        if (step$2.visible) {
          stepList$[step$2.name] = step$2;
        }
      });
      return stepList$;
    });
    var first$ = computed(() => {
      return find_1(visible$.value, (step) => {
        return step.visible;
      });
    });
    var last$ = computed(() => {
      return Object.values(visible$.value).pop();
    });
    var current$ = computed(() => {
      var current = find_1(steps$.value, {
        active: true
      });
      return current !== void 0 ? current : {};
    });
    var next$ = computed(() => {
      return find_1(visible$.value, (step) => {
        return step.index > current$.value.index && step.visible;
      });
    });
    var previous$ = computed(() => {
      return findLast_1(visible$.value, (step) => {
        return step.index < current$.value.index && step.visible;
      });
    });
    var firstInvalid$ = computed(() => {
      return find_1(visible$.value, {
        invalid: true
      });
    });
    var firstNonDone$ = computed(() => {
      return find_1(visible$.value, {
        done: false
      });
    });
    var lastEnabled$ = computed(() => {
      return findLast_1(visible$.value, {
        isDisabled: false
      });
    });
    var isAtLastStep = computed(() => {
      var last2 = findLast_1(visible$.value, {
        visible: true
      });
      if (!current$.value || !last2) {
        return false;
      }
      return last2.index === current$.value.index;
    });
    var isAtFirstStep = computed(() => {
      return current$.value.index === 0;
    });
    var goTo = function goTo2(name2) {
      var enableUntil2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var step = visible$.value[name2];
      step.enable();
      step.select();
      if (enableUntil2) {
        nextTick(() => {
          enableUntilLastEnabled();
        });
      }
    };
    var next = () => {
      fire("next", next$.value);
      next$.value.enable();
      next$.value.select();
      if (form$.value.options.scrollOnNext && form$.value.$el.scrollIntoView) {
        nextTick(() => {
          form$.value.$el.scrollIntoView({
            behavior: "smooth"
          });
        });
      }
    };
    var previous = () => {
      fire("previous", previous$.value);
      previous$.value.select();
    };
    var complete = () => {
      each(steps$.value, (step$2) => {
        step$2.complete();
      });
    };
    var step$ = (name2) => {
      return find_1(visible$.value, {
        name: name2
      });
    };
    var reset = () => {
      each(steps$.value, (step$2) => {
        step$2.uncomplete();
        step$2.disable();
      });
      first$.value.enable();
      first$.value.select();
    };
    var enableAllSteps = () => {
      each(steps$.value, (step$2) => {
        step$2.enable();
      });
    };
    var submit = function() {
      var _ref = _asyncToGenerator(function* () {
        yield form$.value.submit();
        if (invalid.value) {
          firstInvalid$.value.select();
          nextTick(() => {
            form$.value.scrollToFirstInvalid();
          });
          return;
        }
        unwatchInvalid.value = watch(invalid, (isInvalid) => {
          if (isInvalid) {
            firstInvalid$.value.select();
          }
          unwatchInvalid.value();
        });
      });
      return function submit2() {
        return _ref.apply(this, arguments);
      };
    }();
    var select7 = (step$2) => {
      var curr$ = current$.value;
      each(elements$.value, (element$) => {
        element$.deactivate();
      });
      each(steps$.value, (step$3) => {
        step$3.deactivate();
      });
      fire("select", step$2, curr$);
    };
    var enableUntil = (index2) => {
      each(steps$.value, (step$2) => {
        if (step$2.index <= index2 && step$2.visible) {
          step$2.enable();
        }
      });
    };
    var enableUntilCurrent = () => {
      enableUntil(current$.value.index);
    };
    var enableUntilLastEnabled = () => {
      if (!lastEnabled$.value && !first$.value) {
        return;
      }
      enableUntil(lastEnabled$.value !== void 0 ? lastEnabled$.value.index : first$.value.index);
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.steps$ !== void 0) {
        form$.value.$set($parent, "steps$", $this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.steps$ !== void 0) {
        form$.value.$set($parent, "steps$", null);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    provide("View", View);
    watch(elements$, (newValue, oldValue) => {
      var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
      each(newElements$, (newElement$) => {
        elements$.value[newElement$].deactivate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(steps, () => {
      nextTick(() => {
        if (lastEnabled$.value === void 0) ;
        if (current$.value.index === void 0 && first$.value) {
          first$.value.select();
        }
      });
    }, {
      deep: true,
      lazy: true
    });
    watch(steps, (newValue) => {
      var newSteps$Array = [];
      each(newValue, (t2, name2) => {
        newSteps$Array.push(steps$Array.value[steps$Array.value.map((t$) => normalize(t$.name)).indexOf(normalize(name2))]);
      });
      steps$Array.value = newSteps$Array;
    }, {
      flush: "post"
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeFromParent($this.$parent, removeFromParent);
    });
    onMounted(() => {
      nextTick(() => {
        if (current$.value === void 0 || current$.value.index === void 0) {
          first$.value.enable();
          first$.value.select();
        }
        enableUntilCurrent();
        watch(visible$, () => {
          enableUntilLastEnabled();
        }, {
          flush: "post"
        });
      });
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps,
      elements$,
      steps$Array,
      events,
      listeners,
      exists: exists2,
      classes,
      Templates,
      template,
      steps$,
      pending,
      debouncing,
      invalid,
      done,
      busy,
      visible$,
      first$,
      last$,
      current$,
      next$,
      previous$,
      firstInvalid$,
      firstNonDone$,
      lastEnabled$,
      isAtLastStep,
      isAtFirstStep,
      goTo,
      next,
      previous,
      complete,
      step$,
      reset,
      enableAllSteps,
      submit,
      select: select7,
      enableUntil,
      enableUntilCurrent,
      enableUntilLastEnabled,
      on: on2,
      off: off2,
      fire
    };
  }
};
var FormStepsControls = {
  name: "FormStepsControls",
  slots: ["previous", "next", "finish"],
  props: {
    labels: {
      type: Boolean,
      required: false,
      default: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    provide("View", View);
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    };
  }
};
var FormStepsControl = {
  name: "FormStepsControl",
  slots: ["default"],
  props: {
    type: {
      type: [String],
      required: true
    },
    labels: {
      type: [Boolean],
      required: false,
      default: true,
      private: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      type,
      labels
    } = toRefs(props);
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var baseLabel = computed(() => {
      if (!labels.value) {
        return null;
      }
      var stepLabels = current$ && current$.value ? current$.value.labels : (
        /* istanbul ignore next: failsafe only */
        null
      );
      switch (type.value) {
        case "previous":
          return stepLabels && stepLabels.previous ? stepLabels.previous : form$.value.translations.vueform.steps.previous;
        case "next":
          return stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.next;
        case "finish":
          return stepLabels && stepLabels.finish ? stepLabels.finish : stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.finish;
      }
    });
    var {
      isLabelComponent,
      label
    } = base$15(props, context, {
      component$: form$,
      labelDefinition: baseLabel
    });
    var steps$ = computed(() => {
      return form$.value.steps$;
    });
    var current$ = computed(() => {
      return steps$.value ? steps$.value.current$ : (
        /* istanbul ignore next: failsafe only */
        void 0
      );
    });
    var visible = computed(() => {
      var buttons = current$ && current$.value ? current$.value.buttons : (
        /* istanbul ignore next: failsafe only */
        null
      );
      switch (type.value) {
        case "previous":
          return !buttons ? true : buttons.previous !== false;
        case "next":
          return steps$.value && !steps$.value.isAtLastStep && (!buttons || buttons.next !== false);
        case "finish":
          return steps$.value && steps$.value.isAtLastStep && (!buttons || buttons.finish !== false);
      }
    });
    var isDisabled = computed(() => {
      switch (type.value) {
        case "previous":
          return steps$.value && steps$.value.isAtFirstStep;
        case "next":
          return current$.value !== void 0 && current$.value.index !== void 0 && // only disable next because of invalidity
          // if element validations are triggered on
          // change, otherwise it might occur that the
          // step has invalid fields, which values have
          // changed to valid, but still marked as invalid
          (current$.value.invalid && form$.value.shouldValidateOnChange || current$.value.busy || form$.value.isLoading);
        case "finish":
          return steps$.value.invalid && form$.value.shouldValidateOnChange || steps$.value.busy || form$.value.submitting || form$.value.isDisabled || form$.value.isLoading;
      }
    });
    var isLoading = computed(() => {
      return type.value === "previous" ? false : form$.value.isLoading || form$.value.submitting;
    });
    var previous = () => {
      steps$.value.previous();
    };
    var next = function() {
      var _ref = _asyncToGenerator(function* () {
        if (form$.value.shouldValidateOnStep) {
          yield current$.value.validate();
        }
        if (current$.value.invalid) {
          form$.value.scrollToFirstInvalid();
          return;
        }
        current$.value.complete();
        steps$.value.next();
      });
      return function next2() {
        return _ref.apply(this, arguments);
      };
    }();
    var finish = function() {
      var _ref2 = _asyncToGenerator(function* () {
        steps$.value.fire("finish");
        steps$.value.complete();
        steps$.value.submit();
      });
      return function finish2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var handleClick = (e2) => {
      switch (type.value) {
        case "previous":
          previous();
          break;
        case "next":
          next();
          if (e2.key === "Enter" || e2.key === " ") {
            nextTick(() => {
              nextTick(() => {
                var _current$$value$child;
                var firstEl$ = current$ === null || current$ === void 0 || (_current$$value$child = current$.value.children$) === null || _current$$value$child === void 0 ? void 0 : _current$$value$child.find((el$2) => {
                  var _current$$value$eleme;
                  return el$2.name === (current$ === null || current$ === void 0 || (_current$$value$eleme = current$.value.elements) === null || _current$$value$eleme === void 0 ? void 0 : _current$$value$eleme[0]);
                });
                if (!firstEl$) {
                  return;
                }
                firstEl$.focus();
              });
            });
          }
          break;
        case "finish":
          finish();
          break;
      }
    };
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps$,
      classes,
      Templates,
      template,
      visible,
      isDisabled,
      isLoading,
      current$,
      label,
      isLabelComponent,
      previous,
      next,
      finish,
      handleClick
    };
  }
};
var FormStep = {
  name: "FormStep",
  emits: ["activate", "inactivate", "enable", "disable", "complete"],
  slots: ["default"],
  props: {
    name: {
      type: [String, Number],
      required: true
    },
    label: {
      type: [String, Object, Function],
      required: false,
      default: null
    },
    labels: {
      type: [Object],
      required: false,
      default: () => ({})
    },
    buttons: {
      type: [Object],
      required: false,
      default: () => ({})
    },
    elements: {
      type: [Array],
      required: false,
      default: () => []
    },
    conditions: {
      type: [Array],
      required: false,
      default: () => []
    },
    addClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    onActivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onInactivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onDisable: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onEnable: {
      type: [Function],
      required: false,
      default: null,
      private: true
    }
  },
  setup(props, context) {
    var {
      name: name2,
      label,
      elements
    } = toRefs(props);
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var {
      available,
      conditionList,
      updateConditions
    } = base$16(props, context, {
      form$
    });
    var {
      isLabelComponent,
      label: stepLabel_
    } = base$15(props, context, {
      component$: form$,
      labelDefinition: label
    });
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1e(props, context, {
      form$
    }, {
      events: context.emits
    });
    var stepLabel = ref(stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value);
    var active = ref(false);
    var isDisabled = ref(true);
    var completed2 = ref(false);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var steps$ = computed(() => {
      return form$.value.steps$ || /* istanbul ignore next: failsafe only, step can not exist by itself */
      {};
    });
    var baseLabel = computed(() => {
      return label.value;
    });
    var index2 = computed(() => {
      var _steps$$value;
      return Object.keys((steps$ === null || steps$ === void 0 || (_steps$$value = steps$.value) === null || _steps$$value === void 0 ? void 0 : _steps$$value.steps$) || /* istanbul ignore next: failsafe only, step can not exist by itself */
      {}).indexOf(name2.value);
    });
    var isFirst = computed(() => {
      return index2.value === 0;
    });
    var isLast = computed(() => {
      return steps$.value.last$.name === name2.value;
    });
    var children$ = computed(() => {
      return filter_1(elements$.value, (element$, key) => {
        return elements.value.indexOf(key) !== -1;
      });
    });
    var visible = computed(() => {
      return available.value;
    });
    var invalid = computed(() => {
      return some_1(children$.value, {
        available: true,
        invalid: true
      });
    });
    var pending = computed(() => {
      return some_1(children$.value, {
        available: true,
        pending: true
      });
    });
    var debouncing = computed(() => {
      return some_1(children$.value, {
        available: true,
        debouncing: true
      });
    });
    var validated = computed(() => {
      return !some_1(children$.value, {
        available: true,
        validated: false
      });
    });
    var busy = computed(() => {
      return pending.value || debouncing.value;
    });
    var done = computed(() => {
      return completed2.value && validated.value && !invalid.value && !pending.value;
    });
    var step$ = computed(() => {
      var _form$$value$steps$;
      return (_form$$value$steps$ = form$.value.steps$) === null || _form$$value$steps$ === void 0 ? void 0 : _form$$value$steps$.steps$[name2.value];
    });
    var validate = function() {
      var _ref = _asyncToGenerator(function* () {
        if (validated.value && !invalid.value && form$.value.shouldValidateOnChange) {
          return;
        }
        yield asyncForEach(children$.value, function() {
          var _ref2 = _asyncToGenerator(function* (element$) {
            if ((!element$.validated || element$.invalid || !form$.value.shouldValidateOnChange) && element$.available && !element$.isStatic) {
              yield element$.validate();
            }
          });
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }());
      });
      return function validate2() {
        return _ref.apply(this, arguments);
      };
    }();
    var activate = () => {
      if (active.value) {
        return;
      }
      active.value = true;
      fire("activate");
    };
    var deactivate = () => {
      if (!active.value) {
        return;
      }
      active.value = false;
      fire("inactivate");
    };
    var enable = () => {
      if (!isDisabled.value) {
        return;
      }
      isDisabled.value = false;
      fire("enable");
    };
    var disable = () => {
      if (isDisabled.value) {
        return;
      }
      isDisabled.value = true;
      fire("disable");
    };
    var complete = () => {
      if (completed2.value) {
        return;
      }
      completed2.value = true;
      fire("complete");
    };
    var uncomplete = () => {
      completed2.value = false;
    };
    var select7 = () => {
      var _steps$$value2, _steps$$value3;
      if (isDisabled.value || !((_steps$$value2 = steps$.value) !== null && _steps$$value2 !== void 0 && _steps$$value2.select)) {
        return;
      }
      (_steps$$value3 = steps$.value) === null || _steps$$value3 === void 0 || _steps$$value3.select(step$.value);
      each(children$.value, (element$) => {
        element$.activate();
      });
      activate();
    };
    var addChildConditions = () => {
      if (conditionList.value.length == 0) {
        return;
      }
      Object.values(children$.value).forEach((element$) => {
        element$.addConditions("step", conditionList.value);
      });
    };
    var removeChildConditions = () => {
      Object.values(children$.value).forEach((element$) => {
        element$.removeConditions("step");
      });
    };
    var resetChildConditions = () => {
      removeChildConditions();
      addChildConditions();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.steps$Array) {
        $parent.steps$Array.push($this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.steps$Array) {
        $parent.steps$Array.splice($parent.steps$Array.map((t$) => normalize(t$.name)).indexOf(normalize(name2.value)), 1);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    watch(visible, (val) => {
      if (val && index2.value < form$.value.steps$.current$.index) {
        enable();
      }
    });
    watch(children$, () => {
      if (!active.value) {
        return;
      }
      each(children$.value, (element$) => {
        element$.activate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(stepLabel_, () => {
      stepLabel.value = stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value;
    });
    watch(conditionList, (n2, o2) => {
      if (!(n2 !== null && n2 !== void 0 && n2.length)) {
        removeChildConditions();
      } else {
        addChildConditions();
      }
    });
    onMounted(() => {
      nextTick(() => {
        addChildConditions();
      });
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeChildConditions();
      removeFromParent($this.$parent, removeFromParent);
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps$,
      elements$,
      active,
      isDisabled,
      isFirst,
      isLast,
      completed: completed2,
      events,
      listeners,
      children$,
      visible,
      invalid,
      pending,
      classes,
      Templates,
      template,
      available,
      baseLabel,
      debouncing,
      validated,
      busy,
      done,
      step$,
      isLabelComponent,
      stepLabel,
      index: index2,
      conditionList,
      validate,
      activate,
      deactivate,
      enable,
      disable,
      complete,
      uncomplete,
      select: select7,
      on: on2,
      off: off2,
      fire,
      addChildConditions,
      removeChildConditions,
      resetChildConditions,
      updateConditions
    };
  }
};
var base$14 = function base11(props, context, dependencies2) {
  var component = (element2) => {
    return "".concat(upperFirst_1(camelCase_1(element2.type)), "Element");
  };
  return {
    component
  };
};
var FormElements = {
  name: "FormElements",
  slots: ["default"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$17(props, context);
    var {
      component
    } = base$14();
    var schema = computed(() => {
      return form$.value.options.schema;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      schema,
      component
    };
  }
};
var base$13 = function base12(props, context, dependencies2) {
  var el$2 = inject("el$");
  return {
    el$: el$2
  };
};
var base$12 = function base13(props, context, dependencies2) {
  var componentName = context.name;
  var {
    form$
  } = base$1b();
  var {
    el$: el$2
  } = base$13();
  var {
    theme
  } = base$1a();
  var {
    Size
  } = base$19();
  var {
    View
  } = base$18(props, context);
  var component$ = computed(() => {
    return getCurrentInstance().proxy;
  });
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options, el$2.value]
    });
  });
  var classes = computed(() => {
    return classesInstance.value.classes;
  });
  var Templates = computed(() => {
    return el$2.value.Templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    el$: el$2,
    form$,
    theme,
    Size,
    View,
    classesInstance,
    classes,
    Templates,
    template
  };
};
var ElementLayout = {
  name: "ElementLayout",
  slots: ["field", "label", "info", "description", "before", "between", "after"],
  props: {
    multiple: {
      type: [Boolean],
      required: false,
      default: false
    },
    view: {
      type: [String],
      required: false,
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      el$: el$2,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var visible = computed(() => {
      return el$2.value.visible;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      Templates,
      template,
      classes,
      visible
    };
  }
};
var ElementLayoutInline = {
  name: "ElementLayoutInline",
  slots: ["field", "label", "info", "description", "before", "between", "after"],
  setup(props, context) {
    var {
      form$,
      el$: el$2,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var visible = computed(() => {
      return el$2.value.visible;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      Templates,
      template,
      classes,
      visible
      // hasLabel,
    };
  }
};
var ElementLoader = {
  name: "ElementLoader",
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    };
  }
};
var ElementLabelFloating = {
  name: "ElementLabelFloating",
  props: {
    visible: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var config$ = inject("config$");
    var floating = computed(() => {
      var _form$$value$options$;
      var floating2 = localize(el$2.value.floating || /* istanbul ignore next: tested, but not covered */
      (form$.value.options.floatPlaceholders ? el$2.value.placeholder : null), config$.value, form$.value);
      if (el$2.value.isRequired && ((_form$$value$options$ = form$.value.options.showRequired) === null || _form$$value$options$ === void 0 ? void 0 : _form$$value$options$.indexOf("floating")) !== -1) {
        floating2 += "*";
      }
      return floating2;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      floating
    };
  }
};
var ElementLabel = {
  name: "ElementLabel",
  slots: ["default", "info"],
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var {
      label,
      isLabelComponent
    } = base$15(props, context, {
      labelDefinition: computed(() => {
        return el$2.value.label;
      }),
      component$: el$2
    });
    var name2 = computed(() => {
      return el$2.value.fieldId;
    });
    var id = computed(() => {
      return el$2.value.labelId;
    });
    var hasLabel = computed(() => {
      return el$2.value.hasLabel;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.label || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      label,
      isLabelComponent,
      name: name2,
      id,
      hasLabel,
      isSlot
    };
  }
};
function isInViewport(element2) {
  var rect = element2.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}
var ElementInfo = {
  name: "ElementInfo",
  slots: ["default"],
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var config$ = inject("config$");
    var position = ref(el$2.value.infoPosition);
    var info = computed(() => {
      return localize(el$2.value.info, config$.value, form$.value);
    });
    var id = computed(() => {
      return el$2.value.infoId;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.info || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.info || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.info);
    });
    var handleMouseOver = function() {
      var _ref = _asyncToGenerator(function* (e2) {
        if (position.value !== el$2.value.infoPosition) {
          return;
        }
        yield nextTick();
        var wrapper = e2.target.querySelector("div");
        if (!wrapper) {
          return;
        }
        if (!isInViewport(wrapper)) {
          position.value = "right";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "top";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "left";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "bottom";
        }
      });
      return function handleMouseOver2(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      info,
      isSlot,
      position,
      id,
      handleMouseOver
    };
  }
};
var ElementDescription = {
  name: "ElementDescription",
  slots: ["default"],
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var config$ = inject("config$");
    var description2 = computed(() => {
      return localize(el$2.value.description, config$.value, form$.value);
    });
    var id = computed(() => {
      return el$2.value.descriptionId;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.description || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.description || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.description);
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      description: description2,
      isSlot,
      id
    };
  }
};
var ElementError = {
  name: "ElementError",
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var error = computed(() => {
      return el$2.value.error;
    });
    var id = computed(() => {
      return el$2.value.errorId;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      error,
      id
    };
  }
};
var ElementMessage = {
  name: "ElementMessage",
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var message = computed(() => {
      return el$2.value.messageBag ? el$2.value.messageBag.message : (
        /* istanbul ignore next: messageBag itself will always be defined */
        null
      );
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      message
    };
  }
};
var ElementRequired = {
  name: "ElementRequired",
  slots: ["default"],
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var visible = computed(() => {
      var _form$$value$options$;
      return el$2.value.isRequired && ((_form$$value$options$ = form$.value.options.showRequired) === null || _form$$value$options$ === void 0 ? void 0 : _form$$value$options$.indexOf("label")) !== -1;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.required || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.required || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.required);
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      visible,
      isSlot
    };
  }
};
var ElementText = {
  name: "ElementText",
  slots: ["default"],
  props: {
    type: {
      type: String,
      required: true
    }
  },
  setup(props, context) {
    var {
      type
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var config$ = inject("config$");
    var content = computed(() => {
      return localize(el$2.value[type.value], config$.value, form$.value);
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots[type.value] || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots[type.value] || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo[type.value]);
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      content,
      isSlot
    };
  }
};
var DragAndDrop = {
  name: "DragAndDrop",
  emits: ["click", "drop"],
  props: {
    title: {
      type: String,
      required: true
    },
    description: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(props, context) {
    var {
      disabled
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var dragging = ref(false);
    var area = ref(null);
    var handleClick = () => {
      context.emit("click");
    };
    onMounted(() => {
      each(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"], (event) => {
        area.value.addEventListener(event, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
      });
      area.value.addEventListener("drop", (e2) => {
        if (disabled.value) {
          return;
        }
        context.emit("drop", e2);
        dragging.value = false;
      });
      area.value.addEventListener("dragover", (e2) => {
        if (disabled.value) {
          return;
        }
        if (dragging.value !== true) {
          dragging.value = true;
        }
      });
      area.value.addEventListener("dragleave", (e2) => {
        if (disabled.value) {
          return;
        }
        dragging.value = false;
      });
      area.value.addEventListener("dragend", (e2) => {
        if (disabled.value) {
          return;
        }
        dragging.value = false;
      });
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      dragging,
      area,
      handleClick
    };
  }
};
var ElementAddon = {
  name: "ElementAddon",
  slots: ["default"],
  props: {
    type: {
      required: true,
      type: String
    }
  },
  setup(props, context) {
    var {
      type
    } = toRefs(props);
    var {
      form$,
      el$: el$2,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var config$ = inject("config$");
    var baseAddon = computed(() => {
      return el$2.value.addons[type.value];
    });
    var addon = computed(() => {
      var addon2 = isAddonFunction.value ? baseAddon.value(el$2.value) : baseAddon.value || /* istanbul ignore next: failsafe */
      null;
      if (!isAddonComponent.value) {
        addon2 = localize(addon2, config$.value, form$.value);
      }
      return addon2;
    });
    var isAddonFunction = computed(() => {
      return typeof baseAddon.value === "function" && (!baseAddon.value.prototype || !baseAddon.value.prototype.constructor || baseAddon.value.prototype.constructor && baseAddon.value.prototype.constructor.name !== "VueComponent");
    });
    var isAddonComponent = computed(() => {
      return isVueComponent(baseAddon.value);
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$2.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots["addon-".concat(type.value)] || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-".concat(type.value)] || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-".concat(type.value)] || /* istanbul ignore next */
      el$2.value.slots["addon-".concat(type.value)]);
    });
    return {
      el$: el$2,
      form$,
      theme,
      Size,
      View,
      classesInstance,
      Templates,
      template,
      classes,
      addon,
      isAddonComponent,
      isSlot
    };
  }
};
var ElementAddonOptions = {
  name: "ElementAddonOptions",
  emits: ["select", "open", "close"],
  props: {
    options: {
      type: [Array],
      required: false,
      default: () => []
    },
    placeholder: {
      type: [String, Number, Object],
      required: false,
      default: ""
    },
    relaxed: {
      type: [Boolean],
      required: false,
      default: false
    },
    position: {
      type: [String],
      required: false,
      default: "over"
    },
    aria: {
      type: [Object],
      required: false,
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      options,
      position
    } = toRefs(props);
    var {
      form$,
      el$: el$2,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1e(props, context, {
      form$
    }, {
      events: context.emits
    });
    var isOpen = ref(false);
    var selector = ref(null);
    var dropdown = ref(null);
    var left = ref(void 0);
    var right = ref(void 0);
    var top = ref(void 0);
    var bottom = ref(void 0);
    var search = ref("");
    var searchTimeout = ref(null);
    var resizeTimeout = ref(null);
    var hoverDisabled = ref(false);
    var fullHeight = ref(false);
    var selected = ref({});
    var pointed = ref({});
    var focused = computed(() => {
      if (!search.value) {
        return {};
      }
      return options.value.find((o2) => o2.label.toLowerCase().startsWith(search.value.toString().toLowerCase()));
    });
    var style = computed(() => {
      return {
        left: left.value !== void 0 ? "".concat(left.value, "px") : void 0,
        right: right.value !== void 0 ? "".concat(right.value, "px") : void 0,
        top: top.value !== void 0 ? "".concat(top.value, "px") : void 0,
        bottom: bottom.value !== void 0 ? "".concat(bottom.value, "px") : "auto"
      };
    });
    var close = () => {
      top.value = void 0;
      bottom.value = void 0;
      fullHeight.value = false;
      isOpen.value = false;
      document.removeEventListener("click", handleClickOutside);
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("resize", handleResize);
      window.removeEventListener("scroll", handleScroll);
      search.value = "";
      context.emit("close");
    };
    var open = function() {
      var _ref = _asyncToGenerator(function* () {
        isOpen.value = true;
        yield nextTick();
        var selectorRect = selector.value.getBoundingClientRect();
        if (selector.value.closest('[dir="rtl"]')) {
          left.value = void 0;
          right.value = window.innerWidth - (selectorRect.left + selectorRect.width);
        } else {
          right.value = void 0;
          left.value = selectorRect.left;
        }
        resizeDropdown();
        scrollToSelected();
        setTimeout(() => {
          document.addEventListener("click", handleClickOutside);
          document.addEventListener("keydown", handleKeydown);
          window.addEventListener("resize", handleResize);
          window.addEventListener("scroll", handleScroll);
        }, 0);
        context.emit("open");
      });
      return function open2() {
        return _ref.apply(this, arguments);
      };
    }();
    var scrollToOption = (option2) => {
      if (fullHeight.value) {
        var selectorRect = selector.value.getBoundingClientRect();
        var optionRect = option2.getBoundingClientRect();
        var targetCenterY = selectorRect.top + selectorRect.height / 2;
        var optionCenterY = optionRect.top + optionRect.height / 2;
        var centerDiff = targetCenterY - optionCenterY;
        var newScrollTop = dropdown.value.scrollTop - centerDiff;
        dropdown.value.scrollTop = newScrollTop;
      } else {
        var _optionRect = option2.getBoundingClientRect();
        var dropdownRect = dropdown.value.getBoundingClientRect();
        var optionTopWithinDiv = _optionRect.top - dropdownRect.top;
        dropdown.value.scrollTop = optionTopWithinDiv + dropdown.value.scrollTop;
      }
    };
    var scrollToSelected = function() {
      var _ref2 = _asyncToGenerator(function* () {
        yield nextTick();
        var option2 = document.querySelector('[data-dropdown-for="'.concat(el$2.value.fieldId, '"] [data-selected="true"]'));
        if (!option2) {
          return;
        }
        scrollToOption(option2);
      });
      return function scrollToSelected2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var resizeDropdown = () => {
      if (dropdown.value.getBoundingClientRect().height >= window.innerHeight - 32) {
        fullHeight.value = true;
        top.value = 16;
        bottom.value = 16;
      } else {
        fullHeight.value = false;
        var selectorRect = selector.value.getBoundingClientRect();
        var newTop = selectorRect.top;
        if (position.value === "bottom") {
          newTop += selectorRect.height;
        } else if (position.value === "top") ;
        top.value = newTop;
        if (dropdown.value.getBoundingClientRect().height > window.innerHeight - selector.value.getBoundingClientRect().top - 16) {
          bottom.value = 16;
        } else {
          bottom.value = void 0;
        }
      }
    };
    var selectOption = (option2) => {
      selected.value = option2;
      fire("select", option2);
    };
    var reset = () => {
      selected.value = {};
      fire("select", {});
    };
    var handleOptionPoint = (option2) => {
      if (hoverDisabled.value) {
        return;
      }
      pointed.value = option2;
    };
    var handleOptionClick = (option2) => {
      selectOption(option2);
      close();
      el$2.value.input.focus();
    };
    var handleSelectorClick = (e2) => {
      open();
    };
    var handleSelectorKeydown = function() {
      var _ref3 = _asyncToGenerator(function* (e2) {
        if (isOpen.value) {
          return;
        }
        if (["Enter", " ", "ArrowDown", "ArrowUp"].indexOf(e2.key) !== -1) {
          e2.preventDefault();
          open();
          yield nextTick();
          var index2 = selected.value.index !== void 0 ? selected.value.index : pointed.value.index || 0;
          var option2 = document.querySelector('[data-dropdown-for="'.concat(el$2.value.fieldId, '"] [data-index="').concat(index2, '"]'));
          pointed.value = options.value.find((c) => c.index === index2);
          option2.focus();
        }
      });
      return function handleSelectorKeydown2(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
    var handleClickOutside = (e2) => {
      var _dropdown$value;
      if (!((_dropdown$value = dropdown.value) !== null && _dropdown$value !== void 0 && _dropdown$value.contains(e2.target))) {
        close();
      }
    };
    var handleKeydown = (e2) => {
      var _pointed$value;
      if (e2.key === "Escape") {
        close();
        selector.value.focus();
        return;
      }
      if (["Enter", " "].indexOf(e2.key) !== -1 && ((_pointed$value = pointed.value) === null || _pointed$value === void 0 ? void 0 : _pointed$value.index) !== void 0) {
        e2.preventDefault();
        selectOption(pointed.value);
        close();
        el$2.value.input.focus();
        return;
      }
      if (e2.key === "Tab") {
        e2.preventDefault();
        close();
        el$2.value.input.focus();
        return;
      }
      if (e2.key === "ArrowDown") {
        e2.preventDefault();
        var index2 = pointed.value.index === void 0 ? -1 : pointed.value.index;
        var nextIndex = index2 + 1;
        if (options.value.length < nextIndex + 1) {
          nextIndex = 0;
        }
        hoverDisabled.value = true;
        pointed.value = options.value.find((c) => c.index === nextIndex);
        var option2 = document.querySelector('[data-dropdown-for="'.concat(el$2.value.fieldId, '"] [data-index="').concat(nextIndex, '"]'));
        scrollToOption(option2);
        option2.focus();
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 2);
        return;
      }
      if (e2.key === "ArrowUp") {
        e2.preventDefault();
        var _index = pointed.value.index || 0;
        var prevIndex = _index - 1;
        if (prevIndex < 0) {
          prevIndex = options.value.length - 1;
        }
        hoverDisabled.value = true;
        pointed.value = options.value.find((c) => c.index === prevIndex);
        var _option = document.querySelector('[data-dropdown-for="'.concat(el$2.value.fieldId, '"] [data-index="').concat(prevIndex, '"]'));
        scrollToOption(_option);
        _option.focus();
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 0);
        return;
      }
      if (e2.key === "Backspace" && search.value.length) {
        search.value = search.value.slice(0, -1);
        return;
      }
      if (e2.key.length === 1 && !e2.ctrlKey && !e2.metaKey && !e2.altKey) {
        search.value += e2.key;
        hoverDisabled.value = true;
        if (searchTimeout.value) {
          clearTimeout(searchTimeout.value);
        }
        searchTimeout.value = setTimeout(() => {
          search.value = "";
        }, 1e3);
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 0);
      }
    };
    var handleResize = () => {
      close();
    };
    var handleScroll = () => {
      if (resizeTimeout.value) {
        clearTimeout(resizeTimeout.value);
      }
      resizeTimeout.value = setTimeout(() => {
        resizeDropdown();
      }, 50);
    };
    onBeforeUnmount(() => {
      close();
    });
    watch(focused, (option2) => {
      if (!option2 || option2.index === void 0) {
        return;
      }
      var optionEl = document.querySelector('[data-dropdown-for="'.concat(el$2.value.fieldId, '"] [data-index="').concat(option2.index, '"]'));
      scrollToOption(optionEl);
      pointed.value = option2;
      optionEl.focus();
    });
    return {
      form$,
      el$: el$2,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      events,
      listeners,
      on: on2,
      off: off2,
      fire,
      isOpen,
      selector,
      dropdown,
      left,
      right,
      top,
      bottom,
      style,
      search,
      searchTimeout,
      hoverDisabled,
      selected,
      pointed,
      focused,
      close,
      scrollToOption,
      scrollToSelected,
      selectOption,
      reset,
      handleOptionPoint,
      handleOptionClick,
      handleSelectorClick,
      handleSelectorKeydown,
      handleClickOutside,
      handleKeydown,
      handleResize
    };
  }
};
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults$1 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date6 = new Date(givenDate.getTime());
    date6.setHours(0, 0, 0, 0);
    date6.setDate(date6.getDate() + 3 - (date6.getDay() + 6) % 7);
    var week1 = new Date(date6.getFullYear(), 0, 4);
    return 1 + Math.round(((date6.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce$1(fn, wait) {
  var t2;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t2);
    t2 = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};
function toggleClass$1(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e2 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e2.className = className;
  if (content !== void 0)
    e2.textContent = content;
  return e2;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition2) {
  if (condition2(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition2);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date6 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date6.setDate(date6.getDate() - date6.getDay() + locale.firstDayOfWeek);
    return date6;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date6) {
    return date6.toISOString();
  },
  D: function(date6, locale, options) {
    return locale.weekdays.shorthand[formats.w(date6, locale, options)];
  },
  F: function(date6, locale, options) {
    return monthToStr(formats.n(date6, locale, options) - 1, false, locale);
  },
  G: function(date6, locale, options) {
    return pad(formats.h(date6, locale, options));
  },
  H: function(date6) {
    return pad(date6.getHours());
  },
  J: function(date6, locale) {
    return locale.ordinal !== void 0 ? date6.getDate() + locale.ordinal(date6.getDate()) : date6.getDate();
  },
  K: function(date6, locale) {
    return locale.amPM[int(date6.getHours() > 11)];
  },
  M: function(date6, locale) {
    return monthToStr(date6.getMonth(), true, locale);
  },
  S: function(date6) {
    return pad(date6.getSeconds());
  },
  U: function(date6) {
    return date6.getTime() / 1e3;
  },
  W: function(date6, _, options) {
    return options.getWeek(date6);
  },
  Y: function(date6) {
    return pad(date6.getFullYear(), 4);
  },
  d: function(date6) {
    return pad(date6.getDate());
  },
  h: function(date6) {
    return date6.getHours() % 12 ? date6.getHours() % 12 : 12;
  },
  i: function(date6) {
    return pad(date6.getMinutes());
  },
  j: function(date6) {
    return date6.getDate();
  },
  l: function(date6, locale) {
    return locale.weekdays.longhand[date6.getDay()];
  },
  m: function(date6) {
    return pad(date6.getMonth() + 1);
  },
  n: function(date6) {
    return date6.getMonth() + 1;
  },
  s: function(date6) {
    return date6.getSeconds();
  },
  u: function(date6) {
    return date6.getTime();
  },
  w: function(date6) {
    return date6.getDay();
  },
  y: function(date6) {
    return String(date6.getFullYear()).substring(2);
  }
};
var createDateFormatter = function(_a) {
  var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config2.formatDate !== void 0 && !isMobile) {
      return config2.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config2) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date6, givenFormat, timeless, customLocale) {
    if (date6 !== 0 && !date6)
      return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date6;
    if (date6 instanceof Date)
      parsedDate = new Date(date6.getTime());
    else if (typeof date6 !== "string" && date6.toFixed !== void 0)
      parsedDate = new Date(date6);
    else if (typeof date6 === "string") {
      var format = givenFormat || (config2 || defaults$1).dateFormat;
      var datestr = String(date6).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config2 && config2.parseDate) {
        parsedDate = config2.parseDate(date6, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date6);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date6);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date22, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date22.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date22.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config2) {
  var hours = config2.defaultHour;
  var minutes = config2.defaultMinute;
  var seconds = config2.defaultSeconds;
  if (config2.minDate !== void 0) {
    var minHour = config2.minDate.getHours();
    var minMinutes = config2.minDate.getMinutes();
    var minSeconds = config2.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config2.minDate.getSeconds();
  }
  if (config2.maxDate !== void 0) {
    var maxHr = config2.maxDate.getHours();
    var maxMinutes = config2.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config2.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element2, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults$1), flatpickr.defaultConfig),
    l10n: english
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy2;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set2;
  self2.setDate = setDate;
  self2.toggle = toggle3;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element2;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config2 = self2.config;
    if (config2.weekNumbers === false && config2.showMonths === 1) {
      return;
    } else if (config2.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e2) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults2 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e2 !== void 0 && e2.type !== "blur") {
      timeWrapper(e2);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date6 = dateObj || self2.latestSelectedDateObj;
    if (date6 && date6 instanceof Date) {
      setHours(date6.getHours(), date6.getMinutes(), date6.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element3, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element3, ev, handler, options);
      });
    if (element3 instanceof Array)
      return element3.forEach(function(el) {
        return bind(el, event, handler, options);
      });
    element3.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element3.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce$1(onResize, 50);
    self2._debouncedChange = debounce$1(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", function(e2) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e2));
      });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e2) {
        return getEventTarget(e2).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e2) {
          updateTime(e2);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e2) {
      e2.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e2);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e2) {
    var eventTarget = getEventTarget(e2);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e2, delta, inputElem) {
    var target = e2 && getEventTarget(e2);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass$1(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass$1(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass$1(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date6, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date6, true), dayElement = createElement("span", className, date6.getDate().toString());
    dayElement.dateObj = date6;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date6, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date6, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date6)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass$1(dayElement, "startRange", self2.selectedDates[0] && compareDates(date6, self2.selectedDates[0], true) === 0);
          toggleClass$1(dayElement, "endRange", self2.selectedDates[1] && compareDates(date6, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date6) && !isDateSelected(date6))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date6) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self2.config.showMonths; i++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e2) {
        var target = getEventTarget(e2);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass$1(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass$1(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i = self2.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy2() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e2) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e2);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date6, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date6, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array4 = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i = 0, d = void 0; i < array4.length; i++) {
      d = array4[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e2) {
    var isInput = e2.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
      self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e2) {
    var eventTarget = getEventTarget(e2);
    var isInput = self2.config.wrap ? element2.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e2.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e2.keyCode) {
        case 13:
          if (isTimeObj) {
            e2.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e2);
          break;
        case 27:
          e2.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e2.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e2.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e2.keyCode === 39 ? 1 : -1;
              if (!e2.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e2.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e2.preventDefault();
          var delta = e2.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e2.ctrlKey) {
              e2.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e2);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e2.shiftKey ? -1 : 1)];
              e2.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
            e2.preventDefault();
            self2._input.focus();
          }
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e2.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e2);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
      if (!isEnabled(new Date(t2), true)) {
        containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
        if (t2 < initialDate && (!minRange || t2 > minRange))
          minRange = t2;
        else if (t2 > initialDate && (!maxRange || t2 < maxRange))
          maxRange = t2;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date6 = dayElem.dateObj;
      var timestamp = date6.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e2, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e2) {
        e2.preventDefault();
        var eventTarget = getEventTarget(e2);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date6) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date6, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element2.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates6) {
        self2.config._enable = parseDateRules(dates6);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates6) {
        self2.config._disable = parseDateRules(dates6);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults$1.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults$1.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self2.config.plugins.length; i++) {
      var pluginConf = self2.config.plugins[i](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element2.querySelector("[data-input]") : element2;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element2.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass$1(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass$1(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass$1(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass$1(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass$1(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass$1(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass$1(self2.calendarContainer, "rightMost", false);
      toggleClass$1(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t2 = findParent(getEventTarget(e2), isSelectable);
    if (t2 === void 0)
      return;
    var target = t2;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set2(option2, value) {
    if (option2 !== null && typeof option2 === "object") {
      Object.assign(self2.config, option2);
      for (var key in option2) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option2] = value;
      if (CALLBACKS[option2] !== void 0)
        CALLBACKS[option2].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option2) > -1)
        self2.config[option2] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates6 = [];
    if (inputDate instanceof Array)
      dates6 = inputDate.map(function(d) {
        return self2.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates6 = [self2.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates6 = [self2.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates6 = inputDate.split(self2.config.conjunction).map(function(date6) {
            return self2.parseDate(date6, format);
          });
          break;
        case "range":
          dates6 = inputDate.split(self2.l10n.rangeSeparator).map(function(date6) {
            return self2.parseDate(date6, format);
          });
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates6 : dates6.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date6, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self2.config.dateFormat;
    }
    if (date6 !== 0 && !date6 || date6 instanceof Array && date6.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date6, format);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind(self2.mobileInput, "change", function(e2) {
      self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle3(e2) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e2);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name2) {
    var e2 = document.createEvent("Event");
    e2.initEvent(name2, true, true);
    return e2;
  }
  function isDateSelected(date6) {
    for (var i = 0; i < self2.selectedDates.length; i++) {
      var selectedDate = self2.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date6) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date6) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date6, self2.selectedDates[0]) >= 0 && compareDates(date6, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e2) {
    var eventTarget = getEventTarget(e2);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e2) {
    e2.preventDefault();
    var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min3 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min3) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max2) {
        newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min3;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config2) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config2 || {});
      instances.push(node._flatpickr);
    } catch (e2) {
      console.error(e2);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
  HTMLElement.prototype.flatpickr = function(config2) {
    return _flatpickr([this], config2);
  };
}
var flatpickr = function(selector, config2) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config2);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config2);
  } else {
    return _flatpickr(selector, config2);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, english),
  default: __assign({}, english)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config2) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var DatepickerWrapper = {
  name: "DatepickerWrapper",
  emits: ["change"],
  props: {
    value: {
      required: true
    },
    options: {
      type: [Object],
      required: true
    },
    id: {
      type: [Number, String],
      required: true
    },
    placeholder: {
      type: [Number, String],
      required: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      id,
      options,
      value
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var moment = form$.value.$vueform.services.moment;
    var $this = getCurrentInstance().proxy;
    var datepicker$ = ref(null);
    var input = ref(null);
    var available = computed(() => {
      return el$2.value.available;
    });
    var locale = computed(() => {
      var _$this$$vueform$i18n$, _$this$$vueform$i18n$2;
      return ((_$this$$vueform$i18n$ = $this.$vueform.i18n.locales[form$.value.locale$]) === null || _$this$$vueform$i18n$ === void 0 || (_$this$$vueform$i18n$ = _$this$$vueform$i18n$.vueform) === null || _$this$$vueform$i18n$ === void 0 ? void 0 : _$this$$vueform$i18n$.datepicker) || ((_$this$$vueform$i18n$2 = $this.$vueform.i18n.locales[$this.$vueform.i18n.fallbackLocale]) === null || _$this$$vueform$i18n$2 === void 0 || (_$this$$vueform$i18n$2 = _$this$$vueform$i18n$2.vueform) === null || _$this$$vueform$i18n$2 === void 0 ? void 0 : _$this$$vueform$i18n$2.datepicker) || {};
    });
    var mode = computed(() => {
      return options.value.mode || "single";
    });
    var config2 = computed(() => {
      var config3 = {};
      each(options.value, (val, option2) => {
        if (val !== null && val !== void 0) {
          config3[option2] = val;
        }
      });
      config3.static = true;
      return config3;
    });
    var update = (val) => {
      context.emit("change", mode.value == "single" ? val[0] || null : val);
    };
    var setDatepickerId = () => {
      datepicker$.value.input.parentElement.id = "datepicker-" + id.value;
    };
    var init = function() {
      var _ref = _asyncToGenerator(function* () {
        if (!input.value) {
          yield nextTick();
        }
        datepicker$.value = flatpickr(input.value, Object.assign({}, config2.value, {
          onChange: (val) => {
            update(val);
          },
          onClose: (val) => {
            val = mode.value == "range" && val.length < 2 ? [] : val;
            update(val);
          },
          // creating a date object from a string date provided in displayFormat (to value)
          parseDate: (dateStr, format) => {
            return moment(dateStr, format, true).toDate();
          },
          // creating a date string according to displayFormat (to display)
          formatDate: (date6, format) => {
            return moment(date6).format(format);
          },
          ariaDateFormat: "MMMM D, YYYY",
          disableMobile: true,
          locale: locale.value
        }));
        if (datepicker$.value.calendarContainer) {
          classes.value.calendarContainer.forEach((c) => {
            datepicker$.value.calendarContainer.classList.add(c);
          });
        }
        setDatepickerId();
        if (value.value !== null) {
          datepicker$.value.setDate(value.value, false);
        }
      });
      return function init2() {
        return _ref.apply(this, arguments);
      };
    }();
    watch(value, (n2, o2) => {
      var _datepicker$$value;
      (_datepicker$$value = datepicker$.value) === null || _datepicker$$value === void 0 || _datepicker$$value.setDate(n2, false);
    });
    watch(id, (n2, o2) => {
      setDatepickerId();
    }, {
      immediate: false
    });
    watch(options, (n2, o2) => {
      if (isEqual_1(n2, o2)) {
        return;
      }
      init();
    }, {
      deep: true
    });
    watch([locale, available], (n2, o2) => {
      init();
    }, {
      deep: true
    });
    onMounted(() => {
      init();
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      datepicker$,
      input,
      config: config2,
      mode,
      locale,
      update,
      init
    };
  }
};
var EditorWrapper = {
  name: "EditorWrapper",
  emits: ["input", "alert", "error", "blur"],
  props: {
    value: {
      required: false,
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Number],
      default: null
    },
    name: {
      required: false,
      type: [String, Number],
      default: null
    },
    id: {
      required: false,
      type: [String, Number],
      default: null
    },
    accept: {
      required: false,
      type: Array,
      default: () => []
    },
    acceptMimes: {
      required: false,
      type: Array,
      default: () => []
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null
    },
    method: {
      required: false,
      type: String,
      default: "post"
    },
    disabled: {
      required: false,
      type: Boolean,
      default: false
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      disabled,
      acceptMimes,
      accept,
      endpoint,
      method,
      attrs,
      placeholder,
      id
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var trix$ = ref(null);
    var editor$ = computed(() => {
      return trix$.value.$el || trix$.value;
    });
    var resolvedEndpoint = computed(() => {
      if (endpoint.value) {
        return typeof endpoint.value === "function" ? endpoint.value : form$.value.$vueform.config.endpoints[endpoint.value] || endpoint.value;
      }
      return typeof form$.value.$vueform.config.endpoints.attachment === "function" ? form$.value.$vueform.config.endpoints.attachment : form$.value.$vueform.config.endpoints.attachment.url;
    });
    var resolvedMethod = computed(() => {
      if (typeof resolvedEndpoint.value === "function") {
        return null;
      }
      if (endpoint.value && form$.value.$vueform.config.endpoints[endpoint.value]) {
        return form$.value.$vueform.config.endpoints[endpoint.value];
      }
      return method.value || form$.value.$vueform.config.endpoints.attachment.method;
    });
    var options = computed(() => {
      return _objectSpread2$1(_objectSpread2$1({}, attrs.value), {}, {
        placeholder: placeholder.value,
        disabled: disabled.value,
        contentEditable: !disabled.value,
        id: id.value,
        input: "editor-input-".concat(id.value)
      });
    });
    var update = (val) => {
      if (typeof val == "number") {
        val = String(val);
      }
      if (val === null || val === void 0) {
        val = "";
      }
      if (editor$.value.editor) {
        editor$.value.editor.loadHTML(val);
      } else {
        setTimeout(() => {
          var _editor$$value$editor;
          (_editor$$value$editor = editor$.value.editor) === null || _editor$$value$editor === void 0 || _editor$$value$editor.loadHTML(val);
        }, 0);
      }
    };
    var setOption = (key, val) => {
      editor$.value[key] = val;
    };
    var handleChange = () => {
      if (editor$.value.value == value.value || !editor$.value.value && !value.value) {
        return;
      }
      context.emit("input", {
        target: {
          value: editor$.value.value
        }
      });
    };
    var handleFileAccept = (e2) => {
      if (disabled.value) {
        e2.preventDefault();
        return;
      }
      if (!e2.file) {
        e2.preventDefault();
        return;
      }
      if (acceptMimes.value && acceptMimes.value.length && acceptMimes.value.indexOf(e2.file.type) === -1) {
        e2.preventDefault();
        context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedMimesError, {
          mimes: acceptMimes.value.join(", ")
        }));
      }
      var extension = e2.file.name.split(".").pop();
      if (accept.value && accept.value.length && accept.value.indexOf(extension) === -1) {
        e2.preventDefault();
        context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedExtensionsError, {
          extensions: accept.value.join(", ")
        }));
      }
    };
    var handleAttachmentAdd = function() {
      var _ref = _asyncToGenerator(function* (e2) {
        if (!e2.attachment.file) {
          return;
        }
        var data = new FormData();
        data.append("Content-Type", e2.attachment.file.type);
        data.append("file", e2.attachment.file);
        var response;
        try {
          if (typeof resolvedEndpoint.value === "function") {
            response = yield resolvedEndpoint.value(e2.attachment, el$2.value);
          } else {
            response = yield el$2.value.$vueform.services.axios.request({
              url: resolvedEndpoint.value,
              method: resolvedMethod.value,
              [resolvedMethod.value.toLowerCase() === "get" ? "params" : "data"]: data,
              onUploadProgress: (progress) => {
                e2.attachment.setUploadProgress(Math.round(progress.loaded * 100 / progress.total));
              }
            });
            response = response.data;
          }
          e2.attachment.setAttributes({
            url: response.url,
            href: response.href
          });
        } catch (error) {
          context.emit("error", error);
        }
      });
      return function handleAttachmentAdd2(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var handleBlur = () => {
      context.emit("blur");
    };
    watch(disabled, (val) => {
      editor$.value.contentEditable = !val;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      resolvedEndpoint,
      options,
      theme,
      classes,
      Templates,
      template,
      trix$,
      editor$,
      update,
      setOption,
      handleChange,
      handleFileAccept,
      handleAttachmentAdd,
      handleBlur
    };
  }
};
var base$11 = function base14(props, context, dependencies2) {
  var {
    label
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var config$ = inject("config$");
  var hasLabel = computed(() => {
    var _el$$value$$slots, _el$$value$$scopedSlo;
    return !!(form$.value.options.forceLabels || label.value || el$2.value.slots.label || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: vue2 */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
  });
  var isLabelFunction = computed(() => {
    return typeof label.value === "function" && (!label.value.prototype || !label.value.prototype.constructor || label.value.prototype.constructor && label.value.prototype.constructor.name !== "VueComponent");
  });
  var isLabelComponent = computed(() => {
    return isVueComponent(label.value);
  });
  var Label = computed(() => {
    var Label2 = isLabelFunction.value ? label.value(el$2.value) : label.value || null;
    if (!isLabelComponent.value) {
      Label2 = localize(Label2, config$.value, form$.value);
    }
    return Label2;
  });
  return {
    hasLabel,
    Label
  };
};
var base$10 = function base15(props, context, dependencies2) {
  var {
    columns,
    presets
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var theme = dependencies2.theme;
  var hasLabel = dependencies2.hasLabel;
  var Columns2 = ref(cloneDeep_1(columns.value));
  var columnsClassesService = computed(() => {
    var config2 = form$.value.$vueform.config;
    return new form$.value.$vueform.services.columns({
      configPresetColumns: config2.usePresets,
      configColumns: config2.columns,
      formPresetColumns: form$.value.options.presets,
      formColumns: form$.value.options.columns,
      elementPresetColumns: presets.value,
      elementColumns: Columns2.value
    }, hasLabel.value, theme.value.columns, config2.presets);
  });
  var columnsClasses = computed(() => {
    return columnsClassesService.value.classes;
  });
  var cols = computed(() => {
    return columnsClassesService.value.cols;
  });
  var updateColumns = (v) => {
    Columns2.value = cloneDeep_1(v);
  };
  watch(columns, (v) => {
    Columns2.value = cloneDeep_1(v);
  }, {
    immediate: false,
    deep: true
  });
  return {
    cols,
    columnsClassesService,
    columnsClasses,
    updateColumns
  };
};
var base$$ = function base16(props, context, dependencies2) {
  var {
    size: size2,
    view,
    views,
    presets
  } = toRefs(props);
  var componentName = context.name;
  var available = dependencies2.available;
  var active = dependencies2.active;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var hidden = ref(false);
  var visible = computed(() => {
    return available.value && !hidden.value && active.value;
  });
  var Size = computed(() => {
    var Size2;
    if (size2.value) {
      Size2 = size2.value;
    } else {
      each(presets.value, (presetName) => {
        var preset = form$.value.$vueform.config.presets[presetName];
        if (!preset || !preset.size) {
          return;
        }
        Size2 = preset.size;
      });
    }
    if (!Size2) {
      if (parent2.value) {
        Size2 = parent2.value.Size;
      } else {
        Size2 = form$.value.Size;
      }
    }
    return Size2;
  });
  var View = computed(() => {
    if (view.value) {
      return view.value;
    }
    return Views.value[componentName.value];
  });
  var Views = computed(() => {
    var Views2 = form$.value.Views;
    each(presets.value, (presetName) => {
      var preset = form$.value.$vueform.config.presets[presetName];
      if (!preset || !preset.views) {
        return;
      }
      Views2 = Object.assign({}, Views2, preset.views);
    });
    Views2 = Object.assign({}, Views2, views.value);
    return Views2;
  });
  var hide = () => {
    hidden.value = true;
  };
  var show = () => {
    hidden.value = false;
  };
  provide("Size", Size);
  provide("View", View);
  provide("Views", Views);
  return {
    hidden,
    visible,
    Size,
    View,
    Views,
    hide,
    show
  };
};
var captcha$1 = function captcha(props, context, dependencies2) {
  var {
    hidden,
    visible: baseVisible,
    Size,
    View,
    Views,
    hide,
    show
  } = base$$(props, context, dependencies2);
  var {
    shouldVerify
  } = dependencies2;
  var visible = computed(() => {
    return baseVisible.value && shouldVerify.value;
  });
  return {
    hidden,
    visible,
    Size,
    View,
    Views,
    hide,
    show
  };
};
var base$_ = function base17(props, context, dependencies2) {
  var {
    templates,
    presets
  } = toRefs(props);
  var componentName = context.name;
  var theme = dependencies2.theme;
  var View = dependencies2.View;
  var form$ = dependencies2.form$;
  var Templates = computed(() => {
    var presetTemplates = {};
    each(presets ? presets.value : [], (presetName) => {
      var preset = form$.value.$vueform.config.presets[presetName];
      if (!preset || !preset.templates) {
        return;
      }
      presetTemplates = Object.assign({}, presetTemplates, preset.templates);
    });
    return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, theme.value.templates), presetTemplates), templates ? templates.value : {});
  });
  var template = computed(() => {
    return View && View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    Templates,
    template
  };
};
var base$Z = function base18(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  toRefs(props);
  var el$2 = dependencies2.el$;
  var defaultElementSlots = ["label", "info", "required", "description", "before", "between", "after"];
  var defaultFieldSlots = ["checkbox", "radio", "option", "single-label", "multiple-label", "tag", "no-results", "no-options", "after-list", "before-list", "placeholder", "group-label", "caret", "clear", "spinner", "option", "default", "addon-before", "addon-after"];
  var elementSlots = computed(() => {
    var elementSlots2 = {};
    defaultElementSlots.filter((s) => options.slots.indexOf(s) !== -1).forEach((s) => {
      var slot = el$2.value.slots[s] || el$2.value.slots[camelCase_1(s)];
      if (typeof slot === "object") {
        if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
          if (Array.isArray(slot.props)) {
            slot.props.push("el$");
          } else {
            slot.props.el$ = {
              type: Object,
              required: true
            };
          }
        } else if (!slot.props) {
          slot.props = ["el$"];
        }
      }
      elementSlots2[s] = slot;
    });
    return elementSlots2;
  });
  var fieldSlots = computed(() => {
    var fieldSlots2 = {};
    defaultFieldSlots.filter((s) => options.slots.indexOf(s) !== -1).forEach((s) => {
      var slot = el$2.value.slots[s] || el$2.value.slots[camelCase_1(s)];
      if (typeof slot === "object") {
        if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
          if (Array.isArray(slot.props)) {
            slot.props.push("el$");
          } else {
            slot.props.el$ = {
              type: Object,
              required: true
            };
          }
        } else if (!slot.props) {
          slot.props = ["el$"];
        }
      }
      fieldSlots2[s] = slot;
    });
    return fieldSlots2;
  });
  return {
    elementSlots,
    fieldSlots
  };
};
var base$Y = function base19(props, context, dependencies2) {
  var {
    buttonLabel,
    buttonType,
    href,
    target,
    loading,
    onClick,
    resets,
    submits
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isDisabled = dependencies2.isDisabled;
  var fieldId = dependencies2.fieldId;
  var fire = dependencies2.fire;
  var el$2 = dependencies2.el$;
  var isLoading = computed(() => {
    if (typeof loading.value === "function") {
      return loading.value(form$.value, el$2.value);
    }
    if (submits.value && (form$.value.submitting || form$.value.preparing || form$.value.isLoading)) {
      return true;
    }
    return loading.value;
  });
  var isButtonLabelComponent = computed(() => {
    return buttonLabel.value !== null && typeof buttonLabel.value === "object";
  });
  var button4 = computed(() => {
    var button5 = {
      id: fieldId.value
    };
    switch (buttonType.value) {
      case "anchor":
        button5.href = href.value;
        button5.target = target.value;
        break;
      case "button":
        button5.disabled = isDisabled.value;
        break;
    }
    if (isLoading.value) {
      button5.tabindex = void 0;
    }
    return button5;
  });
  var resolvedButtonLabel = computed(() => {
    return typeof buttonLabel.value === "function" ? buttonLabel.value(el$2.value) : buttonLabel.value;
  });
  var handleClick = (e2) => {
    if (buttonType.value === "anchor" && !href.value) {
      e2.preventDefault();
    }
    if (isDisabled.value || isLoading.value) {
      e2.preventDefault();
      return;
    }
    if (resets.value) {
      form$.value.reset();
    }
    if (submits.value) {
      form$.value.submit();
    }
    fire("click", form$.value, el$2.value, e2);
  };
  return {
    isButtonLabelComponent,
    button: button4,
    resolvedButtonLabel,
    isLoading,
    handleClick
  };
};
var base$X = function base20(props, context, dependencies2) {
  var {
    layout,
    inline
  } = toRefs(props);
  var elementLayout = computed(() => {
    return inline.value || !layout.value ? "ElementLayoutInline" : layout.value;
  });
  return {
    elementLayout
  };
};
var base$W = function base21(props, context, dependencies2) {
  var {
    id,
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var fieldId = computed(() => {
    var _parent$value, _parent$value2;
    return id.value || ((_parent$value = parent2.value) !== null && _parent$value !== void 0 && _parent$value.fieldId ? "".concat((_parent$value2 = parent2.value) === null || _parent$value2 === void 0 ? void 0 : _parent$value2.fieldId, ".").concat(name2.value) : name2.value);
  });
  return {
    fieldId
  };
};
var base$V = function base22(props, context, dependencies2) {
  var {
    container
  } = dependencies2;
  var focus = () => {
    var _container$value, _el$querySelector;
    var el = ((_container$value = container.value) === null || _container$value === void 0 ? void 0 : _container$value.$el) || container.value;
    el === null || el === void 0 || (_el$querySelector = el.querySelector("a[href],area[href],input:not([disabled]),select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe,[tabindex],[contentEditable=true],trix-editor")) === null || _el$querySelector === void 0 || _el$querySelector.focus();
  };
  return {
    focus
  };
};
var editor$1 = function editor(props, context, dependencies2) {
  var {
    input
  } = dependencies2;
  var focus = () => {
    input.value.editor$.focus();
  };
  return {
    focus
  };
};
var base$U = function base23(props, context, dependencies2) {
  var currentInstance = getCurrentInstance();
  var el$2 = computed(() => {
    return currentInstance.proxy;
  });
  provide("el$", el$2);
  return {
    el$: el$2
  };
};
var baseClone = _baseClone;
var CLONE_SYMBOLS_FLAG = 4;
function clone$1(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}
var clone_1 = clone$1;
var base$T = function base24(props, context, dependencies2) {
  var {
    disabled
  } = toRefs(props);
  var {
    el$: el$2,
    form$,
    path
  } = dependencies2;
  var localDisabled = ref(null);
  var isDisabled = computed(() => {
    if (localDisabled.value === true) {
      return true;
    }
    if (localDisabled.value === false) {
      return false;
    }
    if (typeof disabled.value === "function") {
      return disabled.value(el$2.value, form$.value);
    }
    if (Array.isArray(disabled.value)) {
      return disabled.value.every((condition2) => {
        return form$.value.$vueform.services.condition.check(condition2, path.value, form$.value, el$2.value);
      });
    }
    if (typeof disabled.value === "object" && disabled.value && disabled.value.value !== void 0) {
      return disabled.value.value;
    }
    return disabled.value;
  });
  var disable = () => {
    localDisabled.value = true;
  };
  var enable = () => {
    localDisabled.value = false;
  };
  return {
    localDisabled,
    isDisabled,
    disable,
    enable
  };
};
var checkboxgroup$3 = function checkboxgroup(props, context, dependencies2) {
  var {
    disables
  } = toRefs(props);
  var {
    localDisabled,
    isDisabled
  } = base$T(props, context, dependencies2);
  var disabledItems = ref([]);
  var disable = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var disablesList = clone_1(disabledItems.value);
    each(values2, (item) => {
      item = String(item);
      if (disablesList.indexOf(item) === -1) {
        disablesList.push(item);
      }
    });
    disabledItems.value = disablesList;
  };
  var enable = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var disablesList = clone_1(disabledItems.value);
    each(values2, (item) => {
      item = String(item);
      var index2 = disablesList.indexOf(item);
      if (index2 !== -1) {
        disablesList.splice(index2, 1);
      }
    });
    disabledItems.value = disablesList;
  };
  var disableAll = () => {
    localDisabled.value = true;
  };
  var enableAll = () => {
    localDisabled.value = false;
    disabledItems.value = [];
  };
  disabledItems.value = map_1(disables.value || /* istanbul ignore next: can't fall into this, because it is hardwired to be `[]` if undefined */
  [], (d) => {
    return String(d);
  });
  return {
    disabledItems,
    isDisabled,
    disableAll,
    enableAll,
    disable,
    enable
  };
};
var button$1 = function button(props, context, dependencies2) {
  var {
    disabled,
    submits
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var isDisabled = computed(() => {
    if (typeof disabled.value === "function") {
      return disabled.value(el$2.value, form$.value);
    }
    if (submits.value && (form$.value.invalid && form$.value.shouldValidateOnChange || form$.value.busy || form$.value.isDisabled)) {
      return true;
    }
    return disabled.value;
  });
  return {
    isDisabled
  };
};
var radiogroup$2 = checkboxgroup$3;
var base$S = function base25(props, context, dependencies2) {
  var fieldId = dependencies2.fieldId;
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var labelId = computed(() => {
    return "".concat(fieldId.value, "__label");
  });
  var descriptionId = computed(() => {
    return "".concat(fieldId.value, "__description");
  });
  var infoId = computed(() => {
    return "".concat(fieldId.value, "__info");
  });
  var errorId = computed(() => {
    return "".concat(fieldId.value, "__error");
  });
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled === null || isDisabled === void 0 ? void 0 : isDisabled.value,
      "aria-busy": busy.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var checkbox$1 = function checkbox(props, context, dependencies2) {
  var {
    text: text5
  } = toRefs(props);
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$S(props, context, dependencies2);
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var aria = computed(() => {
    var aria2 = {
      "aria-label": text5.value,
      "aria-describedby": "".concat(labelId.value, " ").concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled.value,
      "aria-busy": busy.value
    };
    if (!aria2["aria-label"]) {
      aria2["aria-labelledby"] = labelId.value;
    }
    return aria2;
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var checkboxgroup$2 = function checkboxgroup2(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$S(props, context, dependencies2);
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var aria = computed(() => {
    return {
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled.value,
      "aria-busy": busy.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var button2 = function button3(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$S(props, context, dependencies2);
  var isDisabled = dependencies2.isDisabled;
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-disabled": isDisabled.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var static_$3 = function static_(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$S(props, context, dependencies2);
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value)
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var phone$2 = function phone(props, context, dependencies2) {
  toRefs(props);
  var {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  } = base$S(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var optionsAria = computed(() => {
    return {
      "aria-label": form$.value.translations.vueform.elements.phone.ariaLabel
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria,
    optionsAria
  };
};
var radiogroup$1 = checkboxgroup$2;
var radio = checkbox$1;
var toggle$1 = checkbox$1;
var file$4 = checkboxgroup$2;
var createCaseFirst = _createCaseFirst;
var lowerFirst = createCaseFirst("toLowerCase");
var lowerFirst_1 = lowerFirst;
var base$R = function base26(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var currentInstance = getCurrentInstance();
  var form$ = dependencies2.form$;
  var assignToParent = ($parent, assignToParent2) => {
    if ($parent.children$Array) {
      $parent.children$Array.push(currentInstance.proxy);
    } else if ($parent.elements$) {
      form$.value.$set($parent.elements$, name2.value, currentInstance.proxy);
    } else {
      assignToParent2($parent.$parent, assignToParent2);
    }
  };
  var removeFromParent = ($parent, removeFromParent2) => {
    if ($parent.children$Array) {
      $parent.children$Array.splice($parent.children$Array.map((e$) => normalize(e$.name)).indexOf(normalize(name2.value)), 1);
    } else if ($parent.elements$) {
      form$.value.$delete($parent.elements$, name2.value);
    } else {
      removeFromParent2($parent.$parent, removeFromParent2);
    }
  };
  return {
    assignToParent,
    removeFromParent
  };
};
var base$Q = function base27(props, context, dependencies2) {
  var instantHooks = ["onBeforeCreate", "onCreated"];
  var hooks = {
    onBeforeMount,
    onMounted,
    onBeforeUpdate,
    onUpdated,
    onBeforeUnmount,
    onUnmounted
  };
  var currentInstance = getCurrentInstance();
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var fire = dependencies2.fire;
  var {
    assignToParent,
    removeFromParent
  } = base$R(props, context, {
    form$
  });
  var container = ref(null);
  var mounted = ref(false);
  var active = ref(true);
  var isStatic = computed(() => {
    return false;
  });
  var isFileType = computed(() => {
    return false;
  });
  var isImageType = computed(() => {
    return false;
  });
  var isArrayType = computed(() => {
    return false;
  });
  var isObjectType = computed(() => {
    return false;
  });
  var isGroupType = computed(() => {
    return false;
  });
  var isListType = computed(() => {
    return false;
  });
  var isActive = computed(() => {
    return active.value;
  });
  var activate = () => {
    active.value = true;
  };
  var deactivate = () => {
    active.value = false;
  };
  onBeforeMount(() => {
    assignToParent(currentInstance.proxy.$parent, assignToParent);
  });
  onMounted(() => {
    mounted.value = true;
  });
  onBeforeUnmount(() => {
    removeFromParent(currentInstance.proxy.$parent, removeFromParent);
  });
  Object.values(instantHooks).forEach((hook) => {
    fire(lowerFirst_1(hook.replace("on", "")), el$2.value);
  });
  Object.keys(hooks).forEach((hook) => {
    hooks[hook](() => {
      fire(lowerFirst_1(hook.replace("on", "")), el$2.value);
    });
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var list$4 = function list2(props, context, dependencies2) {
  var {
    isStatic,
    isFileType,
    isImageType,
    isObjectType,
    isGroupType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$Q(props, context, dependencies2);
  var isArrayType = computed(() => {
    return true;
  });
  var isListType = computed(() => {
    return true;
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var object$7 = function object(props, context, dependencies2) {
  var {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$Q(props, context, dependencies2);
  var isObjectType = computed(() => {
    return true;
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var group$7 = function group(props, context, dependencies2) {
  var {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$Q(props, context, dependencies2);
  var isGroupType = computed(() => {
    return true;
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var file$3 = function file(props, context, dependencies2) {
  var {
    view
  } = toRefs(props);
  var {
    isStatic,
    isArrayType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$Q(props, context, dependencies2);
  var isFileType = computed(() => {
    return true;
  });
  var isImageType = computed(() => {
    return ["gallery", "image"].indexOf(view.value) !== -1;
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var static_$2 = function static_2(props, context, dependencies2) {
  var {
    isArrayType,
    isFileType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$Q(props, context, dependencies2);
  var isStatic = computed(() => {
    return true;
  });
  return {
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var checkboxgroup$1 = list$4;
var dates$5 = list$4;
var multiselect$5 = list$4;
var tags$5 = list$4;
var base$P = function base28(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var currentInstance = getCurrentInstance();
  var {
    form$
  } = dependencies2;
  var parent2 = computed(() => {
    var getParent = (parent3, getParent2) => {
      if (parent3 && (form$.value.$vueform.vueVersion === 3 && parent3.$options.name && parent3.$options.name.match(/^[a-zA-Z\-]*Element$/) || form$.value.$vueform.vueVersion === 2 && parent3.hasOwnProperty("el$") && typeof parent3.el$ !== "function")) {
        return parent3.el$;
      } else if (parent3.$parent) {
        return getParent2(parent3.$parent, getParent2);
      } else {
        return null;
      }
    };
    return getParent(form$.value.$vueform.vueVersion === 3 ? currentInstance.parent.proxy : currentInstance.proxy.$parent, getParent);
  });
  var path = computed(() => {
    return parent2.value && parent2.value.path ? parent2.value.path + "." + name2.value : name2.value;
  });
  var dataPath = computed(() => {
    return parent2.value && parent2.value.dataPath ? parent2.value.dataPath + "." + name2.value : name2.value;
  });
  var flat = computed(() => {
    return false;
  });
  return {
    parent: parent2,
    path,
    dataPath,
    flat
  };
};
var group$6 = function group2(props, context, dependencies2) {
  var {
    path,
    parent: parent2
  } = base$P(props, context, dependencies2);
  var dataPath = computed(() => {
    return parent2.value && parent2.value.dataPath ? parent2.value.dataPath : null;
  });
  var flat = computed(() => {
    return true;
  });
  return {
    path,
    dataPath,
    flat,
    parent: parent2
  };
};
var static_$1 = function static_3(props, context, dependencies2) {
  var {
    path,
    parent: parent2,
    flat
  } = base$P(props, context, dependencies2);
  return {
    path,
    flat,
    parent: parent2
  };
};
function resolveDeps(props, context, options) {
  var deps = options.deps || {};
  options = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
    events: context.emits,
    slots: context.slots
  });
  context.features.forEach((feature) => {
    each(feature(props, context, deps, options), (featureDep, key) => {
      deps[key] = featureDep;
    });
  });
  return deps;
}
var base$O = function base29(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    if (deps.initWatcher) {
      deps.initWatcher();
    }
    if (deps.initMessageBag) {
      deps.initMessageBag();
    }
    if (deps.initValidation) {
      deps.initValidation();
    }
  });
  return _objectSpread2$1({}, deps);
};
var static_4 = function static_5(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  return _objectSpread2$1({}, deps);
};
var multilingual$8 = function multilingual(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    deps.initWatcher();
    deps.initState();
    deps.initMessageBag();
    deps.initValidation();
  });
  return _objectSpread2$1({}, deps);
};
var location$3 = function location(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    displayKey
  } = toRefs(props);
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    if (deps.value.value[displayKey.value]) {
      deps.input.value.value = deps.value.value[displayKey.value];
    }
  });
  onMounted(() => {
    deps.initWatcher();
    deps.initMessageBag();
    deps.initValidation();
  });
  return _objectSpread2$1({}, deps);
};
var BaseElement = {
  props: {
    name: {
      required: true,
      type: [String, Number]
    },
    conditions: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBeforeCreate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onCreated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeMount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onMounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUpdate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUpdated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUnmount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUnmounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  }
};
var HasView = {
  props: {
    inline: {
      required: false,
      type: [Boolean],
      default: false
    },
    layout: {
      required: false,
      type: [String, Object, Boolean],
      default: "ElementLayout",
      private: true
    },
    addClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object, Function],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    addClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    replaceClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    removeClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    overrideClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    presets: {
      required: false,
      type: [Array],
      default: () => []
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    views: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    size: {
      required: false,
      type: [String],
      default: void 0
    },
    columns: {
      required: false,
      type: [Object, String, Number],
      default: null
    },
    templates: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    description: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    info: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    infoPosition: {
      required: false,
      type: [String],
      default: "right"
    },
    label: {
      required: false,
      type: [String, Object, Function],
      localized: true,
      default: null
    },
    before: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    between: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    after: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    slots: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  }
};
var ButtonElement = {
  name: "ButtonElement",
  mixins: [BaseElement, HasView],
  emits: ["click", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "button",
      private: true
    },
    buttonLabel: {
      required: false,
      type: [String, Object, Function],
      default: null
    },
    buttonType: {
      required: false,
      type: [String],
      default: "button"
      // button|anchor
    },
    buttonClass: {
      required: false,
      type: [String, Array, Object],
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    loading: {
      required: false,
      type: [Function, Boolean],
      default: false
    },
    href: {
      required: false,
      type: [String],
      default: ""
    },
    target: {
      required: false,
      type: [String],
      default: null
    },
    onClick: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    resets: {
      required: false,
      type: [Boolean],
      default: false
    },
    submits: {
      required: false,
      type: [Boolean],
      default: false
    },
    secondary: {
      required: false,
      type: [Boolean],
      default: false
    },
    danger: {
      required: false,
      type: [Boolean],
      default: false
    },
    full: {
      required: false,
      type: [Boolean],
      default: false
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, static_$1, base$1e, static_$2, button$1, base$16, base$11, base$$, base$_, base$W, base$Y, base$1c, base$10, base$Z, button2, base$V];
    context.slots = ["label", "info", "description", "before", "between", "after", "default"];
    return _objectSpread2$1({}, static_4(props, context));
  }
};
var base$N = function base30(props, context, dependencies2) {
  var input = ref(null);
  return {
    input
  };
};
var select$4 = function select(props, context, dependencies2) {
  var input = ref(null);
  return {
    input
  };
};
var multiselect$4 = select$4;
var tags$4 = select$4;
function checkDateFormat(format, date6, moment) {
  if (!(date6 instanceof Date) && moment(date6, format).format(format) !== date6) {
    console.warn('Wrong formatted date. Expected format: "'.concat(format, '", received: "').concat(date6, '"'));
  }
}
var base$M = function base31(props, context, dependencies2) {
  var _options$value, _options$value2;
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    name: name2,
    type
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var initialValue = ref(void 0);
  if (form$.value.isSync) {
    initialValue.value = get_1(form$.value.model, dataPath.value);
  } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
    initialValue.value = parent2.value.value[name2.value];
  }
  var internalValue = ref(defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value));
  var value = computed({
    get: ((_options$value = options.value) === null || _options$value === void 0 ? void 0 : _options$value.get) || function() {
      var value2;
      if (form$.value.isSync) {
        value2 = get_1(form$.value.model, dataPath.value);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
        value2 = parent2.value.value[name2.value];
      } else {
        value2 = internalValue.value;
      }
      return value2 !== void 0 ? value2 : (
        /* istanbul ignore next: value is never undefined if default is set */
        defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
      );
    },
    set: ((_options$value2 = options.value) === null || _options$value2 === void 0 ? void 0 : _options$value2.set) || function(val) {
      if (form$.value.isSync) {
        form$.value.updateModel(dataPath.value, val);
      } else if (parent2.value && parent2.value.isListType) {
        var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
        parent2.value.update(newValue);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        parent2.value.value = Object.assign({}, parent2.value.value, {
          [name2.value]: val
        });
      } else {
        internalValue.value = val;
      }
    }
  });
  var model = computed({
    get() {
      return value.value;
    },
    set(val) {
      value.value = val;
    }
  });
  if (options.init === void 0 || options.init !== false) {
    if (initialValue.value === void 0) {
      value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
    }
  }
  var isDefault = computed(() => {
    return isEqual_1(value.value, defaultValue.value);
  });
  watch(type, () => {
    value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
  });
  return {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  };
};
var list$3 = function list3(props, context, dependencies2) {
  var {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  } = base$M(props, context, dependencies2, {
    init: false
  });
  return {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  };
};
var object$6 = function object2(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    initialValue,
    internalValue,
    value,
    isDefault
  } = base$M(props, context, dependencies2, {
    init: false
  });
  var defaultValue = dependencies2.defaultValue;
  if (options.init === void 0 || /* istanbul ignore next: init will always be false */
  options.init !== false) {
    if (initialValue.value === void 0) {
      value.value = defaultValue.value;
    } else {
      value.value = Object.assign({}, defaultValue.value, value.value);
    }
  }
  return {
    internalValue,
    value,
    isDefault
  };
};
var group$5 = function group3(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var parent2 = dependencies2.parent;
  var dataPath = dependencies2.dataPath;
  var defaultValue = dependencies2.defaultValue;
  var children$Array = dependencies2.children$Array;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var internalValue = ref(cloneDeep_1(defaultValue.value));
  var value = computed(options.value || {
    get() {
      var value2;
      if (form$.value.isSync) {
        value2 = dataPath.value ? get_1(form$.value.model, dataPath.value) || {} : form$.value.model;
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        value2 = parent2.value.value;
      } else {
        value2 = internalValue.value;
      }
      var childKeys = children$Array.value.reduce((all, child$) => {
        if (!child$ || child$.isStatic) {
          return all;
        }
        var keys2 = [];
        if (!child$.flat) {
          keys2.push(child$.name);
        } else {
          var addGroupKeys = (children$Array2) => {
            children$Array2.forEach((child$2) => {
              if (!child$2.isStatic && child$2.flat) {
                addGroupKeys(child$2.children$Array);
              } else if (!child$2.isStatic) {
                keys2.push(child$2.name);
              }
            });
          };
          addGroupKeys(child$.children$Array);
        }
        return all.concat(keys2);
      }, []);
      var tempValue = {};
      childKeys.forEach((key) => {
        if (value2[key] !== void 0) {
          tempValue[key] = value2[key];
        }
      });
      value2 = tempValue;
      return value2 !== void 0 ? value2 : (
        /* istanbul ignore next: will never reach, internalValue is assigned at the beginning */
        cloneDeep_1(defaultValue.value)
      );
    },
    set(val) {
      if (form$.value.isSync) {
        form$.value.updateModel(dataPath.value, val);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        parent2.value.value = Object.assign({}, parent2.value.value, val);
      } else {
        internalValue.value = val;
      }
    }
  });
  var isDefault = computed(() => {
    return isEqual_1(value.value, defaultValue.value);
  });
  return {
    value,
    isDefault
  };
};
var multilingual$7 = function multilingual2(props, context, dependencies2) {
  var {
    value,
    isDefault
  } = base$M(props, context, dependencies2);
  var language = dependencies2.language;
  var model = computed({
    get() {
      return value.value[language.value];
    },
    set(val) {
      value.value = Object.assign({}, value.value, {
        [language.value]: val
      });
    }
  });
  return {
    value,
    model,
    isDefault
  };
};
var date$3 = function date(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var valueDateFormat = dependencies2.valueDateFormat;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var moment = form$.value.$vueform.services.moment;
  var internalValue = ref(defaultValue.value instanceof File ? (
    /* istanbul ignore next: @todo:adam date type will never have file instance default value */
    defaultValue.value
  ) : cloneDeep_1(defaultValue.value));
  var {
    value,
    initialValue,
    isDefault
  } = base$M(props, context, dependencies2, {
    value: {
      get() {
        var value2;
        if (form$.value.isSync) {
          value2 = get_1(form$.value.model, dataPath.value);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
          value2 = parent2.value.value[name2.value];
        } else {
          value2 = internalValue.value;
        }
        return value2 !== void 0 ? value2 : (
          /* istanbul ignore next: can not be undefined @todo:adam can not be file */
          defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
        );
      },
      set(val) {
        if (!isEmpty_1(val) && !(val instanceof Date) && valueDateFormat.value !== false) {
          checkDateFormat(valueDateFormat.value, val, moment);
        }
        val = val && val instanceof Date && valueDateFormat.value !== false ? moment(val).format(valueDateFormat.value) : val;
        if (form$.value.isSync) {
          form$.value.updateModel(dataPath.value, val);
        } else if (parent2.value && parent2.value.isListType) {
          var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
          parent2.value.update(newValue);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
          parent2.value.value = Object.assign({}, parent2.value.value, {
            [name2.value]: val
          });
        } else {
          internalValue.value = val;
        }
      }
    }
  });
  var model = computed(() => {
    return value.value instanceof Date || !value.value ? value.value : moment(value.value, valueDateFormat.value).toDate();
  });
  return {
    value,
    model,
    initialValue,
    internalValue,
    isDefault
  };
};
var dates$4 = function dates(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var valueDateFormat = dependencies2.valueDateFormat;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var moment = form$.value.$vueform.services.moment;
  var internalValue = ref(defaultValue.value instanceof File ? (
    /* istanbul ignore next: @todo:adam date type will never have file instance default value */
    defaultValue.value
  ) : cloneDeep_1(defaultValue.value));
  var {
    value,
    initialValue,
    isDefault
  } = base$M(props, context, dependencies2, {
    value: {
      get() {
        var value2;
        if (form$.value.isSync) {
          value2 = get_1(form$.value.model, dataPath.value);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
          value2 = parent2.value.value[name2.value];
        } else {
          value2 = internalValue.value;
        }
        return value2 !== void 0 ? value2 : (
          /* istanbul ignore next: can not be undefined @todo:adam can not be file */
          defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
        );
      },
      set(val) {
        if (!Array.isArray(val)) {
          val = [val];
        }
        val = val.map((v) => {
          if (!isEmpty_1(v) && !(v instanceof Date) && valueDateFormat.value !== false) {
            checkDateFormat(valueDateFormat.value, v, moment);
          }
          return v && v instanceof Date && valueDateFormat.value !== false ? moment(v).format(valueDateFormat.value) : v;
        });
        if (form$.value.isSync) {
          form$.value.updateModel(dataPath.value, val);
        } else if (parent2.value && parent2.value.isListType) {
          var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
          parent2.value.update(newValue);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
          parent2.value.value = Object.assign({}, parent2.value.value, {
            [name2.value]: val
          });
        } else {
          internalValue.value = val;
        }
      }
    }
  });
  var model = computed(() => {
    return value.value.map((v) => {
      return v instanceof Date || !v ? v : moment(v, valueDateFormat.value).toDate();
    });
  });
  return {
    value,
    model,
    initialValue,
    internalValue,
    isDefault
  };
};
var base$L = function base32(props, context, dependencies2) {
  var nullValue = computed(() => {
    return null;
  });
  return {
    nullValue
  };
};
var array$1 = function array(props, context, dependencies2) {
  var nullValue = computed(() => {
    return [];
  });
  return {
    nullValue
  };
};
var boolean = function boolean2(props, context, dependencies2) {
  var {
    falseValue
  } = toRefs(props);
  var nullValue = computed(() => {
    return falseValue.value;
  });
  return {
    nullValue
  };
};
var min = function min2(props, context, dependencies2) {
  var {
    min: min3,
    default: default_
  } = toRefs(props);
  var nullValue = computed(() => {
    return default_.value !== void 0 && isArray_1(default_.value) ? default_.value.map((v) => min3.value) : min3.value;
  });
  return {
    nullValue
  };
};
var object$5 = function object3(props, context, dependencies2) {
  var nullValue = computed(() => {
    return {};
  });
  return {
    nullValue
  };
};
var location$2 = function location2(props, context, dependencies2) {
  var nullValue = computed(() => {
    return {
      country: null,
      country_code: null,
      state: null,
      state_code: null,
      city: null,
      zip: null,
      address: null,
      formatted_address: null,
      lat: null,
      lng: null
    };
  });
  return {
    nullValue
  };
};
var multilingual$6 = function multilingual3(props, context, dependencies2) {
  var languages = dependencies2.languages;
  var nullValue = computed(() => {
    var value = {};
    each(languages.value, (code) => {
      value[code] = null;
    });
    return value;
  });
  return {
    nullValue
  };
};
var generic = function generic2(props, context, dependencies2) {
  var nullValue = computed(() => {
    return context.nullValue !== void 0 ? context.nullValue : null;
  });
  return {
    nullValue
  };
};
var base$K = function base33(props, context, dependencies2) {
  var {
    name: name2,
    floating,
    placeholder,
    label,
    fieldName
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var Label = dependencies2.Label;
  var config$ = inject("config$");
  var genericName = computed(() => {
    if (fieldName && fieldName.value) {
      return localize(fieldName.value, config$.value, form$.value);
    } else if (label && label.value) {
      return Label.value;
    } else if (floating && floating.value) {
      return localize(floating.value, config$.value, form$.value);
    } else if (placeholder && placeholder.value && form$.value.options.floatPlaceholders) {
      return localize(placeholder.value, config$.value, form$.value);
    } else {
      return upperFirst_1(name2.value).replace(/_|-/g, " ");
    }
  });
  return {
    genericName
  };
};
var file$2 = function file2(props, context, dependencies2) {
  var {
    name: name2,
    embed,
    label,
    fieldName
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var Label = dependencies2.Label;
  var filename = dependencies2.filename || /* istanbul ignore next: failsafe only */
  ref(null);
  var config$ = inject("config$");
  var genericName = computed(() => {
    if (embed.value && filename.value) {
      return filename.value;
    } else if (fieldName && fieldName.value) {
      return localize(fieldName.value, config$.value, form$.value);
    } else if (label.value) {
      return Label.value;
    } else {
      return /^\d+$/.test(name2.value) ? form$.value.translations.vueform.elements.file.defaultName : upperFirst_1(name2.value).replace(/_|-/g, " ");
    }
  });
  return {
    genericName
  };
};
var base$J = function base34(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var empty = computed(() => {
    return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1;
  });
  return {
    empty
  };
};
var multilingual$5 = function multilingual4(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var language = dependencies2.language;
  var empty = computed(() => {
    return value.value[language.value] == nullValue.value[language.value] || value.value[language.value] === "";
  });
  return {
    empty
  };
};
var array2 = function array3(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var empty = computed(() => {
    return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1 || value.value.length == 0;
  });
  return {
    empty
  };
};
var base$I = function base35(props, context, dependencies2) {
  var {
    loading
  } = toRefs(props);
  var pending = dependencies2.pending;
  var isLoading = computed(() => {
    return pending.value || loading.value;
  });
  return {
    isLoading
  };
};
var base$H = function base36(props, context, dependencies2) {
  var {
    floating,
    placeholder
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var hasFloating = computed(() => {
    return !!(!!floating.value || placeholder.value && form$.value.options.floatPlaceholders) && floating.value !== false;
  });
  return {
    hasFloating
  };
};
var base$G = function base37(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validate = dependencies2.validate;
  var value = dependencies2.value;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$2.value);
      if (dirt) {
        dirt();
      }
      if (validate && form$.value.shouldValidateOnChange) {
        validate();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var multilingual$4 = function multilingual5(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var value = dependencies2.value;
  var language = dependencies2.language;
  var validateLanguage = dependencies2.validateLanguage;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$2.value);
      if (dirt) {
        dirt();
      }
      if (form$.value.shouldValidateOnChange) {
        validateLanguage(language.value);
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var list$2 = function list4(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validateValidators = dependencies2.validateValidators;
  var value = dependencies2.value;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$2.value);
      if (dirt) {
        dirt();
      }
      if (validateValidators && form$.value.shouldValidateOnChange) {
        validateValidators();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var object$4 = function object4(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var fire = dependencies2.fire;
  var value = dependencies2.value;
  var el$2 = dependencies2.el$;
  var dirt = dependencies2.dirt;
  var validateValidators = dependencies2.validateValidators;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$2.value);
      if (dirt) {
        dirt();
      }
      if (validateValidators && form$.value.shouldValidateOnChange) {
        validateValidators();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var location$1 = function location3(props, context, dependencies2) {
  var {
    displayKey
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$2 = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validate = dependencies2.validate;
  var value = dependencies2.value;
  var input = dependencies2.input;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$2.value);
      dirt();
      input.value.value = input.value && value.value && value.value[displayKey.value] !== void 0 ? value.value[displayKey.value] : "";
      if (validate && form$.value.shouldValidateOnChange) {
        validate();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var multifile$5 = list$2;
var group$4 = object$4;
var base$F = function base38(props, context, dependencies2) {
  var {
    provider: elementProvider,
    options,
    readonly
  } = toRefs(props);
  var {
    form$,
    input,
    model,
    nullValue,
    messageBag: messageBag2,
    validate,
    el$: el$2,
    invalid,
    isDisabled,
    resetValidators,
    resetting,
    initValidation
  } = dependencies2;
  var Provider = ref(null);
  var shouldVerify = computed(() => {
    return !isDisabled.value && !readonly.value;
  });
  var provider = computed(() => {
    return elementProvider.value || form$.value.options.useProviders.captcha;
  });
  var captchaOptions = computed(() => {
    return _objectSpread2$1(_objectSpread2$1({}, form$.value.options.providerOptions[provider.value]), options.value);
  });
  var initCaptcha = () => {
    model.value = nullValue.value;
    Provider.value = new form$.value.options.providers.captcha[provider.value](input.value, captchaOptions.value, el$2.value);
  };
  var destroyCaptcha = () => {
    resetValidators();
    Provider.value.reset();
    model.value = nullValue.value;
    Provider.value = null;
  };
  onMounted(() => {
    if (shouldVerify.value) {
      initCaptcha();
    }
  });
  watch(shouldVerify, function() {
    var _ref = _asyncToGenerator(function* (n2, o2) {
      if (!n2) {
        destroyCaptcha();
      } else if (n2) {
        yield nextTick();
        initCaptcha();
        initValidation();
      }
    });
    return function(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    Provider,
    captchaOptions,
    shouldVerify,
    initCaptcha,
    destroyCaptcha
  };
};
var base$E = function base39(props, context, dependencies2) {
  var {
    rules: rules2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path;
  var el$2 = dependencies2.el$;
  var state = ref({
    dirty: false,
    validated: true
  });
  var Validators = ref([]);
  var messageBag2 = ref({});
  var validatorFactory = reactive({});
  var resetting = ref(false);
  var validationRules = computed(() => {
    return rules2.value;
  });
  var dirty = computed(() => {
    return state.value.dirty;
  });
  var validated = computed(() => {
    return state.value.validated;
  });
  var invalid = computed(() => {
    return some_1(Validators.value, {
      invalid: true
    });
  });
  var pending = computed(() => {
    return some_1(Validators.value, {
      pending: true
    });
  });
  var busy = computed(() => {
    return pending.value;
  });
  var validatorErrors = computed(() => {
    var errs = [];
    each(Validators.value, (Validator2) => {
      if (Validator2.failing) {
        errs.push(Validator2.message);
      }
    });
    return errs;
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    return messageBag2.value.error || null;
  });
  var isDanger = computed(() => {
    return error.value !== null;
  });
  var isSuccess = computed(() => {
    return validationRules.value && validationRules.value.length > 0 && state.value.validated && !invalid.value || (!validationRules.value || !validationRules.value.length) && dirty.value;
  });
  var isRequired = computed(() => {
    return Validators.value.some((Validator2) => {
      var _Validator$conditions;
      if (Validator2.name !== "required") {
        return;
      }
      if (!((_Validator$conditions = Validator2.conditions) !== null && _Validator$conditions !== void 0 && _Validator$conditions.length)) {
        return true;
      }
      return Validator2.conditions(form$.value, Validator2, el$2.value);
    });
  });
  var validate = function() {
    var _ref = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref2 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate();
        });
        return function(_x) {
          return _ref2.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(Validators.value, (Validator2) => {
      Validator2.reset();
    });
    state.value.validated = !validationRules.value;
  };
  var dirt = () => {
    state.value.dirty = true;
  };
  var clean = () => {
    state.value.dirty = false;
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
  };
  var initValidation = () => {
    if (!validationRules.value) {
      return;
    }
    state.value.validated = false;
    validatorFactory.value = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
    Validators.value = [];
    each(validatorFactory.value.makeAll(validationRules.value), (Validator2) => {
      Validators.value.push(Validator2);
    });
  };
  var reinitValidation = () => {
    initValidation();
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    isRequired,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var text$2 = function text(props, context, dependencies2) {
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    isRequired,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$E(props, context, dependencies2);
  var debouncing = computed(() => {
    return some_1(Validators.value, {
      debouncing: true
    });
  });
  var busy = computed(() => {
    return pending.value || debouncing.value;
  });
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    isRequired,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var list$1 = function list5(props, context, dependencies2) {
  var {
    state,
    Validators,
    messageBag: messageBag2,
    validationRules,
    dirt,
    initValidation,
    resetting,
    isRequired
  } = base$E(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var dirty = computed(() => {
    return some_1(children$.value, {
      available: true,
      dirty: true
    }) || state.value.dirty;
  });
  var validated = computed(() => {
    return !some_1(children$.value, {
      available: true,
      validated: false
    }) && state.value.validated;
  });
  var invalid = computed(() => {
    return some_1(children$.value, {
      available: true,
      invalid: true
    }) || some_1(Validators.value, {
      invalid: true
    });
  });
  var pending = computed(() => {
    return some_1(children$.value, {
      available: true,
      pending: true
    }) || some_1(Validators.value, {
      pending: true
    });
  });
  var debouncing = computed(() => {
    return some_1(children$.value, {
      available: true,
      debouncing: true
    }) || some_1(Validators.value, {
      debouncing: true
    });
  });
  var busy = computed(() => {
    return some_1(children$.value, {
      available: true,
      busy: true
    }) || pending.value || debouncing.value;
  });
  var validatorErrors = computed(() => {
    var validatorErrors2 = [];
    each(Validators.value, (Validator2) => {
      if (Validator2.failing) {
        validatorErrors2.push(Validator2.message);
      }
    });
    return validatorErrors2;
  });
  var childrenErrors = computed(() => {
    var childrenErrors2 = [];
    each(children$.value, (element$) => {
      if (!element$.available || element$.isStatic) {
        return;
      }
      each(element$.errors, (error2) => {
        childrenErrors2.push(error2);
      });
    });
    return childrenErrors2;
  });
  var baseErrors = computed(() => {
    return validatorErrors.value.concat(childrenErrors.value);
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    return head_1(validatorErrors.value);
  });
  var validate = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield validateValidators();
      yield validateChildren();
    });
    return function validate2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var validateValidators = function() {
    var _ref4 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref5 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate();
        });
        return function(_x2) {
          return _ref5.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validateValidators2() {
      return _ref4.apply(this, arguments);
    };
  }();
  var validateChildren = function() {
    var _ref6 = _asyncToGenerator(function* () {
      if (form$.value.validation === false) {
        return;
      }
      yield asyncForEach(children$.value, function() {
        var _ref7 = _asyncToGenerator(function* (element$) {
          if (!element$.isStatic) {
            yield element$.validate();
          }
        });
        return function(_x3) {
          return _ref7.apply(this, arguments);
        };
      }());
    });
    return function validateChildren2() {
      return _ref6.apply(this, arguments);
    };
  }();
  var clean = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clean();
    });
    state.value.dirty = false;
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clearMessages();
    });
  };
  var resetValidators = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.resetValidators();
    });
    each(Validators.value, (Validator2) => {
      Validator2.reset();
    });
    state.value.validated = !validationRules.value;
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(baseErrors);
  };
  var reinitValidation = () => {
    initValidation();
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.reinitValidation();
    });
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    isRequired,
    validatorErrors,
    childrenErrors,
    errors,
    error,
    validationRules,
    validate,
    validateValidators,
    validateChildren,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var multilingual$3 = function multilingual6(props, context, dependencies2) {
  var {
    rules: rules2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path;
  var languages = dependencies2.languages;
  var language = dependencies2.language;
  var value = dependencies2.value;
  var {
    messageBag: messageBag2,
    clearMessages,
    resetting
  } = text$2(props, context, dependencies2);
  var state = ref({
    dirty: {},
    validated: {}
  });
  var Validators = ref({});
  var validationRules = computed(() => {
    var ruleList = {};
    if (!rules2.value) {
      return ruleList;
    }
    each(languages.value, (lang) => {
      ruleList[lang] = isPlainObject_1(rules2.value) ? rules2.value[lang] || null : rules2.value;
    });
    return ruleList;
  });
  var dirty = computed(() => {
    return some_1(state.value.dirty, (val) => {
      return val === true;
    });
  });
  var validated = computed(() => {
    return !some_1(state.value.validated, (val) => {
      return val === false;
    });
  });
  var invalid = computed(() => {
    var invalid2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        invalid: true
      })) {
        invalid2 = true;
      }
    });
    return invalid2;
  });
  var pending = computed(() => {
    var pending2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        pending: true
      })) {
        pending2 = true;
      }
    });
    return pending2;
  });
  var debouncing = computed(() => {
    var debouncing2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        debouncing: true
      })) {
        debouncing2 = true;
      }
    });
    return debouncing2;
  });
  var busy = computed(() => {
    return pending.value || debouncing.value;
  });
  var validatorErrors = computed(() => {
    var errors2 = [];
    each(Validators.value, (Validators2, language2) => {
      each(Validators2, (Validator2) => {
        if (Validator2.failing) {
          errors2.push(Validator2.message + " (" + language2 + ")");
        }
      });
    });
    return errors2;
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    var error2 = null;
    each(Validators.value[language.value], (Validator2) => {
      if (error2 !== null) {
        return false;
      }
      if (Validator2.failing) {
        error2 = Validator2.message;
      }
    });
    var errors2 = messageBag2.value.prepends ? messageBag2.value.prepends.errors : [];
    if (error2 !== null) {
      errors2 = concat_1(errors2, [error2]);
    }
    errors2 = concat_1(errors2, messageBag2.value.appends ? messageBag2.value.appends.errors : []);
    return head_1(errors2);
  });
  var isDanger = computed(() => {
    return error.value !== null && error.value !== void 0;
  });
  var isSuccess = computed(() => {
    return validationRules.value[language.value] && validationRules.value[language.value].length > 0 && state.value.validated[language.value] && !some_1(Validators.value[language.value], {
      invalid: true
    }) || (!validationRules.value[language.value] || !validationRules.value[language.value].length) && state.value.dirty[language.value];
  });
  var isRequired = computed(() => {
    var _Validators$value;
    return (_Validators$value = Validators.value) === null || _Validators$value === void 0 || (_Validators$value = _Validators$value[language.value]) === null || _Validators$value === void 0 ? void 0 : _Validators$value.some((Validator2) => {
      var _Validator$conditions2;
      if (Validator2.name !== "required") {
        return;
      }
      if (!((_Validator$conditions2 = Validator2.conditions) !== null && _Validator$conditions2 !== void 0 && _Validator$conditions2.length)) {
        return true;
      }
      return Validator2.conditions(form$.value, Validator2, el$.value);
    });
  });
  var validate = function() {
    var _ref8 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(languages.value, function() {
        var _ref9 = _asyncToGenerator(function* (lang) {
          yield validateLanguage(lang);
        });
        return function(_x4) {
          return _ref9.apply(this, arguments);
        };
      }());
    });
    return function validate2() {
      return _ref8.apply(this, arguments);
    };
  }();
  var validateLanguage = function() {
    var _ref10 = _asyncToGenerator(function* () {
      var lang = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : language.value;
      if (form$.value.validation === false) {
        return;
      }
      if (!Validators.value[lang]) {
        return;
      }
      yield asyncForEach(Validators.value[lang], function() {
        var _ref11 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate(value.value[lang]);
        });
        return function(_x5) {
          return _ref11.apply(this, arguments);
        };
      }());
      state.value.validated[lang] = true;
    });
    return function validateLanguage2() {
      return _ref10.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(languages.value, (lang) => {
      each(Validators.value[lang], (Validator2) => {
        Validator2.reset();
      });
      each(validationRules.value, (r2, lang2) => {
        state.value.validated[lang2] = r2.length > 0 ? false : true;
      });
    });
  };
  var dirt = () => {
    state.value.dirty[language.value] = true;
  };
  var clean = () => {
    state.value.dirty[language.value] = false;
  };
  var initState = () => {
    var dirty2 = {};
    var validated2 = {};
    each(languages.value, (lang) => {
      dirty2[lang] = false;
    });
    each(languages.value, (lang) => {
      validated2[lang] = true;
    });
    state.value = {
      dirty: dirty2,
      validated: validated2
    };
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
  };
  var initValidation = () => {
    if (!validationRules.value) {
      return;
    }
    each(validationRules.value, (r2, lang) => {
      state.value.validated[lang] = r2 !== null && r2.length > 0 ? false : true;
    });
    var factory = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
    Validators.value = {};
    each(validationRules.value, (languageRules, lang) => {
      if (languageRules === null) {
        return;
      }
      if (!Validators.value[lang]) {
        Validators.value = Object.assign({}, Validators.value, {
          [lang]: []
        });
      }
      each(factory.makeAll(languageRules), (Validator2) => {
        Validators.value[lang].push(Validator2);
      });
    });
  };
  var reinitValidation = () => {
    initValidation();
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    isRequired,
    validate,
    validateLanguage,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initState,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var slider$1 = function slider(props, context, dependencies2) {
  var value = dependencies2.value;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    isRequired,
    errors,
    error,
    validationRules,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$E(props, context, dependencies2);
  var validate = function() {
    var _ref12 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      if (isArray_1(value.value)) {
        yield asyncForEach(value.value, function() {
          var _ref13 = _asyncToGenerator(function* (val) {
            yield asyncForEach(Validators.value, function() {
              var _ref14 = _asyncToGenerator(function* (Validator2) {
                yield Validator2.validate(val);
              });
              return function(_x7) {
                return _ref14.apply(this, arguments);
              };
            }());
            if (invalid.value) {
              return false;
            }
          });
          return function(_x6) {
            return _ref13.apply(this, arguments);
          };
        }());
      } else {
        yield asyncForEach(Validators.value, function() {
          var _ref15 = _asyncToGenerator(function* (Validator2) {
            yield Validator2.validate(value.value);
          });
          return function(_x8) {
            return _ref15.apply(this, arguments);
          };
        }());
      }
      state.value.validated = true;
    });
    return function validate2() {
      return _ref12.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    isRequired,
    errors,
    error,
    validationRules,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var file$1 = function file3(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var uploading = dependencies2.uploading;
  var removing = dependencies2.removing;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    isRequired,
    errors,
    error,
    validationRules,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$E(props, context, dependencies2);
  var busy = computed(() => {
    return pending.value || uploading.value || removing.value;
  });
  var validate = function() {
    var _ref16 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      var restricted = ["min", "max", "between", "size", "mimetypes", "mimes", "dimensions", "file", "image", "gt", "gte", "lt", "lte"];
      yield asyncForEach(Validators.value, function() {
        var _ref17 = _asyncToGenerator(function* (Validator2) {
          if (!(value.value instanceof File) && !!value.value && restricted.indexOf(Validator2.name) !== -1) {
            return;
          }
          yield Validator2.validate();
        });
        return function(_x9) {
          return _ref17.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref16.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    isRequired,
    errors,
    error,
    validationRules,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var location4 = function location5(props, context, dependencies2) {
  var {
    displayKey
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    isRequired,
    errors,
    error,
    validationRules,
    isSuccess,
    isDanger,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = text$2(props, context, dependencies2);
  var validate = function() {
    var _ref18 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref19 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate(value.value[displayKey.value]);
        });
        return function(_x10) {
          return _ref19.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref18.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    isRequired,
    errors,
    error,
    validationRules,
    isSuccess,
    isDanger,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var group$3 = list$1;
var object$3 = list$1;
var base$D = function base40(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (form$.value.options.default[name2.value] !== void 0) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : cloneDeep_1(parentDefaultValue);
    }
    if (default_.value !== void 0) {
      return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var text$1 = function text2(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var config$ = inject("config$");
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (typeof form$.value.options.default[name2.value] !== void 0) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : isPlainObject_1(parentDefaultValue) ? localize(cloneDeep_1(parentDefaultValue), config$.value, form$.value) : cloneDeep_1(parentDefaultValue);
    }
    if (default_.value !== void 0) {
      return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : isPlainObject_1(default_.value) ? localize(cloneDeep_1(default_.value), config$.value, form$.value) : cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var object$2 = function object5(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (form$.value.options.default[name2.value]) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return cloneDeep_1(merge_1({}, default_.value || /* istanbul ignore next: `default_.value` will never be undefined, because it is a hardwired `{}` */
      nullValue.value, parentDefaultValue));
    }
    if (Object.keys(default_.value).length > 0) {
      return cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var group$2 = function group4(props, context, dependencies2) {
  var {
    default: default_
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue = {};
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue;
    } else if (form$.value.options.default) {
      parentDefaultValue = form$.value.options.default;
    }
    return cloneDeep_1(merge_1({}, default_.value, parentDefaultValue));
  });
  return {
    defaultValue
  };
};
var multilingual$2 = function multilingual7(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (form$.value.options.default[name2.value]) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return cloneDeep_1(Object.assign({}, clone_1(nullValue.value), parentDefaultValue));
    }
    if (default_.value === void 0) {
      return clone_1(nullValue.value);
    }
    var def = clone_1(default_.value);
    if (!isPlainObject_1(def)) {
      var tempDefault = {};
      each(nullValue.value, (v, language) => {
        tempDefault[language] = def;
      });
      def = tempDefault;
    }
    return Object.assign({}, clone_1(nullValue.value), def);
  });
  return {
    defaultValue
  };
};
var base$C = function base41(props, context, dependencies2) {
  var {
    readonly
  } = toRefs(props);
  var {
    el$: el$2,
    form$,
    path
  } = dependencies2;
  var isReadonly = computed(() => {
    if (typeof readonly.value === "function") {
      return readonly.value(el$2.value, form$.value);
    }
    if (Array.isArray(readonly.value)) {
      return readonly.value.every((condition2) => {
        return form$.value.$vueform.services.condition.check(condition2, path.value, form$.value, el$2.value);
      });
    }
    if (typeof readonly.value === "object" && readonly.value && readonly.value.value !== void 0) {
      return readonly.value.value;
    }
    return readonly.value;
  });
  return {
    isReadonly
  };
};
function baseSortBy$1(array4, comparer) {
  var length = array4.length;
  array4.sort(comparer);
  while (length--) {
    array4[length] = array4[length].value;
  }
  return array4;
}
var _baseSortBy = baseSortBy$1;
var isSymbol = isSymbol_1;
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending$1;
var compareAscending = _compareAscending;
function compareMultiple$1(object9, other, orders) {
  var index2 = -1, objCriteria = object9.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order = orders[index2];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object9.index - other.index;
}
var _compareMultiple = compareMultiple$1;
var arrayMap = _arrayMap;
var baseGet = _baseGet;
var baseIteratee = _baseIteratee;
var baseMap = _baseMap;
var baseSortBy = _baseSortBy;
var baseUnary = _baseUnary;
var compareMultiple = _compareMultiple;
var identity = identity_1;
var isArray = isArray_1;
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }
  var index2 = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value, key, collection2) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object9, other) {
    return compareMultiple(object9, other, orders);
  });
}
var _baseOrderBy = baseOrderBy$1;
var baseFlatten = _baseFlatten;
var baseOrderBy = _baseOrderBy;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var sortBy_1 = sortBy;
var base$B = function base42(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    submit,
    formatData,
    formatLoad,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var resetValidators = dependencies2.resetValidators;
  var defaultValue = dependencies2.defaultValue;
  var nullValue = dependencies2.nullValue;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var data = computed(() => {
    return {
      [name2.value]: value.value
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    return formatData.value ? formatData.value(name2.value, value.value, form$.value) : {
      [name2.value]: value.value
    };
  });
  var load = function load2(val) {
    var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setValue(format && formatLoad.value ? formatLoad.value(val, form$.value) : val);
  };
  var update = (val) => {
    setValue(val);
  };
  var clear = () => {
    setValue(cloneDeep_1(nullValue.value));
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    setValue(cloneDeep_1(defaultValue.value));
    resetValidators();
  };
  var prepare = function() {
    var _ref = _asyncToGenerator(function* () {
    });
    return function prepare2() {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var text3 = function text4(props, context, dependencies2) {
  var {
    submit,
    formatData,
    name: name2,
    forceNumbers
  } = toRefs(props);
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var config$ = inject("config$");
  var data = computed(() => {
    var v = value.value;
    if (shouldForceNumbers()) {
      v = stringToNumber(value.value);
    }
    return {
      [name2.value]: v
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var v = value.value;
    if (shouldForceNumbers()) {
      v = stringToNumber(value.value);
    }
    return formatData.value ? formatData.value(name2.value, v, form$.value) : {
      [name2.value]: v
    };
  });
  var shouldForceNumbers = () => {
    return forceNumbers.value || config$.value.config.forceNumbers && form$.value.options.forceNumbers !== false && forceNumbers.value !== false || form$.value.options.forceNumbers && forceNumbers.value !== false;
  };
  var stringToNumber = (str) => {
    var v = str;
    if (typeof str === "string") {
      if (/^[-]?\d+([\.,]\d+)?$/.test(str)) {
        v = parseFloat(str.replace(",", "."));
      } else if (/^[-]?\d+$/.test(str)) {
        v = parseInt(str, 10);
      }
    }
    return v;
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var select$3 = function select2(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    resolveOnLoad,
    items
  } = toRefs(props);
  var {
    data,
    requestData,
    load,
    update,
    clear,
    prepare
  } = base$B(props, context, dependencies2);
  var value = dependencies2.value;
  var resetValidators = dependencies2.resetValidators;
  var defaultValue = dependencies2.defaultValue;
  var updateItems = dependencies2.updateItems;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    setValue(cloneDeep_1(defaultValue.value));
    resetValidators();
    if (typeof items.value === "string" && resolveOnLoad.value !== false) {
      updateItems();
    }
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var captcha2 = function captcha3(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear: clearBase,
    reset: resetBase,
    prepare
  } = base$B(props, context, dependencies2);
  var {
    Provider
  } = dependencies2;
  var clear = () => {
    clearBase();
    if (!Provider.value) {
      return;
    }
    Provider.value.reset();
  };
  var reset = () => {
    resetBase();
    if (!Provider.value) {
      return;
    }
    Provider.value.reset();
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var object$1 = function object6(props, context, dependencies2) {
  var {
    name: name2,
    formatLoad,
    formatData,
    submit
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var children$ = dependencies2.children$;
  var children$Array = dependencies2.children$Array;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var data = computed(() => {
    var data2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      data2 = Object.assign({}, data2, element$.data);
    });
    return {
      [name2.value]: data2
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, element$.requestData);
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  var load = function load2(val) {
    var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (!element$.flat && formatted[element$.name] === void 0) {
        element$.clear();
        return;
      }
      element$.load(element$.flat ? formatted : formatted[element$.name], format);
    });
  };
  var update = (val) => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (val[element$.name] === void 0 && !element$.flat) {
        return;
      }
      element$.update(element$.flat ? val : val[element$.name]);
    });
  };
  var clear = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clear();
    });
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.reset();
    });
  };
  var prepare = function() {
    var _ref2 = _asyncToGenerator(function* () {
      yield asyncForEach(children$Array.value, function() {
        var _ref3 = _asyncToGenerator(function* (e$) {
          if (e$.prepare) {
            yield e$.prepare();
          }
        });
        return function(_x) {
          return _ref3.apply(this, arguments);
        };
      }());
    });
    return function prepare2() {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var group$1 = function group5(props, context, dependencies2) {
  var {
    name: name2,
    formatData,
    submit
  } = toRefs(props);
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = object$1(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var available = dependencies2.available;
  dependencies2.value;
  var data = computed(() => {
    var data2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      data2 = Object.assign({}, data2, element$.data);
    });
    return data2;
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, element$.requestData);
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : requestData2;
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var list6 = function list7(props, context, dependencies2, options) {
  var {
    name: name2,
    storeOrder,
    formatLoad,
    formatData,
    order,
    submit,
    initial,
    default: default_
  } = toRefs(props);
  var {
    update,
    clear,
    data
  } = base$B(props, context, dependencies2);
  var el$2 = dependencies2.el$;
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var children$Array = dependencies2.children$Array;
  var available = dependencies2.available;
  var isDisabled = dependencies2.isDisabled;
  var value = dependencies2.value;
  var orderByName = dependencies2.orderByName;
  var refreshOrderStore = dependencies2.refreshOrderStore;
  var dataPath = dependencies2.dataPath;
  var parent2 = dependencies2.parent;
  var nullValue = dependencies2.nullValue;
  var defaultValue = dependencies2.defaultValue;
  var fire = dependencies2.fire;
  var resetValidators = dependencies2.resetValidators;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var initialValue = ref(get_1(form$.value.model, dataPath.value));
  var parentDefaultValue = computed(() => {
    return parent2 && parent2.value ? parent2.value.defaultValue[name2.value] : form$.value.options.default[name2.value];
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = [];
    each(children$.value, (element$) => {
      var val = element$.requestData[element$.name];
      if (val !== void 0) {
        requestData2.push(val);
      }
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  var length = computed(() => {
    return Object.keys(value.value || /* istanbul ignore next: failsafe only */
    {}).length;
  });
  var add = function add2() {
    var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    var focus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var newValue = storeOrder.value ? Object.assign({}, val || {}, {
      [storeOrder.value]: val ? val[storeOrder.value] : void 0
    }) : val;
    value.value = refreshOrderStore(value.value.concat([newValue]));
    var index2 = value.value.length - 1;
    fire("add", index2, newValue, value.value, el$2.value);
    if (focus) {
      nextTick(() => {
        children$Array.value[children$Array.value.length - 1].focus();
      });
    }
    return index2;
  };
  var remove = (index2) => {
    value.value = value.value.filter((v, i2) => i2 !== index2);
    refreshOrderStore(value.value);
    fire("remove", index2, value.value, el$2.value);
  };
  var load = function() {
    var _ref4 = _asyncToGenerator(function* (val) {
      var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var values2 = sortValue(format && formatLoad.value ? formatLoad.value(val, form$.value) : val);
      clear();
      yield nextTick();
      for (var i2 = 0; i2 < values2.length; i2++) {
        add();
      }
      yield nextTick();
      each(children$.value, (child$, i3) => {
        child$.load(values2[i3], format);
      });
    });
    return function load2(_x2) {
      return _ref4.apply(this, arguments);
    };
  }();
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    value.value = cloneDeep_1(defaultValue.value);
    resetValidators();
    if (!value.value.length && initial.value > 0) {
      for (var i2 = 0; i2 < initial.value; i2++) {
        add();
      }
      children$Array.value.forEach((child$) => {
        child$.reset();
      });
    }
    nextTick(() => {
      refreshOrderStore(value.value);
    });
  };
  var prepare = function() {
    var _ref5 = _asyncToGenerator(function* () {
      yield asyncForEach(children$Array.value, function() {
        var _ref6 = _asyncToGenerator(function* (e$) {
          if (e$.prepare) {
            yield e$.prepare();
          }
        });
        return function(_x3) {
          return _ref6.apply(this, arguments);
        };
      }());
    });
    return function prepare2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var sortValue = (val) => {
    if (!order.value && !orderByName.value || !val) {
      return val;
    }
    var desc = order.value && typeof order.value === "string" && order.value.toUpperCase() == "DESC";
    if (orderByName.value) {
      val = desc ? sortBy_1(val, orderByName.value).reverse() : sortBy_1(val, orderByName.value);
    } else if (order.value) {
      val = desc ? val.sort().reverse() : val.sort();
    }
    return val;
  };
  var handleAdd = () => {
    if (isDisabled.value) {
      return;
    }
    add(void 0, true);
  };
  var handleRemove = (index2) => {
    if (isDisabled.value) {
      return;
    }
    remove(index2);
  };
  if (initialValue.value === void 0 && parentDefaultValue.value === void 0 && default_.value === void 0) {
    if (initial.value > 0) {
      for (var i = 0; i < initial.value; i++) {
        add();
      }
    } else {
      value.value = nullValue.value;
    }
  } else if (initialValue.value === void 0) {
    value.value = defaultValue.value;
  }
  return {
    requestData,
    data,
    length,
    add,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  };
};
var date$2 = function date2(props, context, dependencies2) {
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var loadDateFormat = dependencies2.loadDateFormat;
  var moment = form$.value.$vueform.services.moment;
  var load = function load2(val) {
    var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    checkDateFormat(loadDateFormat.value, formatted, moment);
    value.value = formatted instanceof Date || !formatted ? formatted : moment(formatted, loadDateFormat.value).toDate();
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var dates$3 = function dates2(props, context, dependencies2) {
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var loadDateFormat = dependencies2.loadDateFormat;
  var moment = form$.value.$vueform.services.moment;
  var load = function load2(val) {
    var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    value.value = map_1(formatted, (v) => {
      checkDateFormat(loadDateFormat.value, v, moment);
      return v instanceof Date ? v : moment(v, loadDateFormat.value).toDate();
    });
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var multilingual$1 = function multilingual8(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2, options);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var language = dependencies2.language;
  var nullValue = dependencies2.nullValue;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var load = function load2(val) {
    var format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    if (!isPlainObject_1(formatted)) {
      throw new Error("Multilingual element requires an object to load");
    }
    setValue(Object.assign({}, clone_1(nullValue.value), formatted));
  };
  var update = (val) => {
    var updateValue = val;
    if (!isPlainObject_1(updateValue)) {
      updateValue = {
        [language.value]: val
      };
    }
    setValue(Object.assign({}, value.value, updateValue));
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var editor2 = function editor3(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2, {
    setValue: (val) => {
      value.value = val;
      nextTick(() => {
        var _input$value;
        (_input$value = input.value) === null || _input$value === void 0 || _input$value.update(val);
      });
    }
  });
  var input = dependencies2.input;
  var value = dependencies2.value;
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var teditor = function teditor2(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  } = multilingual$1(props, context, dependencies2, {
    setValue: (val) => {
      value.value = val;
      nextTick(() => {
        input.value.update(val[language.value]);
      });
    }
  });
  var input = dependencies2.input;
  var model = dependencies2.model;
  var value = dependencies2.value;
  var language = dependencies2.language;
  watch(language, () => {
    input.value.update(model.value);
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var file4 = function file5(props, context, dependencies2) {
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var {
    submit,
    formatData,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var data = computed(() => {
    var _v;
    var v = value.value;
    if (typeof v === "object" && (_v = v) !== null && _v !== void 0 && _v.__file__) {
      v = v instanceof File ? v : _objectSpread2$1({}, v);
      delete v.__file__;
    }
    return {
      [name2.value]: v
    };
  });
  var requestData = computed(() => {
    var _v2;
    if (!available.value || !submit.value) {
      return {};
    }
    var v = value.value;
    if (typeof v === "object" && (_v2 = v) !== null && _v2 !== void 0 && _v2.__file__) {
      v = v instanceof File ? v : _objectSpread2$1({}, v);
      delete v.__file__;
    }
    return formatData.value ? formatData.value(name2.value, v, form$.value) : {
      [name2.value]: v
    };
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var multifile$4 = function multifile(props, context, dependencies2) {
  var {
    length,
    add,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  } = list6(props, context, dependencies2);
  var {
    submit,
    formatData,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var children$ = dependencies2.children$;
  var data = computed(() => {
    var val = value.value;
    val = val.map((file6) => {
      if (typeof file6 === "object" && file6 !== null && file6 !== void 0 && file6.__file__) {
        var v = file6 instanceof File ? file6 : _objectSpread2$1({}, file6);
        delete v.__file__;
        return v;
      }
      return file6;
    });
    return {
      [name2.value]: val
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = [];
    each(children$.value, (element$) => {
      var val = element$.requestData[element$.name];
      if (val !== void 0) {
        var _val;
        if (typeof val === "object" && (_val = val) !== null && _val !== void 0 && _val.__file__) {
          var v = file4 instanceof File ? file4 : _objectSpread2$1({}, file4);
          delete v.__file__;
          val = v;
        }
        requestData2.push(val);
      }
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  return {
    requestData,
    data,
    length,
    add,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  };
};
var signature = function signature2(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear: clearBase,
    reset: resetBase
  } = base$B(props, context, dependencies2);
  var {
    mode,
    clearSignature,
    typingToImage,
    drawingToImage,
    uploaded,
    setDefaultMode,
    setDefaultFont,
    setDefaultColor
  } = dependencies2;
  var clear = () => {
    clearBase();
    clearSignature();
  };
  var reset = () => {
    clearSignature();
    setDefaultMode(true);
    setDefaultFont(true);
    setDefaultColor();
    resetBase();
  };
  var prepare = function() {
    var _ref7 = _asyncToGenerator(function* () {
      if (uploaded.value) {
        return;
      }
      if (mode.value === "type") {
        yield typingToImage();
      }
      if (mode.value === "draw") {
        yield drawingToImage();
      }
    });
    return function prepare2() {
      return _ref7.apply(this, arguments);
    };
  }();
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var multiselect$3 = select$3;
var tags$3 = select$3;
var HasChange = {
  props: {
    onChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  }
};
var HasData = {
  props: {
    formatData: {
      required: false,
      type: [Function],
      default: null
    },
    formatLoad: {
      required: false,
      type: [Function],
      default: null
    },
    submit: {
      required: false,
      type: [Boolean],
      default: true
    }
  }
};
var HasValidation = {
  props: {
    rules: {
      required: false,
      type: [Array, String, Object],
      default: null
    },
    messages: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    fieldName: {
      required: false,
      type: [String],
      "@default": "name|label"
    }
  }
};
var CaptchaElement = {
  name: "CaptchaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "captcha",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    default: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    rules: {
      required: false,
      type: [Array, String, Object],
      default: ["captcha"]
    },
    size: {
      required: false,
      type: [String],
      default: void 0,
      private: true
    },
    fieldName: {
      required: false,
      type: [String],
      "@default": "name|label",
      private: true
    },
    provider: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.useProviders.captcha"
    },
    options: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$H, base$1e, base$Q, base$T, base$C, base$D, base$16, base$E, base$I, base$M, base$F, base$J, captcha2, base$11, base$K, captcha$1, base$_, base$1c, base$10, base$Z, base$G, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$A = function base43(props, context, dependencies2) {
  var {
    text: text5
  } = toRefs(props);
  var config$ = inject("config$");
  var form$ = inject("form$");
  var Text = computed(() => {
    return localize(text5.value, config$.value, form$.value) || "";
  });
  return {
    Text
  };
};
var base$z = function base44(props, context, dependencies2) {
  var {
    trueValue,
    falseValue
  } = toRefs(props);
  var update = dependencies2.update;
  var check2 = () => {
    update(trueValue.value);
  };
  var uncheck = () => {
    update(falseValue.value);
  };
  return {
    check: check2,
    uncheck
  };
};
var checkbox2 = function checkbox3(props, context, dependencies2) {
  var {
    trueValue,
    falseValue
  } = toRefs(props);
  var update = dependencies2.update;
  var check2 = () => {
    update(trueValue.value);
  };
  var uncheck = () => {
    update(falseValue.value);
  };
  return {
    check: check2,
    uncheck
  };
};
var CheckboxElement = {
  name: "CheckboxElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "checkbox",
      private: true
    },
    default: {
      required: false,
      type: [String, Boolean, Number],
      default: void 0
      // falseValue
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    trueValue: {
      required: false,
      type: [Boolean, String, Number],
      default: true
    },
    falseValue: {
      required: false,
      type: [Boolean, String, Number],
      default: false
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, boolean, base$W, base$1e, base$Q, base$T, base$D, base$16, base$E, base$M, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, checkbox2, checkbox$1, base$G, base$V, base$A];
    context.slots = ["default", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$y = function base45(props, context, dependencies2) {
  var value = dependencies2.value;
  var resolvedOptions = dependencies2.resolvedOptions;
  var toggle3 = (val) => {
    if (value.value.indexOf(String(val)) === -1 && value.value.indexOf(Number(val)) === -1) {
      check2(val);
    } else {
      uncheck(val);
    }
  };
  var check2 = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var items = clone_1(value.value);
    each(values2, (item) => {
      if (items.indexOf(String(item)) === -1 && items.indexOf(Number(item)) === -1) {
        items.push(item);
      }
    });
    value.value = items;
  };
  var uncheck = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var items = clone_1(value.value);
    each(values2, (item) => {
      var index2 = items.indexOf(String(item));
      if (index2 === -1) {
        index2 = items.indexOf(Number(item));
      }
      if (index2 !== -1) {
        items.splice(index2, 1);
      }
    });
    value.value = items;
  };
  var checkAll = () => {
    check2(resolvedOptions.value.map((o2) => o2.value));
  };
  var uncheckAll = () => {
    uncheck(resolvedOptions.value.map((o2) => o2.value));
  };
  return {
    toggle: toggle3,
    check: check2,
    uncheck,
    checkAll,
    uncheckAll
  };
};
var base$x = function base46(props, context, dependencies2) {
  var {
    items,
    valueProp,
    labelProp,
    dataKey,
    searchParam,
    clearOnRefetch,
    object: object9
  } = toRefs(props);
  var isNative = dependencies2.isNative;
  var disable = dependencies2.disable;
  var enable = dependencies2.enable;
  var input = dependencies2.input;
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var path = dependencies2.path;
  var el$2 = dependencies2.el$;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var options = ref(null);
  var watchers = ref([]);
  var resolvedOptions = computed(() => {
    if (!isNative.value) {
      return options.value;
    }
    var nativeItems = [];
    each(options.value, (item, key) => {
      if ([null, void 0].indexOf(item) !== -1) {
        return;
      }
      if (Array.isArray(options.value) && typeof item === "object") {
        if (item[valueProp.value] === void 0) {
          console.warn("You must define `value` property for each option when using an array of objects options for select element");
        }
        nativeItems.push({
          value: item[valueProp.value],
          label: item[labelProp.value]
        });
      } else if (Array.isArray(options.value)) {
        nativeItems.push({
          value: item,
          label: item
        });
      } else {
        nativeItems.push({
          value: key,
          label: item
        });
      }
    });
    return nativeItems.map((o2) => {
      return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
        label: localize(o2.label, config$.value, form$.value)
      });
    });
  });
  var updateItems = function() {
    var _ref = _asyncToGenerator(function* () {
      var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!isNative.value) {
        var _input$value;
        if (typeof items.value === "string") {
          options.value = createAsyncOptionsFromUrl();
        }
        yield (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.resolveOptions();
        return;
      }
      if (shouldDisable) {
        disable();
      }
      if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else if (typeof items.value === "function") {
        yield resolveOptionsFromFunction();
      } else {
        options.value = items.value;
      }
      if (shouldDisable) {
        enable();
      }
    });
    return function updateItems2() {
      return _ref.apply(this, arguments);
    };
  }();
  var resolveOptionsFromUrl = function() {
    var _ref2 = _asyncToGenerator(function* () {
      try {
        var _yield$form$$value$$v;
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        var optionList = ((_yield$form$$value$$v = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v === void 0 ? void 0 : _yield$form$$value$$v.data) || [];
        if (dataKey && dataKey.value && Object.keys(optionList).length) {
          optionList = get_1(optionList, dataKey.value) || [];
        }
        options.value = optionList;
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from ".concat(items.value), e2);
      } finally {
        var _resolvedOptions$valu;
        cleanupValue(((_resolvedOptions$valu = resolvedOptions.value) === null || _resolvedOptions$valu === void 0 ? void 0 : _resolvedOptions$valu.map((o2) => o2.value)) || []);
      }
    });
    return function resolveOptionsFromUrl2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var createAsyncOptionsFromUrl = () => {
    return function() {
      var _ref3 = _asyncToGenerator(function* (query) {
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        var optionList;
        try {
          var _yield$form$$value$$v2;
          optionList = ((_yield$form$$value$$v2 = yield form$.value.$vueform.services.axios.get("".concat(url2).concat(url2.match(/\?/) ? "&" : "?").concat(searchParam.value, "=").concat(query || ""))) === null || _yield$form$$value$$v2 === void 0 ? void 0 : _yield$form$$value$$v2.data) || [];
          if (dataKey && dataKey.value && Object.keys(optionList).length) {
            optionList = get_1(optionList, dataKey.value) || [];
          }
        } catch (e2) {
          console.error(e2);
        } finally {
          setTimeout(() => {
            var _input$value2;
            cleanupValue(((_input$value2 = input.value) === null || _input$value2 === void 0 || (_input$value2 = _input$value2.eo) === null || _input$value2 === void 0 ? void 0 : _input$value2.map((o2) => o2[valueProp.value])) || []);
          }, 0);
        }
        return optionList;
      });
      return function(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  };
  var resolveOptionsFromFunction = function() {
    var _ref4 = _asyncToGenerator(function* () {
      try {
        options.value = (yield items.value(el$2.value)) || [];
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from async function", e2);
      }
    });
    return function resolveOptionsFromFunction2() {
      return _ref4.apply(this, arguments);
    };
  }();
  var resolveOptions = function() {
    var _ref5 = _asyncToGenerator(function* (n2, o2) {
      if (typeof items.value === "function" && isNative.value) {
        yield resolveOptionsFromFunction();
      } else if (!isEqual_1(n2, o2) || n2 === void 0 && o2 === void 0) {
        if (typeof items.value === "string" && isNative.value) {
          yield resolveOptionsFromUrl();
        } else if (typeof items.value === "string" && !isNative.value) {
          options.value = createAsyncOptionsFromUrl();
        } else {
          options.value = items.value;
        }
      }
    });
    return function resolveOptions2(_x2, _x3) {
      return _ref5.apply(this, arguments);
    };
  }();
  var cleanupValue = (values2) => {
    if (clearOnRefetch.value) {
      value.value = cloneDeep_1(nullValue.value);
      return;
    }
    if (!Array.isArray(nullValue.value) && value.value && values2.indexOf(object9.value ? value.value[valueProp.value] : value.value) === -1) {
      value.value = cloneDeep_1(nullValue.value);
    } else if (Array.isArray(nullValue.value) && value.value.length) {
      value.value = value.value.filter((v) => {
        return values2.indexOf(v) !== -1;
      });
    }
  };
  var resolveUrlAndSetWatchers = function() {
    var _ref6 = _asyncToGenerator(function* (url2, updateItems2) {
      var regex2 = /{([^}]+)}/g;
      var resolvedUrl = url2;
      if (url2.match(regex2)) {
        yield nextTick();
        watchers.value.forEach((unwatch) => unwatch());
        var match;
        var _loop = function* _loop2() {
          var _match$1$match;
          var defaultValue = ((_match$1$match = match[1].match(/\|'([^']+)/)) === null || _match$1$match === void 0 ? void 0 : _match$1$match[1]) || "";
          var elPath = replaceWildcards(match[1].match(/^([^|]+)/)[1], path.value);
          var el$3 = form$.value.el$(elPath);
          var elValue = typeof (el$3 === null || el$3 === void 0 ? void 0 : el$3.value) !== "undefined" && el$3.value !== null && typeof el$3.value === "object" ? JSON.stringify(el$3.value) : typeof (el$3 === null || el$3 === void 0 ? void 0 : el$3.value) !== "undefined" && el$3.value !== null ? el$3.value : defaultValue;
          resolvedUrl = resolvedUrl.replace(match[0], encodeURIComponent(elValue));
          watchers.value.push(watch(computed(() => el$3 === null || el$3 === void 0 ? void 0 : el$3.value), () => {
            updateItems2();
          }));
        };
        while ((match = regex2.exec(url2)) !== null) {
          yield* _loop();
        }
      }
      return resolvedUrl;
    });
    return function resolveUrlAndSetWatchers2(_x4, _x5) {
      return _ref6.apply(this, arguments);
    };
  }();
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var select$2 = function select3(props, context, dependencies2) {
  var {
    items
  } = toRefs(props);
  var {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  } = base$x(props, context, dependencies2);
  resolveOptions();
  watch(items, resolveOptions);
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var checkboxgroup3 = function checkboxgroup4(props, context, dependencies2) {
  var {
    items
  } = toRefs(props);
  var {
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  } = base$x(props, context, dependencies2);
  var disableAll = dependencies2.disableAll;
  var enableAll = dependencies2.enableAll;
  var el$2 = dependencies2.el$;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var options = ref(null);
  var resolvedOptions = computed(() => {
    var resolvedOptions2 = [];
    each(options.value, (item, key) => {
      if ([null, void 0].indexOf(item) !== -1) {
        return;
      }
      if (Array.isArray(options.value) && typeof item === "object") {
        if (item.value === void 0) {
          console.warn("You must define `value` property for each item when using an array of objects options");
        }
        resolvedOptions2.push(item);
      } else if (Array.isArray(options.value)) {
        resolvedOptions2.push({
          value: item,
          label: item
        });
      } else if (typeof item === "object") {
        resolvedOptions2.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, {
          value: key
        }));
      } else {
        resolvedOptions2.push({
          label: item,
          value: key
        });
      }
    });
    return resolvedOptions2.map((o2) => {
      return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
        label: localize(o2.label, config$.value, form$.value)
      });
    });
  });
  var updateItems = function() {
    var _ref7 = _asyncToGenerator(function* () {
      var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (shouldDisable) {
        disableAll();
      }
      if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else {
        yield resolveOptionsFromFunction();
      }
      if (shouldDisable) {
        enableAll();
      }
    });
    return function updateItems2() {
      return _ref7.apply(this, arguments);
    };
  }();
  var resolveOptionsFromUrl = function() {
    var _ref8 = _asyncToGenerator(function* () {
      try {
        var _yield$form$$value$$v3, _resolvedOptions$valu2;
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        options.value = ((_yield$form$$value$$v3 = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v3 === void 0 ? void 0 : _yield$form$$value$$v3.data) || [];
        cleanupValue(((_resolvedOptions$valu2 = resolvedOptions.value) === null || _resolvedOptions$valu2 === void 0 ? void 0 : _resolvedOptions$valu2.map((o2) => o2.value)) || []);
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from ".concat(items.value), e2);
      }
    });
    return function resolveOptionsFromUrl2() {
      return _ref8.apply(this, arguments);
    };
  }();
  var resolveOptionsFromFunction = function() {
    var _ref9 = _asyncToGenerator(function* () {
      try {
        options.value = (yield items.value(el$2.value)) || [];
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from async function", e2);
      }
    });
    return function resolveOptionsFromFunction2() {
      return _ref9.apply(this, arguments);
    };
  }();
  var resolveOptions = function() {
    var _ref10 = _asyncToGenerator(function* () {
      if (typeof items.value === "function") {
        yield resolveOptionsFromFunction();
      } else if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else {
        options.value = items.value;
      }
    });
    return function resolveOptions2() {
      return _ref10.apply(this, arguments);
    };
  }();
  resolveOptions();
  watch(items, resolveOptions);
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var radiogroup = checkboxgroup3;
var multiselect$2 = select$2;
var tags$2 = select$2;
var CheckboxgroupElement = {
  name: "CheckboxgroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "checkboxgroup",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$P, array$1, base$W, base$1e, checkboxgroup$1, checkboxgroup$3, base$D, base$M, checkboxgroup3, base$16, base$E, base$y, base$B, base$11, base$K, base$10, base$$, base$_, base$1c, base$Z, checkboxgroup$2, base$G, base$V];
    context.slots = ["checkbox", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$w = function base47(props, context, dependencies2) {
  var {
    addons,
    slots
  } = toRefs(props);
  var el$2 = dependencies2.el$;
  var form$ = dependencies2.form$;
  var hasAddonBefore = computed(() => {
    var _el$$value$$slots, _el$$value$$scopedSlo;
    return !!(addons.value.before || (_el$$value$$slots = el$2.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-before"] || /* istanbul ignore next */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-before"] || slots.value["addon-before"]);
  });
  var hasAddonAfter = computed(() => {
    var _el$$value$$slots2, _el$$value$$scopedSlo2;
    return !!(addons.value.after || (_el$$value$$slots2 = el$2.value.$slots) !== null && _el$$value$$slots2 !== void 0 && _el$$value$$slots2["addon-after"] || /* istanbul ignore next */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo2 = el$2.value.$scopedSlots) !== null && _el$$value$$scopedSlo2 !== void 0 && _el$$value$$scopedSlo2["addon-after"] || slots.value["addon-after"]);
  });
  return {
    hasAddonBefore,
    hasAddonAfter
  };
};
var base$v = function base48(props, context, dependencies2) {
  var {
    displayFormat,
    valueFormat,
    loadFormat,
    date: date6,
    time: time2,
    seconds,
    hour24
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var defaultFormat = computed(() => {
    var format;
    if (date6.value && time2.value && seconds.value && hour24.value) {
      format = "datetimeSeconds24";
    } else if (date6.value && time2.value && seconds.value && !hour24.value) {
      format = "datetimeSeconds12";
    } else if (date6.value && time2.value && !seconds.value && hour24.value) {
      format = "datetime24";
    } else if (date6.value && time2.value && !seconds.value && !hour24.value) {
      format = "datetime12";
    } else if (!date6.value && time2.value && seconds.value && hour24.value) {
      format = "timeSeconds24";
    } else if (!date6.value && time2.value && seconds.value && !hour24.value) {
      format = "timeSeconds12";
    } else if (!date6.value && time2.value && !seconds.value && hour24.value) {
      format = "time24";
    } else if (!date6.value && time2.value && !seconds.value && !hour24.value) {
      format = "time12";
    } else {
      format = "date";
    }
    return format;
  });
  var defaultDisplayFormat = computed(() => {
    return form$.value.translations.vueform.dateFormats[defaultFormat.value];
  });
  var defaultDataFormat = computed(() => {
    var dataDateFormats = {
      datetimeSeconds24: "YYYY-MM-DD HH:mm:ss",
      datetimeSeconds12: "YYYY-MM-DD hh:mm:ss a",
      datetime24: "YYYY-MM-DD HH:mm",
      datetime12: "YYYY-MM-DD hh:mm a",
      timeSeconds24: "HH:mm:ss",
      timeSeconds12: "hh:mm:ss a",
      time24: "HH:mm",
      time12: "hh:mm a",
      date: "YYYY-MM-DD"
    };
    return dataDateFormats[defaultFormat.value];
  });
  var displayDateFormat = computed(() => {
    return displayFormat.value !== null ? displayFormat.value : defaultDisplayFormat.value;
  });
  var valueDateFormat = computed(() => {
    return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultDataFormat.value;
  });
  var loadDateFormat = computed(() => {
    return loadFormat.value !== null ? loadFormat.value : defaultDataFormat.value;
  });
  return {
    displayDateFormat,
    valueDateFormat,
    loadDateFormat
  };
};
var dates$2 = function dates3(props, context, dependencies2) {
  var {
    displayFormat,
    valueFormat,
    loadFormat
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var defaultFormat = computed(() => {
    return form$.value.translations.vueform.dateFormats.date;
  });
  var displayDateFormat = computed(() => {
    return displayFormat.value !== null ? displayFormat.value : defaultFormat.value;
  });
  var valueDateFormat = computed(() => {
    return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultFormat.value;
  });
  var loadDateFormat = computed(() => {
    return loadFormat.value !== null ? loadFormat.value : defaultFormat.value;
  });
  return {
    displayDateFormat,
    valueDateFormat,
    loadDateFormat
  };
};
var base$u = function base49(props, context, dependencies2) {
  var value = dependencies2.value;
  var handleChange = (val) => {
    value.value = val;
  };
  return {
    handleChange
  };
};
var base$t = function base50(props, context, dependencies2) {
  var {
    placeholder
  } = toRefs(props);
  var {
    el$: el$2
  } = dependencies2;
  var config$ = inject("config$");
  var form$ = inject("form$");
  var Placeholder = computed(() => {
    var _form$$value$options$;
    var Placeholder2 = localize(placeholder.value, config$.value, form$.value);
    if (el$2.value.isRequired && ((_form$$value$options$ = form$.value.options.showRequired) === null || _form$$value$options$ === void 0 ? void 0 : _form$$value$options$.indexOf("placeholder")) !== -1) {
      Placeholder2 += "*";
    }
    return Placeholder2;
  });
  return {
    Placeholder
  };
};
var date$1 = function date3(props, context, dependencies2) {
  var {
    disables,
    min: min3,
    max: max2,
    extendOptions,
    readonly,
    hour24,
    seconds,
    date: date6,
    time: time2
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var displayDateFormat = dependencies2.displayDateFormat;
  var valueDateFormat = dependencies2.valueDateFormat;
  var form$ = dependencies2.form$;
  var moment = form$.value.$vueform.services.moment;
  var disabledDates = computed(() => {
    if (disables.value === void 0) {
      return [];
    }
    return map_1(disables.value, (disabledDate) => {
      checkDateFormat(valueDateFormat.value, disabledDate, moment);
      return disabledDate instanceof Date ? disabledDate : moment(disabledDate, valueDateFormat.value, true).toDate();
    });
  });
  var minDate = computed(() => {
    if (!min3.value) {
      return null;
    }
    checkDateFormat(valueDateFormat.value, min3.value, moment);
    return min3.value instanceof Date ? min3.value : moment(min3.value, valueDateFormat.value, true).toDate();
  });
  var maxDate = computed(() => {
    if (!max2.value) {
      return null;
    }
    checkDateFormat(valueDateFormat.value, max2.value, moment);
    return max2.value instanceof Date ? max2.value : moment(max2.value, valueDateFormat.value, true).toDate();
  });
  var defaultOptions = computed(() => {
    return {
      dateFormat: displayDateFormat.value,
      minDate: minDate.value,
      maxDate: maxDate.value,
      disable: disabledDates.value,
      clickOpens: !isDisabled.value && !readonly.value,
      time_24hr: hour24.value,
      enableTime: time2.value,
      enableSeconds: seconds.value,
      noCalendar: !date6.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  var hasDate = computed(() => {
    return true;
  });
  var hasTime = computed(() => {
    return false;
  });
  return {
    minDate,
    maxDate,
    disabledDates,
    fieldOptions,
    hasDate,
    hasTime
  };
};
var dates$1 = function dates4(props, context, dependencies2) {
  var {
    mode,
    extendOptions,
    readonly
  } = toRefs(props);
  var {
    minDate,
    maxDate,
    disabledDates
  } = date$1(props, context, dependencies2);
  var isDisabled = dependencies2.isDisabled;
  var displayDateFormat = dependencies2.displayDateFormat;
  var defaultOptions = computed(() => {
    return {
      mode: mode.value,
      dateFormat: displayDateFormat.value,
      minDate: minDate.value,
      maxDate: maxDate.value,
      disable: disabledDates.value,
      clickOpens: !isDisabled.value && !readonly.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  var hasDate = computed(() => {
    return true;
  });
  var hasTime = computed(() => {
    return false;
  });
  return {
    minDate,
    maxDate,
    disabledDates,
    fieldOptions,
    hasDate,
    hasTime
  };
};
var select$1 = function select4(props, context, dependencies2) {
  var {
    native,
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    canDeselect,
    canClear,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    inputType,
    create,
    appendNewOption,
    addOptionOn,
    appendTo,
    appendToBody,
    allowAbsent
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var isNative = computed(() => {
    return native.value && !search.value;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "single",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      canDeselect: canDeselect.value,
      canClear: canClear.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      inputType: inputType.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value,
      allowAbsent: allowAbsent.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions,
    isNative
  };
};
var multiselect$1 = function multiselect(props, context, dependencies2) {
  var {
    native,
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    clearOnSelect,
    canClear,
    max: max2,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    groupSelect,
    inputType,
    hideSelected,
    multipleLabel,
    multipleLabelMultiple,
    multipleLabelSingle,
    create,
    appendNewOption,
    addOptionOn,
    appendTo,
    appendToBody,
    allowAbsent
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var isNative = computed(() => {
    return native.value && !search.value;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "multiple",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      multipleLabel: multipleLabel.value || ((val, select$) => {
        return val && val.length > 1 ? multipleLabelMultiple.value ? multipleLabelMultiple.value.replace(":x:", val.length) : form$.value.__(form$.value.translations.vueform.multiselect.multipleLabelMore, {
          options: val.length
        }) : multipleLabelSingle.value || form$.value.translations.vueform.multiselect.multipleLabelOne;
      }),
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      clearOnSelect: clearOnSelect.value,
      canClear: canClear.value,
      max: max2.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      groupSelect: groupSelect.value,
      inputType: inputType.value,
      hideSelected: hideSelected.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value,
      allowAbsent: allowAbsent.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions,
    isNative
  };
};
var tags$1 = function tags(props, context, dependencies2) {
  var {
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    clearOnSelect,
    canClear,
    max: max2,
    showOptions,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    groupSelect,
    inputType,
    hideSelected,
    create,
    appendNewOption,
    addOptionOn,
    breakTags,
    appendTo,
    appendToBody,
    allowAbsent
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var native = ref(false);
  var isNative = computed(() => {
    return false;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "tags",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      clearOnSelect: clearOnSelect.value,
      canClear: canClear.value,
      max: max2.value,
      showOptions: showOptions.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      groupSelect: groupSelect.value,
      inputType: inputType.value,
      hideSelected: hideSelected.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      breakTags: breakTags.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value,
      allowAbsent: allowAbsent.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    native,
    fieldOptions,
    isNative
  };
};
var slider2 = function slider3(props, context, dependencies2) {
  var {
    min: min3,
    max: max2,
    step,
    tooltips,
    merge: merge2,
    format,
    orientation,
    direction,
    extendOptions,
    showTooltip,
    tooltipPosition,
    lazy
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  dependencies2.labelId;
  var defaultOptions = computed(() => {
    return {
      min: min3.value,
      max: max2.value,
      step: step.value,
      tooltips: tooltips.value,
      merge: merge2.value,
      format: format.value,
      orientation: orientation.value,
      direction: direction.value,
      disabled: isDisabled.value,
      showTooltip: showTooltip.value,
      tooltipPosition: tooltipPosition.value,
      lazy: lazy.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions
  };
};
var toggle = function toggle2(props, context, dependencies2) {
  var {
    labels,
    extendOptions,
    trueValue,
    falseValue
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var defaultOptions = computed(() => {
    return {
      disabled: isDisabled.value,
      offLabel: labels.value ? localize(labels.value.off, config$.value, form$.value) || "" : (
        /* istanbul ignore next: default is hardcoded {}, will never fall there */
        ""
      ),
      onLabel: labels.value ? localize(labels.value.on, config$.value, form$.value) || "" : (
        /* istanbul ignore next: default is hardcoded {}, will never fall there */
        ""
      ),
      trueValue: trueValue.value,
      falseValue: falseValue.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions
  };
};
var base$s = function base51(props, context, dependencies2) {
  var input = dependencies2.input;
  var focused = ref(false);
  onMounted(() => {
    if (input && input.value && input.value.addEventListener) {
      input.value.addEventListener("focus", () => {
        focused.value = true;
      });
      input.value.addEventListener("blur", () => {
        focused.value = false;
      });
    }
  });
  return {
    focused
  };
};
var date4 = function date5(props, context, dependencies2) {
  var input = dependencies2.input;
  var focused = ref(false);
  onMounted(() => {
    input.value.input.addEventListener("focus", () => {
      focused.value = true;
    });
    input.value.input.addEventListener("blur", () => {
      focused.value = false;
    });
  });
  return {
    focused
  };
};
var select5 = function select6(props, context, dependencies2) {
  var input = dependencies2.input;
  var isNative = dependencies2.isNative;
  var focused = ref(false);
  onMounted(() => {
    if (isNative.value) {
      input.value.addEventListener("focus", () => {
        focused.value = true;
      });
      input.value.addEventListener("blur", () => {
        focused.value = false;
      });
    } else {
      watch(computed(() => {
        var _input$value;
        return (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.isActive;
      }), (active) => {
        focused.value = active;
      });
    }
  });
  return {
    focused
  };
};
var dates5 = date4;
var multiselect2 = select5;
var tags2 = select5;
var DateElement = {
  name: "DateElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "date",
      private: true
    },
    default: {
      required: false,
      type: [String, Date],
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    displayFormat: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    valueFormat: {
      required: false,
      type: [String, Boolean],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    loadFormat: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    date: {
      required: false,
      type: [Boolean],
      default: true
    },
    time: {
      required: false,
      type: [Boolean],
      default: false
    },
    seconds: {
      required: false,
      type: [Boolean],
      default: false
    },
    hour24: {
      required: false,
      type: [Boolean],
      default: true
    },
    min: {
      required: false,
      type: [String, Date],
      default: null
    },
    max: {
      required: false,
      type: [String, Date],
      default: null
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$H, base$1e, base$Q, base$T, base$C, base$w, base$v, date$1, base$D, base$16, base$E, date$3, base$J, date$2, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$u, date4, base$S, base$G, base$V, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var DatesElement = {
  name: "DatesElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "dates",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    displayFormat: {
      required: false,
      type: [String],
      default: null
    },
    valueFormat: {
      required: false,
      type: [String, Boolean],
      default: null
    },
    loadFormat: {
      required: false,
      type: [String, Boolean],
      default: null
    },
    mode: {
      required: false,
      type: [String],
      default: "multiple"
    },
    min: {
      required: false,
      type: [String, Date],
      default: null
    },
    max: {
      required: false,
      type: [String, Date],
      default: null
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, array$1, base$W, base$H, base$1e, dates$5, base$T, base$C, base$w, dates$2, dates$1, base$D, dates$4, base$16, base$E, base$J, dates$3, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$u, dates5, base$S, base$G, base$V, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$r = function base52(props, context, dependencies2) {
  var {
    embed,
    auto,
    methods,
    urls,
    uploadTempEndpoint,
    removeTempEndpoint,
    removeEndpoint,
    url: url2,
    previewUrl,
    params,
    softRemove,
    view
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var isDisabled = dependencies2.isDisabled;
  var validate = dependencies2.validate;
  var invalid = dependencies2.invalid;
  var path = dependencies2.path;
  var axios = dependencies2.axios;
  var request = dependencies2.request;
  var uploading = dependencies2.uploading;
  var input = dependencies2.input;
  var update = dependencies2.update;
  var fire = dependencies2.fire;
  dependencies2.isImageType;
  var removing = dependencies2.removing;
  var handleError = dependencies2.handleError;
  var el$2 = dependencies2.el$;
  var hasUploadError = ref(false);
  var progress = ref(0);
  var preparing = ref(false);
  var endpoints = computed(() => {
    var configEndpoints = form$.value.$vueform.config.endpoints;
    var propEndpoints = {
      uploadTempFile: uploadTempEndpoint.value,
      removeTempFile: removeTempEndpoint.value,
      removeFile: removeEndpoint.value
    };
    var endpoints2 = {};
    Object.keys(propEndpoints).forEach((name2) => {
      var endpoint = configEndpoints[name2];
      if (endpoint === false) {
        endpoint = (f) => f;
      }
      if (urls.value[name2]) {
        endpoint = {
          url: urls.value[name2],
          method: "POST"
        };
      }
      if (methods.value[name2] && typeof endpoint === "object") {
        endpoint.method = methods.value[name2];
      }
      if (typeof propEndpoints[name2] === "string") {
        if (configEndpoints[propEndpoints[name2]] !== void 0) {
          endpoint = configEndpoints[propEndpoints[name2]];
        } else {
          endpoint.url = propEndpoints[name2];
        }
      }
      if (propEndpoints[name2] === false) {
        endpoint = (f) => f;
      }
      if (typeof propEndpoints[name2] === "function") {
        endpoint = propEndpoints[name2];
      }
      if (typeof propEndpoints[name2] === "object") {
        endpoint = {
          url: propEndpoints[name2].url || propEndpoints[name2].endpoint || configEndpoints[name2].url,
          method: propEndpoints[name2].method || configEndpoints[name2].method
        };
      }
      endpoints2[name2] = endpoint;
    });
    return endpoints2;
  });
  var fileUrl = computed(() => {
    if (url2.value === void 0) {
      return "/";
    }
    if (url2.value === false) {
      return "";
    }
    var fileUrl2 = url2.value;
    if (!fileUrl2.match(/\/$/)) {
      fileUrl2 += "/";
    }
    if (!fileUrl2.match(/^(http|file)/) && !fileUrl2.match(/^\//)) {
      fileUrl2 = "/" + fileUrl2;
    }
    return fileUrl2;
  });
  var filePreviewUrl = computed(() => {
    if (previewUrl.value === void 0) {
      return fileUrl.value;
    }
    var filePreviewUrl2 = previewUrl.value;
    if (!filePreviewUrl2.match(/\/$/)) {
      filePreviewUrl2 += "/";
    }
    if (!filePreviewUrl2.match(/^http/) && !filePreviewUrl2.match(/^\//)) {
      filePreviewUrl2 = "/" + filePreviewUrl2;
    }
    return filePreviewUrl2;
  });
  var stage = computed(() => {
    if (value.value === null) {
      return 0;
    }
    if (value.value instanceof File) {
      return 1;
    }
    if (isObject_1(value.value) && value.value.tmp !== void 0) {
      return 2;
    }
    if (isString_1(value.value)) {
      return 3;
    }
    return -1;
  });
  var filename = computed(() => {
    switch (stage.value) {
      case 1:
        return value.value.name;
      case 2:
        return value.value.originalName;
      case 3:
        return value.value;
      default:
        return null;
    }
  });
  var link = computed(() => {
    if (!uploaded.value) {
      return;
    }
    return fileUrl.value + filename.value;
  });
  var previewLink = computed(() => {
    if (!uploaded.value) {
      return;
    }
    return filePreviewUrl.value + filename.value;
  });
  var preview = computed(() => {
    var _value$value;
    if (view.value === "file") {
      return null;
    }
    return uploaded.value ? previewLink.value : value.value instanceof File ? URL.createObjectURL(value.value) : ((_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.__file__) instanceof File ? URL.createObjectURL(value.value.__file__) : null;
  });
  var uploaded = computed(() => {
    return stage.value === 3;
  });
  var canRemove = computed(() => {
    return stage.value > 0 && !uploading.value && !isDisabled.value && !preparing.value && !removing.value;
  });
  var canUploadTemp = computed(() => {
    return stage.value === 1 && !auto.value && !uploading.value && !isDisabled.value;
  });
  var canSelect = computed(() => {
    return !embed.value && stage.value == 0;
  });
  var uploadTemp = function() {
    var _ref = _asyncToGenerator(function* () {
      if (stage.value !== 1) {
        throw new Error("No file is selected");
      }
      yield validate();
      if (invalid.value) {
        return;
      }
      request.value = axios.value.CancelToken.source();
      try {
        var data = _getFormData(Object.assign({}, params.value, {
          file: value.value,
          formKey: form$.value.options.formKey,
          path: path.value
        }));
        hasUploadError.value = false;
        var response;
        if (typeof endpoints.value.uploadTempFile === "function") {
          response = yield endpoints.value.uploadTempFile(value.value, el$2.value);
        } else {
          var method = endpoints.value.uploadTempFile.method.toLowerCase();
          response = yield axios.value.request({
            url: endpoints.value.uploadTempFile.url,
            method,
            [method === "get" ? "params" : "data"]: data,
            onUploadProgress: (e2) => {
              progress.value = Math.round(e2.loaded * 100 / e2.total);
            },
            cancelToken: request.value.token
          });
          response = response.data;
        }
        if (response && typeof response === "object") {
          response.__file__ = value.value;
        }
        update(response);
      } catch (error) {
        progress.value = 0;
        if (!axios.value.isCancel(error)) {
          hasUploadError.value = true;
          handleError(error);
        }
        throw new Error(error);
      } finally {
        request.value = null;
      }
    });
    return function uploadTemp2() {
      return _ref.apply(this, arguments);
    };
  }();
  var remove = function() {
    var _ref2 = _asyncToGenerator(function* () {
      removing.value = true;
      hasUploadError.value = false;
      try {
        if (stage.value === 3 && !softRemove.value) {
          if (!confirm(form$.value.translations.vueform.elements.file.removeConfirm)) {
            return false;
          }
          if (typeof endpoints.value.removeFile === "function") {
            yield endpoints.value.removeFile(value.value, el$2.value);
          } else {
            var method = endpoints.value.removeFile.method.toLowerCase();
            yield axios.value.request({
              method,
              url: endpoints.value.removeFile.url,
              [method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                file: value.value,
                formKey: form$.value.options.formKey,
                path: path.value
              })
            });
          }
        } else if (stage.value === 2 && !softRemove.value) {
          if (typeof endpoints.value.removeTempFile === "function") {
            yield endpoints.value.removeTempFile(value.value, el$2.value);
          } else {
            var _method = endpoints.value.removeTempFile.method.toLowerCase();
            yield axios.value.request({
              method: _method,
              url: endpoints.value.removeTempFile.url,
              [_method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                file: value.value.tmp,
                formKey: form$.value.options.formKey,
                path: path.value
              })
            });
          }
        }
      } catch (error) {
        handleError(error);
        return;
      } finally {
        removing.value = false;
      }
      update(null);
      progress.value = 0;
      fire("remove");
    });
    return function remove2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var prepare = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (stage.value === 1) {
        preparing.value = true;
        try {
          yield uploadTemp();
        } finally {
          preparing.value = false;
        }
      }
    });
    return function prepare2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var handleChange = function() {
    var _ref4 = _asyncToGenerator(function* (e2) {
      var file6 = e2.target.files[0];
      input.value.value = "";
      update(file6 || null);
      if (auto.value) {
        yield uploadTemp();
      }
      if (form$.value.shouldValidateOnChange) {
        validate();
      }
    });
    return function handleChange2(_x) {
      return _ref4.apply(this, arguments);
    };
  }();
  var handleClick = () => {
    if (isDisabled.value) {
      return;
    }
    input.value.click();
  };
  var handleUploadTemp = () => {
    uploadTemp();
  };
  var handleRemove = () => {
    remove();
  };
  var handleAbort = () => {
    if (request.value === null) {
      return;
    }
    request.value.cancel();
  };
  if (value.value instanceof File && auto.value) {
    nextTick(() => {
      uploadTemp();
    });
  }
  return {
    hasUploadError,
    progress,
    preparing,
    endpoints,
    fileUrl,
    stage,
    filename,
    link,
    preview,
    uploaded,
    canRemove,
    canUploadTemp,
    canSelect,
    uploadTemp,
    remove,
    prepare,
    handleChange,
    handleClick,
    handleUploadTemp,
    handleRemove,
    handleAbort
  };
};
var base$q = function base53(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var request = ref(null);
  var axios = ref(null);
  var uploading = computed(() => {
    return request.value !== null;
  });
  onMounted(() => {
    axios.value = form$.value.$vueform.services.axios;
  });
  return {
    request,
    axios,
    uploading
  };
};
function checkFileType(file6, accept) {
  if (!accept) {
    return true;
  }
  if (!isArray_1(accept)) {
    accept = accept.split(",");
    each(accept, (one, i) => {
      accept[i] = one.trim();
    });
  }
  return some_1(accept, (a) => {
    var universal = a.match(/^([^\/]+)\/\*$/);
    if (universal) {
      return !!new RegExp("^".concat(universal[1], "/")).exec(file6.type);
    } else if (a == file6.type) {
      return true;
    } else if (a == ".".concat(file6.name.split(".").pop())) {
      return true;
    }
    return false;
  });
}
var base$p = function base54(props, context, dependencies2) {
  var {
    accept,
    auto
  } = toRefs(props);
  var update = dependencies2.update;
  var isDisabled = dependencies2.isDisabled;
  var uploadTemp = dependencies2.uploadTemp;
  var canDrop = computed(() => {
    var div = document.createElement("div");
    return ("draggable" in div || /* istanbul ignore next: failsafe only, can not influence div from outside */
    "ondragstart" in div && "ondrop" in div) && "FormData" in window && "FileReader" in window;
  });
  var handleDrop = (e2) => {
    if (isDisabled.value) {
      return;
    }
    var file6 = e2.dataTransfer.files[0];
    if (!checkFileType(file6, accept.value)) {
      return;
    }
    update(file6 || /* istanbul ignore next: failsafe only */
    null);
    if (auto.value) {
      uploadTemp();
    }
    file6.value = null;
  };
  return {
    canDrop,
    handleDrop
  };
};
var multifile$3 = function multifile2(props, context, dependencies2) {
  var {
    accept
  } = toRefs(props);
  var {
    canDrop
  } = base$p(props, context, dependencies2);
  var add = dependencies2.add;
  var isDisabled = dependencies2.isDisabled;
  var isObject2 = dependencies2.isObject;
  var storeFileName = dependencies2.storeFileName;
  var handleDrop = (e2) => {
    if (!e2.dataTransfer || !e2.dataTransfer.files || e2.dataTransfer.files.length == 0 || isDisabled.value) {
      return;
    }
    each(e2.dataTransfer.files, (file6) => {
      if (!checkFileType(file6, accept.value)) {
        return;
      }
      add(isObject2.value ? {
        [storeFileName.value]: file6
      } : file6);
    });
  };
  return {
    canDrop,
    handleDrop
  };
};
var base$o = function base55(props, context, dependencies2) {
  var removing = ref(false);
  return {
    removing
  };
};
var base$n = function base56(props, context, dependencies2) {
  var fire = dependencies2.fire;
  dependencies2.listeners;
  var handleError = (error) => {
    fire("error", error);
  };
  return {
    handleError
  };
};
var FileElement = {
  name: "FileElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "remove", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "file",
      private: true
    },
    default: {
      required: false,
      type: [String, Object],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    view: {
      type: [String],
      required: false,
      default: "file"
    },
    drop: {
      required: false,
      type: [Boolean],
      default: false
    },
    accept: {
      required: false,
      type: [String, Array],
      default: null
    },
    clickable: {
      required: false,
      type: [Boolean],
      default: true
    },
    url: {
      required: false,
      type: [String, Boolean],
      default: "/"
    },
    previewUrl: {
      required: false,
      type: [String],
      default: void 0
    },
    auto: {
      required: false,
      type: [Boolean],
      default: true
    },
    urls: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    methods: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    uploadTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.uploadTempFile"
    },
    removeTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeTempFile"
    },
    removeEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeFile"
    },
    params: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    softRemove: {
      required: false,
      type: [Boolean],
      default: false
    },
    embed: {
      type: [Boolean],
      required: false,
      default: false,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$o, base$W, base$1e, file$3, base$T, base$q, base$D, base$16, base$M, file$1, base$J, file4, base$n, base$r, base$p, base$11, file$2, base$$, base$_, base$1c, base$10, base$Z, file$4, base$G, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$m = function base57(props, context, dependencies2) {
  var model = dependencies2.model;
  var handleInput = (e2) => {
    model.value = e2.target.value;
  };
  return {
    handleInput
  };
};
var phone$1 = function phone2(props, context, dependencies2) {
  var {
    model,
    input,
    el$: el$2
  } = dependencies2;
  var handleInput = (e2) => {
    if (el$2.value.maskPluginInstalled) {
      model.value = e2.target.value;
      return;
    }
    var startsWithPlus = e2.target.value.startsWith("+");
    var value = e2.target.value.substr(startsWithPlus ? 1 : 0);
    var numbers = value.match(/\d+/g) || [];
    if (numbers.length || startsWithPlus) {
      value = "+";
    }
    value += numbers.join("");
    input.value.value = value;
    model.value = value;
  };
  return {
    handleInput
  };
};
var GenericElement = {
  register: false,
  name: "GenericElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: void 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, generic, base$W, base$1e, base$Q, base$T, text$1, base$16, text$2, base$M, base$J, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$m, base$s, base$S, base$G, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$l = function base58(props, context, dependencies2) {
  var children$Array = ref([]);
  var children$ = computed(() => {
    var children$2 = {};
    children$Array.value.forEach((e$) => {
      children$2[e$.name] = e$;
    });
    return children$2;
  });
  return {
    children$Array,
    children$
  };
};
var object7 = function object8(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var schemaName = options.schemaName || "schema";
  var {
    [schemaName]: schema
  } = toRefs(props);
  var {
    children$Array,
    children$
  } = base$l();
  var children = computed(() => {
    return schema.value;
  });
  if (schema) {
    watch(schema, (newValue) => {
      var newChildren$Array = [];
      each(newValue, (child, name2) => {
        var child$ = children$Array.value[children$Array.value.map((e$) => normalize(e$.name)).indexOf(normalize(name2))];
        if (child$) {
          newChildren$Array.push(child$);
        }
      });
      children$Array.value = newChildren$Array;
    }, {
      flush: "post",
      deep: true
    });
  }
  return {
    children,
    children$Array,
    children$
  };
};
var group6 = object7;
var GroupElement = {
  name: "GroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "group",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    schema: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, group$6, base$W, object$5, base$1e, group$7, group6, group$2, base$11, group$3, group$5, base$14, group$8, base$$, base$_, base$1c, base$10, base$Z, group$1, base$S, group$4, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var HiddenElement = {
  name: "HiddenElement",
  mixins: [BaseElement, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "hidden",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    meta: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$N, base$P, base$L, base$K, base$W, base$_, base$1e, base$Q, base$D, base$16, base$E, base$M, base$J, base$B, base$G, base$V];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
function ownKeys(object9, enumerableOnly) {
  var keys2 = Object.keys(object9);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object9);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object9, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.3";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector) return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list8 = ctx.getElementsByTagName(tagName), i = 0, n2 = list8.length;
    if (iterator) {
      for (; i < n2; i++) {
        iterator(list8[i], i);
      }
    }
    return list8;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent2) {
    var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent2;
    if (parent2 === getWindowScrollingElement()) break;
    parent2 = getParentAutoScrollElement(parent2, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last2 = el.lastElementChild;
  while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
    last2 = last2.previousElementSibling;
  }
  return last2 || null;
}
function index$1(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle$1(callback57, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback57.call(_this, args[0]);
      } else {
        callback57.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback57) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback57 === "function") callback57();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time2 = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time2 = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time2) {
            time2 = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time2);
        }
        if (time2) {
          animating = true;
          animationTime = Math.max(animationTime, time2);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time2);
          target.thisAnimationDuration = time2;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback57 === "function") callback57();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback57 === "function") callback57();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration2) {
      if (duration2) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration2 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration2);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2)) continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function") return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
        modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable) return;
  var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group7 = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group7.name = originalGroup.name;
  group7.checkPull = toFn(originalGroup.pull, true);
  group7.checkPut = toFn(originalGroup.put);
  group7.revertClone = originalGroup.revertClone;
  options.group = group7;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name2 in defaults2) {
    !(name2 in options) && (options[name2] = defaults2[name2]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable) return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter2 = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable);
    if (typeof filter2 === "function") {
      if (filter2.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter2) {
      filter2 = filter2.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter2) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
    var touch = e2.touches ? e2.touches[0] : e2;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent2 = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent2) break;
        parent2 = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent2) {
        do {
          if (parent2[expando]) {
            var inserted = void 0;
            inserted = parent2[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent2
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent2;
        } while (parent2 = getParentOrHost(parent2));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group7 = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group7, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent) return;
    function dragOverEvent(name2, extra) {
      pluginEvent2(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed: completed2,
        onMove: function onMove(target2, after3) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after3);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed2(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed2(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group7.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed2(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed2(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed2(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed2(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed2(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed2(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after2 = false;
        after2 = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after2);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after2 = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after2 && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after2 ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed2(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed2(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el, children = this.el.children, i = 0, n2 = children.length, options = this.options;
    for (; i < n2; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name2, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value);
      if (typeof modifiedValue !== "undefined") {
        options[name2] = modifiedValue;
      } else {
        options[name2] = value;
      }
      if (name2 === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle: throttle$1,
  closest,
  toggleClass,
  clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle$1(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var base$k = function base59(props, context, dependencies2, options) {
  var {
    sort: sort2
  } = toRefs(props);
  var el$2 = dependencies2.el$;
  var isDisabled = dependencies2.isDisabled;
  var fire = dependencies2.fire;
  var refreshOrderStore = dependencies2.refreshOrderStore;
  var value = dependencies2.value;
  var sorting = dependencies2.sorting;
  var length = dependencies2.length;
  var path = dependencies2.path;
  var children$Array = dependencies2.children$Array;
  var list8 = ref(null);
  var sortable = ref(null);
  var isSortable = computed(() => {
    return sort2.value && !isDisabled.value && length.value && value.value[0] !== void 0;
  });
  var initSortable = () => {
    sortable.value = new Sortable(list8.value, {
      handle: "[data-handle]",
      onStart: (
        /* istanbul ignore next: can not imitate dragging */
        () => {
          sorting.value = true;
        }
      ),
      onEnd: handleSort
    });
  };
  var destroySortable = () => {
    var _sortable$value;
    (_sortable$value = sortable.value) === null || _sortable$value === void 0 || _sortable$value.destroy();
    sortable.value = null;
  };
  var handleSort = (_ref) => {
    var {
      oldIndex: oldIndex2,
      newIndex: newIndex2,
      item
    } = _ref;
    sorting.value = false;
    if (oldIndex2 === newIndex2 || isDisabled.value) {
      return;
    }
    list8.value.children[newIndex2].remove();
    list8.value.insertBefore(item, list8.value.children[oldIndex2]);
    var valueClone = cloneDeep_1(value.value);
    valueClone.splice(newIndex2, 0, valueClone.splice(oldIndex2, 1)[0]);
    value.value = valueClone;
    refreshOrderStore(value.value);
    fire("sort", value.value, oldIndex2, newIndex2, children$Array.value[newIndex2], el$2.value);
  };
  watch(isSortable, (n2, o2) => {
    if (n2 === true && o2 === false) {
      initSortable();
    } else if (n2 === false && o2 === true) {
      destroySortable();
    }
  }, {
    immediate: false,
    flush: "post"
  });
  onMounted(() => {
    if (isSortable.value) {
      initSortable();
    }
  });
  watch(length, (n2) => {
    var _sortable$value2;
    if (!isSortable.value) {
      return;
    }
    destroySortable();
    initSortable();
    (_sortable$value2 = sortable.value) === null || _sortable$value2 === void 0 || _sortable$value2.sort(Array.from(Array(n2).keys()).reduce((a, b, i) => {
      a.push("".concat(path.value, "-").concat(i));
      return a;
    }, []));
  }, {
    flush: "post"
  });
  return {
    list: list8,
    sortable,
    isSortable,
    handleSort,
    initSortable,
    destroySortable
  };
};
var base$j = function base60(props, context, dependencies2) {
  var sorting = ref(false);
  return {
    sorting
  };
};
var base$i = function base61(props, context, dependencies2, options) {
  var {
    storeOrder,
    orderBy,
    order
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var orderFrom = ref(form$.value.$vueform.config.orderFrom);
  var refreshOrderStore = (value2) => {
    if (storeOrder.value) {
      each(value2, (val, index2) => {
        val[storeOrder.value] = order.value && order.value.toUpperCase() === "DESC" ? value2.length - index2 - (orderFrom.value == 0 ? 1 : 0) : parseInt(index2) + orderFrom.value;
      });
    }
    return value2;
  };
  var orderByName = computed(() => {
    return orderBy.value || storeOrder.value;
  });
  watch(storeOrder, (n2, o2) => {
    if (n2) {
      refreshOrderStore(value.value);
    } else {
      each(value.value, (val, index2) => {
        val[o2] = null;
      });
    }
  }, {
    immediate: false
  });
  return {
    refreshOrderStore,
    orderByName
  };
};
var multifile$2 = function multifile3(props, context, dependencies2, options) {
  var {
    storeOrder,
    orderBy
  } = toRefs(props);
  var {
    refreshOrderStore
  } = base$i(props, context, dependencies2);
  var orderByName = computed(() => {
    return orderBy.value || storeOrder.value;
  });
  return {
    refreshOrderStore,
    orderByName
  };
};
var base$h = function base62(props, context, dependencies2) {
  var {
    object: object9,
    element: element2
  } = toRefs(props);
  var prototype = computed(() => {
    return isObject2.value ? Object.assign({}, object9.value, {
      type: "object"
    }) : element2.value || {};
  });
  var isObject2 = computed(() => {
    return !!object9.value;
  });
  return {
    prototype,
    isObject: isObject2
  };
};
var multifile$1 = function multifile4(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    auto,
    object: object9,
    file: file6,
    fields,
    storeFile,
    storeOrder,
    view,
    clickable,
    url: url2,
    previewUrl,
    uploadTempEndpoint,
    removeTempEndpoint,
    removeEndpoint,
    params,
    softRemove
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var type = computed(() => {
    return options.type || "file";
  });
  var storeFileName = computed(() => {
    if (storeFile.value) {
      return storeFile.value;
    }
    return object9.value || keys_1(fields.value).length || storeOrder.value ? "file" : null;
  });
  var isObject2 = computed(() => {
    return !!object9.value || !!storeOrder.value || !!keys_1(fields.value).length;
  });
  var prototype = computed(() => {
    var fileSchema = {
      type: type.value,
      auto: auto.value,
      view: view.value,
      layout: view.value === "gallery" ? "ElementLayoutInline" : "ElementLayout",
      disabled: isDisabled.value,
      clickable: clickable.value,
      url: url2.value,
      previewUrl: previewUrl.value,
      uploadTempEndpoint: uploadTempEndpoint.value,
      removeTempEndpoint: removeTempEndpoint.value,
      removeEndpoint: removeEndpoint.value,
      params: params.value,
      softRemove: softRemove.value
    };
    if (!isObject2.value) {
      return Object.assign({}, fileSchema, file6.value);
    }
    return {
      type: "object",
      schema: Object.assign(
        {},
        // File
        {
          [storeFileName.value]: Object.assign({}, fileSchema, {
            embed: true
          }, file6.value)
        },
        // Order
        storeOrder.value ? {
          [storeOrder.value]: {
            type: "hidden",
            meta: true
          }
        } : {},
        // Other fields
        fields.value
      )
    };
  });
  return {
    storeFileName,
    isObject: isObject2,
    prototype
  };
};
var base$g = function base63(props, context, dependencies2) {
  var {
    controls,
    sort: sort2,
    min: min3,
    max: max2,
    addText
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var value = dependencies2.value;
  var form$ = dependencies2.form$;
  var hasAdd = computed(() => {
    return !isDisabled.value && (controls.value.add || controls.value.add === void 0) && (max2.value === -1 || max2.value > value.value.length);
  });
  var hasRemove = computed(() => {
    return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && (min3.value === -1 || min3.value < value.value.length);
  });
  var hasSort = computed(() => {
    return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort2.value;
  });
  var addLabel = computed(() => {
    return addText.value || form$.value.translations.vueform.elements.list.add;
  });
  return {
    hasAdd,
    hasRemove,
    hasSort,
    addLabel
  };
};
var multifile5 = function multifile6(props, context, dependencies2) {
  var {
    controls,
    sort: sort2
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var hasUploading = dependencies2.hasUploading;
  var hasAdd = computed(() => {
    return controls.value.add || controls.value.add === void 0;
  });
  var hasRemove = computed(() => {
    return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && !hasUploading.value;
  });
  var hasSort = computed(() => {
    return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort2.value && !hasUploading.value;
  });
  return {
    hasAdd,
    hasRemove,
    hasSort
  };
};
var ListElement = {
  name: "ListElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "list",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: void 0
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    onAdd: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSort: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    element: {
      required: false,
      type: [Object],
      default: null
    },
    object: {
      required: false,
      type: [Object],
      default: null
    },
    initial: {
      required: false,
      type: [Number],
      default: 1
    },
    min: {
      required: false,
      type: [Number],
      default: -1
    },
    max: {
      required: false,
      type: [Number],
      default: -1
    },
    addText: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.elements.list.add"
    },
    sort: {
      required: false,
      type: [Boolean],
      default: false
    },
    controls: {
      required: false,
      type: [Object],
      default: () => ({
        add: true,
        remove: true,
        sort: true
      })
    },
    storeOrder: {
      required: false,
      type: [String],
      default: null
    },
    order: {
      required: false,
      type: [String],
      default: null
    },
    orderBy: {
      required: false,
      type: [String],
      default: null
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$U, base$1b, base$1a, base$X, base$P, base$W, array$1, base$h, base$l, base$j, base$i, base$1e, list$4, base$T, base$D, base$11, base$K, base$14, list$5, list$1, list$3, base$g, array2, base$10, base$$, base$_, base$1c, base$Z, list6, base$k, base$S, list$2, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$f = function base64(props, context, dependencies2) {
  var options_ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    provider,
    extendOptions
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var clear = dependencies2.clear;
  var input = dependencies2.input;
  var inputElement = () => {
    return options_.input ? options_.input.value : input.value;
  };
  var locationService = ref(null);
  var location6 = ref({});
  var locationProvider = computed(() => {
    return provider.value || form$.value.$vueform.config.locationProvider;
  });
  var defaultOptions = computed(() => {
    var providers = {
      google: {
        fields: ["geometry", "formatted_address", "address_components"]
      },
      algolia: {
        type: "address",
        appId: form$.value.$vueform.config.services.algolia.app_id,
        apiKey: form$.value.$vueform.config.services.algolia.api_key,
        templates: options_.templates || {}
      }
    };
    return providers[locationProvider.value];
  });
  var providerOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next: failsafe only */
    {});
  });
  var handleAddressChange = (data, raw) => {
    if (options_.handleAddressChange) {
      options_.handleAddressChange(data, raw);
      return;
    }
    location6.value = raw;
    value.value = data;
  };
  var handleLocationBlur = () => {
    if (inputElement().value.length) {
      inputElement().value = value.value.formatted_address;
    } else {
      clear();
    }
  };
  var initLocationService = () => {
    if (locationService.value) {
      locationService.value.destroy();
    }
    locationService.value = new form$.value.$vueform.services.location[locationProvider.value]();
    locationService.value.init(inputElement(), handleAddressChange, providerOptions.value);
  };
  watch([locationProvider, providerOptions], () => {
    initLocationService();
  }, {
    deep: true,
    immediate: false
  });
  onMounted(() => {
    initLocationService();
  });
  return {
    locationService,
    location: location6,
    defaultOptions,
    providerOptions,
    handleAddressChange,
    handleLocationBlur,
    initLocationService
  };
};
var LocationElement = {
  name: "LocationElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "location",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({
        country: null,
        country_code: null,
        state: null,
        state_code: null,
        city: null,
        zip: null,
        address: null,
        formatted_address: null,
        lat: null,
        lng: null
      })
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    provider: {
      required: false,
      type: [String],
      default: "google"
    },
    displayKey: {
      required: false,
      type: [String],
      default: "formatted_address"
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, location$2, base$W, base$H, base$1e, base$Q, base$T, base$C, base$w, base$D, base$M, location4, base$16, base$J, base$B, base$f, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$s, base$S, location$1, base$V, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, location$3(props, context));
  }
};
var base$e = function base65(props, context, dependencies2) {
  var isDisabled = dependencies2.isDisabled;
  var add = dependencies2.add;
  var input = dependencies2.input;
  var isObject2 = dependencies2.isObject;
  var storeFileName = dependencies2.storeFileName;
  var children$ = dependencies2.children$;
  var preparing = computed(() => {
    return some_1(children$.value, {
      available: true,
      preparing: true
    });
  });
  var hasUploading = computed(() => {
    return some_1(children$.value, {
      uploading: true
    });
  });
  var handleChange = (e2) => {
    if (!e2.target || !e2.target.files || e2.target.files.length == 0 || isDisabled.value) {
      return;
    }
    each(e2.target.files, (file6) => {
      add(isObject2.value ? {
        [storeFileName.value]: file6
      } : file6);
    });
    input.value.value = "";
  };
  var handleClick = () => {
    if (isDisabled.value) {
      return;
    }
    input.value.click();
  };
  return {
    preparing,
    hasUploading,
    handleChange,
    handleClick
  };
};
var MultifileElement = {
  name: "MultifileElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "multifile",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    initial: {
      required: false,
      type: [Number],
      default: 0,
      private: true
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    onAdd: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSort: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    view: {
      type: [String],
      required: false,
      default: "file"
    },
    drop: {
      required: false,
      type: [Boolean],
      default: false
    },
    sort: {
      required: false,
      type: [Boolean],
      default: false
    },
    controls: {
      required: false,
      type: [Object],
      default: () => ({
        add: true,
        remove: true,
        sort: true
      })
    },
    object: {
      required: false,
      type: [Boolean],
      default: null
    },
    storeFile: {
      required: false,
      type: [String],
      default: "file"
    },
    fields: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    storeOrder: {
      required: false,
      type: [String],
      default: null
    },
    order: {
      required: false,
      type: [String],
      default: null
    },
    orderBy: {
      required: false,
      type: [String],
      default: null
    },
    file: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    accept: {
      required: false,
      type: [String, Array],
      default: null
    },
    clickable: {
      required: false,
      type: [Boolean],
      default: true
    },
    url: {
      required: false,
      type: [String, Boolean],
      default: "/"
    },
    previewUrl: {
      required: false,
      type: [String],
      default: void 0
    },
    auto: {
      required: false,
      type: [Boolean],
      default: true
    },
    uploadTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.uploadTempFile"
    },
    removeTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeTempFile"
    },
    removeEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeFile"
    },
    params: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    softRemove: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$P, base$T, array$1, base$l, base$N, base$j, multifile$1, base$W, base$1e, list$4, base$D, base$11, base$K, list$1, base$M, array2, base$14, base$16, base$10, base$$, base$_, base$Z, multifile$2, multifile$4, base$e, multifile5, multifile$3, base$1c, base$k, base$S, multifile$5, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$d = function base66(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$2 = dependencies2.el$;
  var handleSelect = (option2) => {
    fire("select", option2, el$2.value);
  };
  var handleDeselect = (option2) => {
    fire("deselect", option2, el$2.value);
  };
  var handleSearchChange = (searchQuery) => {
    fire("search-change", searchQuery, el$2.value);
  };
  var handleOpen = () => {
    fire("open", el$2.value);
  };
  var handleClose = () => {
    fire("close", el$2.value);
  };
  var handleClear = () => {
    fire("clear", el$2.value);
  };
  var handlePaste = (e2) => {
    fire("paste", e2, el$2.value);
  };
  var handleTag = (searchQuery) => {
  };
  return {
    handleSelect,
    handleDeselect,
    handleSearchChange,
    handleOpen,
    handleClose,
    handleClear,
    handlePaste,
    handleTag
  };
};
function spliceMultiple(array4, indexes) {
  indexes.sort();
  for (var i = indexes.length - 1; i >= 0; i--) {
    array4.splice(indexes[i], 1);
  }
  return array4;
}
var base$c = function base67(props, context, dependencies2) {
  var value = dependencies2.value;
  var inValue = (option2) => {
    return value.value.indexOf(option2) !== -1;
  };
  var select7 = (options) => {
    if (!isArray_1(options)) {
      options = [options];
    }
    var val = clone_1(value.value);
    each(options, (option2) => {
      if (inValue(normalize(option2))) {
        return;
      }
      val.push(option2);
    });
    value.value = val;
  };
  var deselect = (options) => {
    if (!isArray_1(options)) {
      options = [options];
    }
    var val = clone_1(value.value);
    var indexes = [];
    each(options, (option2) => {
      var i = value.value.indexOf(option2);
      if (i === -1 || indexes.indexOf(i) !== -1) {
        return;
      }
      indexes.push(i);
    });
    value.value = spliceMultiple(val, indexes);
  };
  return {
    select: select7,
    deselect
  };
};
var MultiselectElement = {
  name: "MultiselectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "multiselect",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null,
      native: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    native: {
      required: false,
      type: [Boolean],
      default: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value",
      native: false
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: "label",
      native: false
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    multipleLabel: {
      type: [Function],
      required: false,
      native: false
    },
    multipleLabelSingle: {
      type: [String],
      required: false,
      native: false,
      "@default": "locale.vueform.multiselect.multipleLabelOne"
    },
    multipleLabelMultiple: {
      type: [String],
      required: false,
      native: false,
      "@default": "locale.vueform.multiselect.multipleLabelMore"
    },
    create: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"],
      native: false
    },
    allowAbsent: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    object: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    max: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items",
      native: false
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom",
      native: false
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSelect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    },
    delay: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0,
      native: false
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    hideSelected: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true,
      native: false
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true,
      native: false
    },
    autocomplete: {
      type: [String],
      required: false,
      native: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text",
      native: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, multiselect$4, base$P, array$1, base$W, base$H, base$1e, multiselect$5, base$T, base$D, base$E, base$I, multiselect$1, base$M, multiselect$2, base$16, array2, multiselect$3, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$d, base$c, multiselect2, base$S, base$G, base$V, base$t];
    context.slots = ["option", "multiple-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var ObjectElement = {
  name: "ObjectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "remove", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "object",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    schema: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    embed: {
      required: false,
      type: [Boolean],
      default: false
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$P, base$W, object$5, base$1e, object$7, object$2, object$6, base$11, object7, base$14, object$8, object$3, base$$, base$_, base$1c, base$10, base$Z, object$1, base$S, object$4, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$b = function base68(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$2 = dependencies2.el$;
  var handleBlur = () => {
    fire("blur", el$2.value);
  };
  var handleFocus = () => {
    fire("focus", el$2.value);
  };
  return {
    handleBlur,
    handleFocus
  };
};
var us = "{+}0 (000) 000-0000";
var countryPhones = [
  {
    // "country": "Afghanistan",
    "c": "AF",
    "n": "+93",
    "p": 0,
    "m": [
      ["93", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Albania",
    "c": "AL",
    "n": "+355",
    "p": 1,
    "m": [
      ["3554", "{+}000 0 000 0000"],
      ["355", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Algeria",
    "c": "DZ",
    "n": "+213",
    "p": 2,
    "m": [
      ["2131", "{+}000 0 000 0000"],
      ["2132", "{+}000 0 000 0000"],
      ["2133", "{+}000 0 000 0000"],
      ["2134", "{+}000 0 000 0000"],
      ["213", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "American Samoa",
    "c": "AS",
    "n": "+1",
    "p": 3,
    "m": [
      ["1684", us]
    ]
  },
  {
    // "country": "Andorra",
    "c": "AD",
    "n": "+376",
    "p": 4,
    "m": [
      ["376", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Angola",
    "c": "AO",
    "n": "+244",
    "p": 5,
    "m": [
      ["2449", "{+}000 000 000 0000"],
      ["244", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Anguilla",
    "c": "AI",
    "n": "+1",
    "p": 6,
    "m": [
      ["1264", us]
    ]
  },
  {
    // "country": "Antigua & Barbuda",
    "c": "AG",
    "n": "+1",
    "p": 7,
    "m": [
      ["1268", us]
    ]
  },
  {
    // "country": "Argentina",
    "c": "AR",
    "n": "+54",
    "p": 8,
    "m": [
      ["549", "{+}00 0 000 000 0000"],
      ["54", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Armenia",
    "c": "AM",
    "n": "+374",
    "p": 9,
    "m": [
      ["37493", "{+}000 00 000 000"],
      ["37494", "{+}000 00 000 000"],
      ["37498", "{+}000 00 000 000"],
      ["37477", "{+}000 00 000 000"],
      ["37491", "{+}000 00 000 000"],
      ["37496", "{+}000 00 000 000"],
      ["37499", "{+}000 00 000 000"],
      ["37455", "{+}000 00 000 000"],
      ["37495", "{+}000 00 000 000"],
      ["37441", "{+}000 00 000 000"],
      ["374", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Aruba",
    "c": "AW",
    "n": "+297",
    "p": 10,
    "m": [
      ["297", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Ascension Island",
    "c": "AC",
    "n": "+247",
    "p": 11,
    "m": [
      ["247", "{+}000 0000"]
    ]
  },
  {
    // "country": "Australia",
    "c": "AU",
    "n": "+61",
    "p": 12,
    "m": [
      ["61", "{+}00 0 0000 0000"],
      ["614", "{+}00 000 000 000"]
    ]
  },
  {
    // "country": "Austria",
    "c": "AT",
    "n": "+43",
    "p": 13,
    "m": [
      ["43", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Azerbaijan",
    "c": "AZ",
    "n": "+994",
    "p": 14,
    "m": [
      ["9944", "{+}000 00 000 000"],
      ["9945", "{+}000 00 000 000"],
      ["9946", "{+}000 00 000 000"],
      ["9947", "{+}000 00 000 000"],
      ["994", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Bahamas",
    "c": "BS",
    "n": "+1",
    "p": 15,
    "m": [
      ["1242", us]
    ]
  },
  {
    // "country": "Bahrain",
    "c": "BH",
    "n": "+973",
    "p": 16,
    "m": [
      ["973", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Bangladesh",
    "c": "BD",
    "n": "+880",
    "p": 17,
    "m": [
      ["8801", "{+}000 00 0000 0000"],
      ["880", "{+}000 00 0000 0000[00]"]
    ]
  },
  {
    // "country": "Barbados",
    "c": "BB",
    "n": "+1",
    "p": 18,
    "m": [
      ["1246", us]
    ]
  },
  {
    // "country": "Belarus",
    "c": "BY",
    "n": "+375",
    "p": 19,
    "m": [
      ["375", "{+}000 000000000[0]"]
    ]
  },
  {
    // "country": "Belgium",
    "c": "BE",
    "n": "+32",
    "p": 20,
    "m": [
      ["324", "{+}00 000 00 00 00"],
      ["32", "{+}00 0 000 00 00"]
    ]
  },
  {
    // "country": "Belize",
    "c": "BZ",
    "n": "+501",
    "p": 21,
    "m": [
      ["501", "{+}000 000-0000"]
    ]
  },
  {
    // "country": "Benin",
    "c": "BJ",
    "n": "+229",
    "p": 22,
    "m": [
      ["229", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Bermuda",
    "c": "BM",
    "n": "+1",
    "p": 23,
    "m": [
      ["1441", us]
    ]
  },
  {
    // "country": "Bhutan",
    "c": "BT",
    "n": "+975",
    "p": 24,
    "m": [
      ["97517", "{+}000 00 000000"],
      ["975", "{+}000 0 00000[0]"]
    ]
  },
  {
    // "country": "Bolivia",
    "c": "BO",
    "n": "+591",
    "p": 25,
    "m": [
      ["5916", "{+}000 000 000 0000"],
      ["5917", "{+}000 000 000 0000"],
      ["591", "{+}000 0 000 0000[0]"]
    ]
  },
  {
    // "country": "Bosnia & Herzegovina",
    "c": "BA",
    "n": "+387",
    "p": 26,
    "m": [
      ["3876", "{+}000 00 000 000"],
      ["387", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Botswana",
    "c": "BW",
    "n": "+267",
    "p": 27,
    "m": [
      ["2677", "{+}000 00 000 0000"],
      ["267", "{+}000 000 000000"]
    ]
  },
  {
    // "country": "Brazil",
    "c": "BR",
    "n": "+55",
    "p": 28,
    "m": [
      ["55", "{+}00 00 0000 0000[0]"]
    ]
  },
  {
    // "country": "British Indian Ocean Territory",
    "c": "IO",
    "n": "+246",
    "p": 29,
    "m": [
      ["246", "{+}000 0000"]
    ]
  },
  {
    // "country": "British Virgin Islands",
    "c": "VG",
    "n": "+1",
    "p": 30,
    "m": [
      ["1284", us]
    ]
  },
  {
    // "country": "Brunei",
    "c": "BN",
    "n": "+673",
    "p": 31,
    "m": [
      ["673", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Bulgaria",
    "c": "BG",
    "n": "+359",
    "p": 32,
    "m": [
      ["3598", "{+}000 00 000 0000"],
      ["3599", "{+}000 00 000 0000"],
      ["359", "{+}000 0000000[000]"]
    ]
  },
  {
    // "country": "Burkina Faso",
    "c": "BF",
    "n": "+226",
    "p": 33,
    "m": [
      ["226", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Burundi",
    "c": "BI",
    "n": "+257",
    "p": 34,
    "m": [
      ["257", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Cambodia",
    "c": "KH",
    "n": "+855",
    "p": 35,
    "m": [
      ["855", "{+}000 000000000"]
    ]
  },
  {
    // "country": "Cameroon",
    "c": "CM",
    "n": "+237",
    "p": 36,
    "m": [
      ["237", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Canada",
    "c": "CA",
    "n": "+1",
    "p": 37,
    "m": [
      ["1204", us],
      ["1226", us],
      ["1236", us],
      ["1249", us],
      ["1250", us],
      ["1263", us],
      ["1289", us],
      ["1306", us],
      ["1343", us],
      ["1354", us],
      ["1365", us],
      ["1367", us],
      ["1368", us],
      ["1403", us],
      ["1416", us],
      ["1418", us],
      ["1431", us],
      ["1437", us],
      ["1438", us],
      ["1450", us],
      ["1468", us],
      ["1474", us],
      ["1506", us],
      ["1514", us],
      ["1519", us],
      ["1548", us],
      ["1579", us],
      ["1581", us],
      ["1584", us],
      ["1587", us],
      ["1604", us],
      ["1613", us],
      ["1639", us],
      ["1647", us],
      ["1672", us],
      ["1683", us],
      ["1705", us],
      ["1709", us],
      ["1742", us],
      ["1753", us],
      ["1778", us],
      ["1780", us],
      ["1782", us],
      ["1807", us],
      ["1819", us],
      ["1825", us],
      ["1867", us],
      ["1873", us],
      ["1902", us],
      ["1905", us]
    ]
  },
  {
    // "country": "Cape Verde",
    "c": "CV",
    "n": "+238",
    "p": 38,
    "m": [
      ["238", "{+}000 0000 000"]
    ]
  },
  {
    // "country": "Caribbean Netherlands",
    "c": "BQ",
    "n": "+599",
    "p": 39,
    "m": [
      ["599", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Cayman Islands",
    "c": "KY",
    "n": "+1",
    "p": 40,
    "m": [
      ["1345", us]
    ]
  },
  {
    // "country": "Central African Republic",
    "c": "CF",
    "n": "+236",
    "p": 41,
    "m": [
      ["236", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Chad",
    "c": "TD",
    "n": "+235",
    "p": 42,
    "m": [
      ["235", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Chile",
    "c": "CL",
    "n": "+56",
    "p": 43,
    "m": [
      ["562", "{+}00 0 0000 0000"],
      ["569", "{+}00 0 0000 0000"],
      ["56", "{+}00 00 0000 000[0]"]
    ]
  },
  {
    // "country": "China",
    "c": "CN",
    "n": "+86",
    "p": 44,
    "m": [
      ["8613", "{+}00 000 0000 0000"],
      ["8615", "{+}00 000 0000 0000"],
      ["8618", "{+}00 000 0000 0000"],
      ["86", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Colombia",
    "c": "CO",
    "n": "+57",
    "p": 45,
    "m": [
      ["573", "{+}00 000 000 0000"],
      ["57", "{+}00 0 000 0000"]
    ]
  },
  {
    // "country": "Comoros",
    "c": "KM",
    "n": "+269",
    "p": 46,
    "m": [
      ["269", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Congo - Brazzaville",
    "c": "CG",
    "n": "+242",
    "p": 47,
    "m": [
      ["242", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Congo - Kinshasa",
    "c": "CD",
    "n": "+243",
    "p": 48,
    "m": [
      ["243", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Cook Islands",
    "c": "CK",
    "n": "+682",
    "p": 49,
    "m": [
      ["682", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Costa Rica",
    "c": "CR",
    "n": "+506",
    "p": 50,
    "m": [
      ["506", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Côte d’Ivoire",
    "c": "CI",
    "n": "+225",
    "p": 51,
    "m": [
      ["225", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Croatia",
    "c": "HR",
    "n": "+385",
    "p": 52,
    "m": [
      ["385", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Cuba",
    "c": "CU",
    "n": "+53",
    "p": 53,
    "m": [
      ["535", "{+}00 0 000 0000"],
      ["53", "{+}00 000000[0000]"]
    ]
  },
  {
    // "country": "Curaçao",
    "c": "CW",
    "n": "+599",
    "p": 54,
    "m": [
      ["5999", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Cyprus",
    "c": "CY",
    "n": "+357",
    "p": 55,
    "m": [
      ["357", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Czechia",
    "c": "CZ",
    "n": "+420",
    "p": 56,
    "m": [
      ["4206", "{+}000 000 000 000"],
      ["4207", "{+}000 000 000 000"],
      ["420", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Denmark",
    "c": "DK",
    "n": "+45",
    "p": 57,
    "m": [
      ["45", "{+}00 00 00 00 00"]
    ]
  },
  {
    // "country": "Djibouti",
    "c": "DJ",
    "n": "+253",
    "p": 58,
    "m": [
      ["253", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Dominica",
    "c": "DM",
    "n": "+1",
    "p": 59,
    "m": [
      ["1767", us]
    ]
  },
  {
    // "country": "Dominican Republic",
    "c": "DO",
    "n": "+1",
    "p": 60,
    "m": [
      ["1809", us],
      ["1829", us],
      ["1849", us]
    ]
  },
  {
    // "country": "Ecuador",
    "c": "EC",
    "n": "+593",
    "p": 61,
    "m": [
      ["593", "{+}000 00 0000 000"]
    ]
  },
  {
    // "country": "Egypt",
    "c": "EG",
    "n": "+20",
    "p": 62,
    "m": [
      ["2010", "{+}00 000 0000 000"],
      ["2011", "{+}00 000 0000 000"],
      ["2012", "{+}00 000 0000 000"],
      ["2014", "{+}00 000 0000 000"],
      ["2016", "{+}00 000 0000 000"],
      ["202", "{+}00 0 0000 0000"],
      ["203", "{+}00 0 0000 0000"],
      ["20", "{+}00 000 0000 000"]
    ]
  },
  {
    // "country": "El Salvador",
    "c": "SV",
    "n": "+503",
    "p": 63,
    "m": [
      ["503", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Equatorial Guinea",
    "c": "GQ",
    "n": "+240",
    "p": 64,
    "m": [
      ["240", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Eritrea",
    "c": "ER",
    "n": "+291",
    "p": 65,
    "m": [
      ["291", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Estonia",
    "c": "EE",
    "n": "+372",
    "p": 66,
    "m": [
      ["372", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Eswatini",
    "c": "SZ",
    "n": "+268",
    "p": 67,
    "m": [
      ["268", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Ethiopia",
    "c": "ET",
    "n": "+251",
    "p": 68,
    "m": [
      ["2519", "{+}000 000 000 000"],
      ["251", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Falkland Islands (Islas Malvinas)",
    "c": "FK",
    "n": "+500",
    "p": 69,
    "m": [
      ["500", "{+}000 00000"]
    ]
  },
  {
    // "country": "Faroe Islands",
    "c": "FO",
    "n": "+298",
    "p": 70,
    "m": [
      ["298", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Fiji",
    "c": "FJ",
    "n": "+679",
    "p": 71,
    "m": [
      ["679", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Finland",
    "c": "FI",
    "n": "+358",
    "p": 72,
    "m": [
      ["358", "{+}000 0000[0000000]"]
    ]
  },
  {
    // "country": "France",
    "c": "FR",
    "n": "+33",
    "p": 73,
    "m": [
      ["33", "{+}00 000 000 000"]
    ]
  },
  {
    // "country": "French Guiana",
    "c": "GF",
    "n": "+594",
    "p": 74,
    "m": [
      ["594", "{+}000 000 00 00 00"]
    ]
  },
  {
    // "country": "French Polynesia",
    "c": "PF",
    "n": "+689",
    "p": 75,
    "m": [
      ["689", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Gabon",
    "c": "GA",
    "n": "+241",
    "p": 76,
    "m": [
      ["24106", "{+}000 000 00 00 00"],
      ["24107", "{+}000 000 00 00 00"],
      ["241", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Gambia",
    "c": "GM",
    "n": "+220",
    "p": 77,
    "m": [
      ["220", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Georgia",
    "c": "GE",
    "n": "+995",
    "p": 78,
    "m": [
      ["99532", "{+}000 00 000 0000"],
      ["995", "{+}000 000 000 000[0]"]
    ]
  },
  {
    // "country": "Germany",
    "c": "DE",
    "n": "+49",
    "p": 79,
    "m": [
      ["4930", "{+}00 00 0000 0000"],
      ["4989", "{+}00 00 0000 0000"],
      ["49", "{+}00 000 0000 000[0]"]
    ]
  },
  {
    // "country": "Ghana",
    "c": "GH",
    "n": "+233",
    "p": 80,
    "m": [
      ["233", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Gibraltar",
    "c": "GI",
    "n": "+350",
    "p": 81,
    "m": [
      ["350", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Greece",
    "c": "GR",
    "n": "+30",
    "p": 82,
    "m": [
      ["3069", "{+}00 000 0000 000"],
      ["30", "{+}00 000 0000 000[0]"]
    ]
  },
  {
    // "country": "Greenland",
    "c": "GL",
    "n": "+299",
    "p": 83,
    "m": [
      ["299", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "Grenada",
    "c": "GD",
    "n": "+1",
    "p": 84,
    "m": [
      ["1473", us]
    ]
  },
  {
    // "country": "Guadeloupe",
    "c": "GP",
    "n": "+590",
    "p": 85,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Guam",
    "c": "GU",
    "n": "+1",
    "p": 86,
    "m": [
      ["1671", us]
    ]
  },
  {
    // "country": "Guatemala",
    "c": "GT",
    "n": "+502",
    "p": 87,
    "m": [
      ["502", "{+}000 000 00000"]
    ]
  },
  {
    // "country": "Guinea",
    "c": "GN",
    "n": "+224",
    "p": 88,
    "m": [
      ["224", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Guinea-Bissau",
    "c": "GW",
    "n": "+245",
    "p": 89,
    "m": [
      ["245", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Guyana",
    "c": "GY",
    "n": "+592",
    "p": 90,
    "m": [
      ["592", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Haiti",
    "c": "HT",
    "n": "+509",
    "p": 91,
    "m": [
      ["509", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Honduras",
    "c": "HN",
    "n": "+504",
    "p": 92,
    "m": [
      ["504", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Hong Kong",
    "c": "HK",
    "n": "+852",
    "p": 93,
    "m": [
      ["852", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Hungary",
    "c": "HU",
    "n": "+36",
    "p": 94,
    "m": [
      ["361", "{+}00 0 000 0000"],
      ["3620", "{+}00 00 000 0000"],
      ["3630", "{+}00 00 000 0000"],
      ["3670", "{+}00 00 000 0000"],
      ["36", "{+}00 00 000 000[0]"]
    ]
  },
  {
    // "country": "Iceland",
    "c": "IS",
    "n": "+354",
    "p": 95,
    "m": [
      ["354", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "India",
    "c": "IN",
    "n": "+91",
    "p": 96,
    "m": [
      ["916", "{+}00 000 000 0000"],
      ["917", "{+}00 000 000 0000"],
      ["918", "{+}00 000 000 0000"],
      ["919", "{+}00 000 000 0000"],
      ["91", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Indonesia",
    "c": "ID",
    "n": "+62",
    "p": 97,
    "m": [
      ["62361", "{+}00 000 000 000"],
      ["6221", "{+}00 00 0000 0000"],
      ["628", "{+}00 000 0000 0000"],
      ["62", "{+}00 00000[000000]"]
    ]
  },
  {
    // "country": "Iran",
    "c": "IR",
    "n": "+98",
    "p": 98,
    "m": [
      ["98921", "{+}00 00 000 0000"],
      ["98951", "{+}00 00 000 0000"],
      ["989", "{+}00 000 000 0000"],
      ["98", "{+}00 00000000[00]"]
    ]
  },
  {
    // "country": "Iraq",
    "c": "IQ",
    "n": "+964",
    "p": 99,
    "m": [
      ["9641", "{+}000 0 000 0000[0]"],
      ["9647", "{+}000 000 000 0000"],
      ["964", "{+}000 000000[0000]"]
    ]
  },
  {
    // "country": "Ireland",
    "c": "IE",
    "n": "+353",
    "p": 100,
    "m": [
      ["3531", "{+}000 0 000 0000"],
      ["353", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Israel",
    "c": "IL",
    "n": "+972",
    "p": 101,
    "m": [
      ["9725", "{+}000 00 000 0000"],
      ["9727", "{+}000 00 000 0000"],
      ["972", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Italy",
    "c": "IT",
    "n": "+39",
    "p": 102,
    "m": [
      ["393", "{+}00 000 000 0000"],
      ["39", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Jamaica",
    "c": "JM",
    "n": "+1",
    "p": 103,
    "m": [
      ["1876", us]
    ]
  },
  {
    // "country": "Japan",
    "c": "JP",
    "n": "+81",
    "p": 104,
    "m": [
      ["8170", "{+}00 00 0000 0000"],
      ["8180", "{+}00 00 0000 0000"],
      ["8190", "{+}00 00 0000 0000"],
      ["81", "{+}00 0 0000 0000"]
    ]
  },
  {
    // "country": "Jordan",
    "c": "JO",
    "n": "+962",
    "p": 105,
    "m": [
      ["9627", "{+}000 000 000 000"],
      ["962", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Kazakhstan",
    "c": "KZ",
    "n": "+7",
    "p": 106,
    "m": [
      ["77", "{+}0 000 000 0000"]
    ]
  },
  {
    // "country": "Kenya",
    "c": "KE",
    "n": "+254",
    "p": 107,
    "m": [
      ["2541", "{+}000 000 000 000"],
      ["2547", "{+}000 000 000 000"],
      ["254", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Kiribati",
    "c": "KI",
    "n": "+686",
    "p": 108,
    "m": [
      ["686", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Kosovo",
    "c": "XK",
    "n": "+383",
    "p": 109,
    "m": [
      ["383", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Kuwait",
    "c": "KW",
    "n": "+965",
    "p": 110,
    "m": [
      ["9655", "{+}000 000 00000"],
      ["9656", "{+}000 000 00000"],
      ["9659", "{+}000 000 00000"],
      ["965", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Kyrgyzstan",
    "c": "KG",
    "n": "+996",
    "p": 111,
    "m": [
      ["996", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Laos",
    "c": "LA",
    "n": "+856",
    "p": 112,
    "m": [
      ["85620", "{+}000 00 0000 0000"],
      ["85630", "{+}000 00 0000 0000"],
      ["856", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Latvia",
    "c": "LV",
    "n": "+371",
    "p": 113,
    "m": [
      ["3715", "{+}000 0 00 00000"],
      ["3716", "{+}000 0 00 00000"],
      ["3717", "{+}000 0 00 00000"],
      ["371", "{+}000 000 00 000"]
    ]
  },
  {
    // "country": "Lebanon",
    "c": "LB",
    "n": "+961",
    "p": 114,
    "m": [
      ["96170", "{+}000 00 000 000"],
      ["96171", "{+}000 00 000 000"],
      ["96180", "{+}000 00 000 000"],
      ["96181", "{+}000 00 000 000"],
      ["96190", "{+}000 00 000 000"],
      ["96191", "{+}000 00 000 000"],
      ["961", "{+}000 0 000 000[0]"]
    ]
  },
  {
    // "country": "Lesotho",
    "c": "LS",
    "n": "+266",
    "p": 115,
    "m": [
      ["266", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Liberia",
    "c": "LR",
    "n": "+231",
    "p": 116,
    "m": [
      ["231", "{+}000 000000[0000]"]
    ]
  },
  {
    // "country": "Libya",
    "c": "LY",
    "n": "+218",
    "p": 117,
    "m": [
      ["218", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Liechtenstein",
    "c": "LI",
    "n": "+423",
    "p": 118,
    "m": [
      ["42323", "{+}000 00 00000"],
      ["42375", "{+}000 00 00000"],
      ["423", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Lithuania",
    "c": "LT",
    "n": "+370",
    "p": 119,
    "m": [
      ["370", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Luxembourg",
    "c": "LU",
    "n": "+352",
    "p": 120,
    "m": [
      ["352", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Macao",
    "c": "MO",
    "n": "+853",
    "p": 121,
    "m": [
      ["8536", "{+}000 000 0000[0]"],
      ["853", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Madagascar",
    "c": "MG",
    "n": "+261",
    "p": 122,
    "m": [
      ["261", "{+}000 00 00 00000"]
    ]
  },
  {
    // "country": "Malawi",
    "c": "MW",
    "n": "+265",
    "p": 123,
    "m": [
      ["265", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Malaysia",
    "c": "MY",
    "n": "+60",
    "p": 124,
    "m": [
      ["60", "{+}00 0000000[000]"]
    ]
  },
  {
    // "country": "Maldives",
    "c": "MV",
    "n": "+960",
    "p": 125,
    "m": [
      ["960", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Mali",
    "c": "ML",
    "n": "+223",
    "p": 126,
    "m": [
      ["223", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Malta",
    "c": "MT",
    "n": "+356",
    "p": 127,
    "m": [
      ["356", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Marshall Islands",
    "c": "MH",
    "n": "+692",
    "p": 128,
    "m": [
      ["692", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Martinique",
    "c": "MQ",
    "n": "+596",
    "p": 129,
    "m": [
      ["596", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Mauritania",
    "c": "MR",
    "n": "+222",
    "p": 130,
    "m": [
      ["222", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Mauritius",
    "c": "MU",
    "n": "+230",
    "p": 131,
    "m": [
      ["230", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Mexico",
    "c": "MX",
    "n": "+52",
    "p": 132,
    "m": [
      ["52", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Micronesia",
    "c": "FM",
    "n": "+691",
    "p": 133,
    "m": [
      ["691", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Moldova",
    "c": "MD",
    "n": "+373",
    "p": 134,
    "m": [
      ["373", "{+}000 000 00 000"]
    ]
  },
  {
    // "country": "Monaco",
    "c": "MC",
    "n": "+377",
    "p": 135,
    "m": [
      ["377", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Mongolia",
    "c": "MN",
    "n": "+976",
    "p": 136,
    "m": [
      ["976", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Montenegro",
    "c": "ME",
    "n": "+382",
    "p": 137,
    "m": [
      ["382", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Montserrat",
    "c": "MS",
    "n": "+1",
    "p": 138,
    "m": [
      ["1664", us]
    ]
  },
  {
    // "country": "Morocco",
    "c": "MA",
    "n": "+212",
    "p": 139,
    "m": [
      ["212", "{+}000 00 000 0000[0]"]
    ]
  },
  {
    // "country": "Mozambique",
    "c": "MZ",
    "n": "+258",
    "p": 140,
    "m": [
      ["258", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Myanmar (Burma)",
    "c": "MM",
    "n": "+95",
    "p": 141,
    "m": [
      ["95", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Namibia",
    "c": "NA",
    "n": "+264",
    "p": 142,
    "m": [
      ["264", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Nauru",
    "c": "NR",
    "n": "+674",
    "p": 143,
    "m": [
      ["674", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Nepal",
    "c": "NP",
    "n": "+977",
    "p": 144,
    "m": [
      ["977", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Netherlands",
    "c": "NL",
    "n": "+31",
    "p": 145,
    "m": [
      ["31", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "New Caledonia",
    "c": "NC",
    "n": "+687",
    "p": 146,
    "m": [
      ["687", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "New Zealand",
    "c": "NZ",
    "n": "+64",
    "p": 147,
    "m": [
      ["642", "{+}00 000 000 000"],
      ["64", "{+}00 0 000 0000"]
    ]
  },
  {
    // "country": "Nicaragua",
    "c": "NI",
    "n": "+505",
    "p": 148,
    "m": [
      ["505", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Niger",
    "c": "NE",
    "n": "+227",
    "p": 149,
    "m": [
      ["227", "{+}000 00000000[000]"]
    ]
  },
  {
    // "country": "Nigeria",
    "c": "NG",
    "n": "+234",
    "p": 150,
    "m": [
      ["234", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Niue",
    "c": "NU",
    "n": "+683",
    "p": 151,
    "m": [
      ["683", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Norfolk Island",
    "c": "NF",
    "n": "+672",
    "p": 152,
    "m": [
      ["672", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "North Korea",
    "c": "KP",
    "n": "+850",
    "p": 153,
    "m": [
      ["850", "{+}000 000000[0000000]"]
    ]
  },
  {
    // "country": "North Macedonia",
    "c": "MK",
    "n": "+389",
    "p": 154,
    "m": [
      ["389", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Northern Mariana Islands",
    "c": "MP",
    "n": "+1",
    "p": 155,
    "m": [
      ["1670", us]
    ]
  },
  {
    // "country": "Norway",
    "c": "NO",
    "n": "+47",
    "p": 156,
    "m": [
      ["47", "{+}00 00 00 00 00"]
    ]
  },
  {
    // "country": "Oman",
    "c": "OM",
    "n": "+968",
    "p": 157,
    "m": [
      ["968", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Pakistan",
    "c": "PK",
    "n": "+92",
    "p": 158,
    "m": [
      ["923", "{+}00 000 0000 000"],
      ["92", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Palau",
    "c": "PW",
    "n": "+680",
    "p": 159,
    "m": [
      ["680", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Palestine",
    "c": "PS",
    "n": "+970",
    "p": 160,
    "m": [
      ["970", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Panama",
    "c": "PA",
    "n": "+507",
    "p": 161,
    "m": [
      ["507", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Papua New Guinea",
    "c": "PG",
    "n": "+675",
    "p": 162,
    "m": [
      ["675", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Paraguay",
    "c": "PY",
    "n": "+595",
    "p": 163,
    "m": [
      ["595", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Peru",
    "c": "PE",
    "n": "+51",
    "p": 164,
    "m": [
      ["51", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Philippines",
    "c": "PH",
    "n": "+63",
    "p": 165,
    "m": [
      ["639", "{+}00 000 000 0000"],
      ["63", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Poland",
    "c": "PL",
    "n": "+48",
    "p": 166,
    "m": [
      ["485", "{+}00 000 000 000"],
      ["48", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Portugal",
    "c": "PT",
    "n": "+351",
    "p": 167,
    "m": [
      ["351", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Puerto Rico",
    "c": "PR",
    "n": "+1",
    "p": 168,
    "m": [
      ["1787", us],
      ["1939", us]
    ]
  },
  {
    // "country": "Qatar",
    "c": "QA",
    "n": "+974",
    "p": 169,
    "m": [
      ["974", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Réunion",
    "c": "RE",
    "n": "+262",
    "p": 170,
    "m": [
      ["262", "{+}000 00000 0000"]
    ]
  },
  {
    // "country": "Romania",
    "c": "RO",
    "n": "+40",
    "p": 171,
    "m": [
      ["407", "{+}00 000 000 000"],
      ["40", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Russia",
    "c": "RU",
    "n": "+7",
    "p": 172,
    "m": [
      ["7", "{+}0 000 000 00 00"]
    ]
  },
  {
    // "country": "Rwanda",
    "c": "RW",
    "n": "+250",
    "p": 173,
    "m": [
      ["250", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Samoa",
    "c": "WS",
    "n": "+685",
    "p": 174,
    "m": [
      ["685", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "San Marino",
    "c": "SM",
    "n": "+378",
    "p": 175,
    "m": [
      ["378", "{+}000 0000 000000"]
    ]
  },
  {
    // "country": "São Tomé & Príncipe",
    "c": "ST",
    "n": "+239",
    "p": 176,
    "m": [
      ["239", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "Saudi Arabia",
    "c": "SA",
    "n": "+966",
    "p": 177,
    "m": [
      ["96657", "{+}000 000 00 0000"],
      ["966", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Senegal",
    "c": "SN",
    "n": "+221",
    "p": 178,
    "m": [
      ["221", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Serbia",
    "c": "RS",
    "n": "+381",
    "p": 179,
    "m": [
      ["3816", "{+}000 000 000 000"],
      ["3817", "{+}000 000 000 000"],
      ["381", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Seychelles",
    "c": "SC",
    "n": "+248",
    "p": 180,
    "m": [
      ["248", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Sierra Leone",
    "c": "SL",
    "n": "+232",
    "p": 181,
    "m": [
      ["232", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Singapore",
    "c": "SG",
    "n": "+65",
    "p": 182,
    "m": [
      ["65", "{+}00 0000 0000"]
    ]
  },
  {
    // "country": "Sint Maarten",
    "c": "SX",
    "n": "+1",
    "p": 183,
    "m": [
      ["1721", us]
    ]
  },
  {
    // "country": "Slovakia",
    "c": "SK",
    "n": "+421",
    "p": 184,
    "m": [
      ["4219", "{+}000 000 000 0000"],
      ["421", "{+}000 00000000[00]"]
    ]
  },
  {
    // "country": "Slovenia",
    "c": "SI",
    "n": "+386",
    "p": 185,
    "m": [
      ["3863", "{+}000 00 000 000"],
      ["386", "{+}000 0000000[00]"]
    ]
  },
  {
    // "country": "Solomon Islands",
    "c": "SB",
    "n": "+677",
    "p": 186,
    "m": [
      ["677", "{+}000 00000"]
    ]
  },
  {
    // "country": "Somalia",
    "c": "SO",
    "n": "+252",
    "p": 187,
    "m": [
      ["252", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "South Africa",
    "c": "ZA",
    "n": "+27",
    "p": 188,
    "m": [
      ["276", "{+}00 000 000 000"],
      ["277", "{+}00 000 000 000"],
      ["278", "{+}00 000 000 000"],
      ["27", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "South Korea",
    "c": "KR",
    "n": "+82",
    "p": 189,
    "m": [
      ["82", "{+}00 00000000[00]"]
    ]
  },
  {
    // "country": "South Sudan",
    "c": "SS",
    "n": "+211",
    "p": 190,
    "m": [
      ["211", "{+}000 0000000[00]"]
    ]
  },
  {
    // "country": "Spain",
    "c": "ES",
    "n": "+34",
    "p": 191,
    "m": [
      ["346", "{+}00 000 000 000"],
      ["347", "{+}00 000 000 000"],
      ["34", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Sri Lanka",
    "c": "LK",
    "n": "+94",
    "p": 192,
    "m": [
      ["947", "{+}00 000 000 0000"],
      ["948", "{+}00 000 000 0000"],
      ["949", "{+}00 000 000 0000"],
      ["94", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "St. Barthélemy",
    "c": "BL",
    "n": "+590",
    "p": 193,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "St. Helena",
    "c": "SH",
    "n": "+290",
    "p": 194,
    "m": [
      ["290", "{+}000 0000"]
    ]
  },
  {
    // "country": "St. Kitts & Nevis",
    "c": "KN",
    "n": "+1",
    "p": 195,
    "m": [
      ["1869", us]
    ]
  },
  {
    // "country": "St. Lucia",
    "c": "LC",
    "n": "+1",
    "p": 196,
    "m": [
      ["1758", us]
    ]
  },
  {
    // "country": "St. Martin",
    "c": "MF",
    "n": "+590",
    "p": 197,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "St. Pierre & Miquelon",
    "c": "PM",
    "n": "+508",
    "p": 198,
    "m": [
      ["508", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "St. Vincent & Grenadines",
    "c": "VC",
    "n": "+1",
    "p": 199,
    "m": [
      ["1784", us]
    ]
  },
  {
    // "country": "Sudan",
    "c": "SD",
    "n": "+249",
    "p": 200,
    "m": [
      ["249", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Suriname",
    "c": "SR",
    "n": "+597",
    "p": 201,
    "m": [
      ["597", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Sweden",
    "c": "SE",
    "n": "+46",
    "p": 202,
    "m": [
      ["4613", "{+}00 00 00 00 00"],
      ["4618", "{+}00 00 00 00 00"],
      ["467", "{+}00 00 000 00 00"],
      ["468", "{+}00 00 000 00 00"],
      ["46", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Switzerland",
    "c": "CH",
    "n": "+41",
    "p": 203,
    "m": [
      ["417", "{+}00 000 000 000"],
      ["41", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Syria",
    "c": "SY",
    "n": "+963",
    "p": 204,
    "m": [
      ["9639", "{+}000 000 000 000"],
      ["963", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Taiwan",
    "c": "TW",
    "n": "+886",
    "p": 205,
    "m": [
      ["8869", "{+}000 000 000 000"],
      ["886", "{+}000 0 0000 0000"]
    ]
  },
  {
    // "country": "Tajikistan",
    "c": "TJ",
    "n": "+992",
    "p": 206,
    "m": [
      ["992", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Tanzania",
    "c": "TZ",
    "n": "+255",
    "p": 207,
    "m": [
      ["255", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Thailand",
    "c": "TH",
    "n": "+66",
    "p": 208,
    "m": [
      ["6653", "{+}00 00 000 000"],
      ["6676", "{+}00 00 000 000"],
      ["662", "{+}00 0 000 0000"],
      ["666", "{+}00 000 000 000"],
      ["668", "{+}00 000 000 000"],
      ["669", "{+}00 000 000 000"],
      ["66", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Timor-Leste",
    "c": "TL",
    "n": "+670",
    "p": 209,
    "m": [
      ["670", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Togo",
    "c": "TG",
    "n": "+228",
    "p": 210,
    "m": [
      ["228", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Tokelau",
    "c": "TK",
    "n": "+690",
    "p": 211,
    "m": [
      ["690", "{+}000 0000"]
    ]
  },
  {
    // "country": "Tonga",
    "c": "TO",
    "n": "+676",
    "p": 212,
    "m": [
      ["676", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Trinidad & Tobago",
    "c": "TT",
    "n": "+1",
    "p": 213,
    "m": [
      ["1868", us]
    ]
  },
  {
    // "country": "Tunisia",
    "c": "TN",
    "n": "+216",
    "p": 214,
    "m": [
      ["216", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Türkiye",
    "c": "TR",
    "n": "+90",
    "p": 215,
    "m": [
      ["90", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Turkmenistan",
    "c": "TM",
    "n": "+993",
    "p": 216,
    "m": [
      ["993", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Turks & Caicos Islands",
    "c": "TC",
    "n": "+1",
    "p": 217,
    "m": [
      ["1649", us]
    ]
  },
  {
    // "country": "Tuvalu",
    "c": "TV",
    "n": "+688",
    "p": 218,
    "m": [
      ["688", "{+}000 00 000"]
    ]
  },
  {
    // "country": "U.S. Virgin Islands",
    "c": "VI",
    "n": "+1",
    "p": 219,
    "m": [
      ["1340", us]
    ]
  },
  {
    // "country": "Uganda",
    "c": "UG",
    "n": "+256",
    "p": 220,
    "m": [
      ["2567", "{+}000 000 000 000"],
      ["256", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Ukraine",
    "c": "UA",
    "n": "+380",
    "p": 221,
    "m": [
      ["380", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "United Arab Emirates",
    "c": "AE",
    "n": "+971",
    "p": 222,
    "m": [
      ["9715", "{+}000 00 000 0000"],
      ["971", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "United Kingdom",
    "c": "GB",
    "n": "+44",
    "p": 223,
    "m": [
      ["4420", "{+}00 00 0000 0000"],
      ["447", "{+}00 0000 000 000"],
      ["44", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "United States",
    "c": "US",
    "n": "+1",
    "p": 224,
    "m": [
      ["1", us]
    ]
  },
  {
    // "country": "Uruguay",
    "c": "UY",
    "n": "+598",
    "p": 225,
    "m": [
      ["598", "{+}000 0 000 00 00"]
    ]
  },
  {
    // "country": "Uzbekistan",
    "c": "UZ",
    "n": "+998",
    "p": 226,
    "m": [
      ["998", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Vanuatu",
    "c": "VU",
    "n": "+678",
    "p": 227,
    "m": [
      ["678", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "Vatican City",
    "c": "VA",
    "n": "+39",
    "p": 228,
    "m": [
      ["3906698", "{+}00 00 000 00000"],
      ["379", "{+}000 00 0000 0000"]
    ]
  },
  {
    // "country": "Venezuela",
    "c": "VE",
    "n": "+58",
    "p": 229,
    "m": [
      ["58", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Vietnam",
    "c": "VN",
    "n": "+84",
    "p": 230,
    "m": [
      ["843", "{+}00 000 000 000"],
      ["845", "{+}00 000 000 000"],
      ["847", "{+}00 000 000 000"],
      ["849", "{+}00 000 000 000"],
      ["84", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Wallis & Futuna",
    "c": "WF",
    "n": "+681",
    "p": 231,
    "m": [
      ["681", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "Yemen",
    "c": "YE",
    "n": "+967",
    "p": 232,
    "m": [
      ["9677", "{+}000 000 000 000"],
      ["967", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Zambia",
    "c": "ZM",
    "n": "+260",
    "p": 233,
    "m": [
      ["2609", "{+}000 000 000 000"],
      ["260", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Zimbabwe",
    "c": "ZW",
    "n": "+263",
    "p": 234,
    "m": [
      ["263", "{+}000 00 000 00[00]"]
    ]
  }
];
var base$a = function base69(props, context, dependencies2) {
  var {
    include,
    exclude,
    mask: maskProp
  } = toRefs(props);
  var {
    update,
    focus,
    value,
    input,
    form$,
    el$: el$2,
    classes
  } = dependencies2;
  var options$ = ref(null);
  var addonPlaceholder = ref(markRaw({
    props: ["option", "el$"],
    render() {
      return h("div", {
        class: classes.value.placeholder,
        style: {
          backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
        }
      });
    }
  }));
  var addonOptions = computed(() => {
    return countryPhones.filter((c) => {
      if (!include.value.length && !exclude.value.length) {
        return true;
      }
      if (include.value.length) {
        return include.value.map((c2) => c2.toUpperCase()).indexOf(c.c) !== -1;
      }
      return exclude.value.map((c2) => c2.toUpperCase()).indexOf(c.c) === -1;
    }).map((c) => {
      return _objectSpread2$1(_objectSpread2$1({}, c), {}, {
        value: c.c,
        label: form$.value.translations.vueform.countries[c.c],
        display: markRaw({
          props: ["option", "index", "selected", "pointed", "el$"],
          render() {
            return h("div", {
              class: classes.value.option(this.selected || this.pointed)
            }, [h("div", {
              class: classes.value.optionWrapper
            }, [h("div", {
              class: classes.value.flag,
              style: {
                backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
              }
            }), h("div", {
              class: classes.value.country
            }, [this.option.label, h("span", {
              class: classes.value.number
            }, [this.option.n])])])]);
          }
        }),
        valueDisplay: markRaw({
          props: ["option", "el$"],
          render() {
            return h("div", {
              class: classes.value.flag,
              style: {
                backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
              }
            });
          }
        })
      });
    }).sort((a, b) => a.label.localeCompare(b.label)).map((c, i) => _objectSpread2$1(_objectSpread2$1({}, c), {}, {
      index: i
    }));
  });
  var mask = computed(() => {
    if (!maskPluginInstalled.value) {
      return;
    }
    var masks2 = {};
    var maskLengths = [];
    addonOptions.value.forEach((c) => c.m.forEach((m) => {
      if (masks2[m[1]] === void 0) {
        masks2[m[1]] = [];
      }
      var length = m[0].toString().length;
      if (masks2[m[1]][length] === void 0) {
        masks2[m[1]][length] = [];
      }
      masks2[m[1]][length].push(parseInt(m[0]));
      if (maskLengths.indexOf(length) === -1) {
        maskLengths.push(length);
      }
    }));
    maskLengths.sort().reverse();
    var mask2 = [];
    maskLengths.forEach((length) => {
      Object.keys(masks2).forEach((m) => {
        if (masks2[m][length]) {
          mask2.push({
            mask: m,
            startsWith: masks2[m][length],
            placeholder: true
          });
        }
      });
    });
    mask2.push({
      mask: "{+}0000000[0000000]",
      startsWith: ""
    });
    return {
      mask: mask2
    };
  });
  var masks = computed(() => {
    return addonOptions.value.reduce((prev, curr) => {
      return curr.m.reduce((p, c) => {
        return _objectSpread2$1(_objectSpread2$1({}, p), {}, {
          [c[0]]: curr.c
        });
      }, _objectSpread2$1({}, prev));
    }, {});
  });
  var maskPluginInstalled = computed(() => {
    return !!maskProp;
  });
  var inputType = computed(() => {
    return maskPluginInstalled.value ? "text" : "tel";
  });
  var setFlag = () => {
    var _options$$value$selec;
    if (!value.value) {
      if (Object.keys(options$.value.selected).length) {
        options$.value.reset();
      }
      return;
    }
    if (value.value && !value.value.toString().startsWith("+") || value.value === ((_options$$value$selec = options$.value.selected) === null || _options$$value$selec === void 0 ? void 0 : _options$$value$selec.n)) {
      return;
    }
    var number = value.value.replace("+", "");
    var lengths = [7, 5, 4, 3, 2, 1].filter((l) => number.length >= l);
    var country;
    lengths.forEach((l) => {
      if (country) {
        return;
      }
      country = masks.value[number.slice(0, l)] || void 0;
    });
    if (!country) {
      if (Object.keys(options$.value.selected).length) {
        options$.value.reset();
      }
      return;
    }
    if (country === "MF") {
      country = "GP";
    }
    var option2 = addonOptions.value.find((c) => c.c === country);
    if (options$.value.selected.index !== option2.index) {
      options$.value.selectOption(option2);
    }
  };
  var handleOptionSelect = (option2) => {
    if (document.activeElement === input.value) {
      context.emit("select", option2, el$2.value);
      return;
    }
    if (option2.n === void 0) {
      el$2.value.clear();
    } else if (maskPluginInstalled.value) {
      var valueMatchesMask = value.value ? option2.m.map((m) => "+".concat(m[0])).find((m) => {
        return value.value.startsWith(m);
      }) : false;
      if (!valueMatchesMask) {
        el$2.value.update(option2.m.length === 1 ? "+".concat(option2.m[0][0]) : option2.n);
      }
      if (document.activeElement.closest("[data-dropdown-for]")) {
        focus();
      }
    }
    context.emit("select", option2, el$2.value);
  };
  var handleOpen = () => {
    context.emit("open", el$2);
  };
  var handleClose = () => {
    context.emit("close", el$2);
  };
  onMounted(() => {
    setFlag();
  });
  watch(value, (n2) => {
    setFlag();
  });
  return {
    options$,
    addonOptions,
    handleOptionSelect,
    addonPlaceholder,
    maskPluginInstalled,
    inputType,
    mask,
    handleOpen,
    handleClose
  };
};
var base$9 = function base70(props, context, dependencies2) {
  var {
    fire,
    el$: el$2
  } = dependencies2;
  var handleKeydown = (e2) => {
    fire("keydown", e2, el$2.value);
  };
  var handleKeyup = (e2) => {
    fire("keyup", e2, el$2.value);
  };
  var handleKeypress = (e2) => {
    fire("keypress", e2, el$2.value);
  };
  return {
    handleKeydown,
    handleKeyup,
    handleKeypress
  };
};
var phone3 = function phone4(props, context, dependencies2) {
  var {
    fire,
    model,
    input,
    el$: el$2
  } = dependencies2;
  var handleKeydown = (e2) => {
    if (el$2.value.maskPluginInstalled) {
      return;
    }
    if (["Backspace", "Delete", "Tab", "Escape", "Enter", "ArrowLeft", "ArrowRight"].indexOf(e2.key) !== -1 || e2.ctrlKey || e2.metaKey) {
      return;
    }
    if (/[0-9]/.test(e2.key) && (!model.value || model.value.length < 16)) {
      return;
    }
    if (e2.key === "+" && (!model.value || input.value.selectionStart === 0) && (!model.value || model.value.length < 16)) {
      return;
    }
    e2.preventDefault();
  };
  return {
    handleKeydown
  };
};
var PhoneElement = {
  name: "PhoneElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "open", "close", "blur", "focus", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "text",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    include: {
      required: false,
      type: [Array],
      default: () => []
    },
    exclude: {
      required: false,
      type: [Array],
      default: () => []
    },
    unmask: {
      require: false,
      type: [Boolean],
      default: false
    },
    allowIncomplete: {
      require: false,
      type: [Boolean],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$H, base$1e, base$Q, base$T, base$C, text$1, base$16, text$2, base$I, base$M, base$J, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, phone$1, base$s, base$b, phone$2, base$G, base$V, phone3, base$t, base$a];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$8 = function base71(props, context, dependencies2) {
  var {
    radioName,
    radioValue
  } = toRefs(props);
  var update = dependencies2.update;
  var nullValue = dependencies2.nullValue;
  var fieldId = dependencies2.fieldId;
  var path = dependencies2.path;
  var form$ = dependencies2.form$;
  var listeners = ref([]);
  var inputName = computed(() => {
    return radioName.value || path.value;
  });
  var check2 = () => {
    update(radioValue.value);
  };
  var uncheck = () => {
    update(nullValue.value);
  };
  var watchChange = (value, old) => {
    if (old) {
      form$.value.$el.querySelectorAll('input[name="'.concat(old, '"')).forEach((element2, i) => {
        if (listeners.value[i]) {
          element2.removeEventListener("change", listeners.value[i]);
        }
      });
    }
    form$.value.$el.querySelectorAll('input[name="'.concat(value, '"')).forEach((element2) => {
      var listener = () => {
        if (element2.id != fieldId.value) {
          update(nullValue.value);
        }
      };
      listeners.value.push(listener);
      element2.addEventListener("change", listener);
    });
  };
  onMounted(() => {
    watchChange(inputName.value);
  });
  watch(inputName, watchChange);
  return {
    inputName,
    check: check2,
    uncheck
  };
};
var RadioElement = {
  name: "RadioElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "radio",
      private: true
    },
    default: {
      required: false,
      type: [String, Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    radioName: {
      required: false,
      type: [String],
      default: null
    },
    radioValue: {
      required: false,
      type: [Boolean, String, Number],
      default: 1
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$W, base$1e, base$Q, base$T, base$L, base$D, base$16, base$E, base$M, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$8, radio, base$G, base$V, base$A];
    context.slots = ["default", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var RadiogroupElement = {
  name: "RadiogroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "radiogroup",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Boolean],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$P, base$L, base$W, base$1e, base$Q, radiogroup$2, base$D, base$M, radiogroup, base$16, base$E, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, radiogroup$1, base$G, base$V];
    context.slots = ["radio", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var SelectElement = {
  name: "SelectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "select",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    native: {
      required: false,
      type: [Boolean],
      default: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label"
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value"
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: void 0,
      native: false
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    create: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"],
      native: false
    },
    allowAbsent: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    object: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items",
      native: false
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom",
      native: false
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canDeselect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: false
    },
    delay: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0,
      native: false
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    truncate: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true,
      native: false
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true,
      native: false
    },
    autocomplete: {
      type: [String],
      required: false,
      native: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text",
      native: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, select$4, base$P, base$L, base$W, base$H, base$1e, base$Q, base$T, base$D, base$E, base$I, select$1, base$M, select$2, base$16, base$J, select$3, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$d, select5, base$S, base$G, base$V, base$t];
    context.slots = ["option", "single-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var Point = class {
  constructor(x, y, pressure, time2) {
    if (isNaN(x) || isNaN(y)) {
      throw new Error(`Point is invalid: (${x}, ${y})`);
    }
    this.x = +x;
    this.y = +y;
    this.pressure = pressure || 0;
    this.time = time2 || Date.now();
  }
  distanceTo(start) {
    return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
  }
  equals(other) {
    return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;
  }
  velocityFrom(start) {
    return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;
  }
};
var Bezier = class _Bezier {
  static fromPoints(points, widths) {
    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
    return new _Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
  }
  static calculateControlPoints(s1, s2, s3) {
    const dx1 = s1.x - s2.x;
    const dy1 = s1.y - s2.y;
    const dx2 = s2.x - s3.x;
    const dy2 = s2.y - s3.y;
    const m1 = { x: (s1.x + s2.x) / 2, y: (s1.y + s2.y) / 2 };
    const m2 = { x: (s2.x + s3.x) / 2, y: (s2.y + s3.y) / 2 };
    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
    const dxm = m1.x - m2.x;
    const dym = m1.y - m2.y;
    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);
    const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
    const tx = s2.x - cm.x;
    const ty = s2.y - cm.y;
    return {
      c1: new Point(m1.x + tx, m1.y + ty),
      c2: new Point(m2.x + tx, m2.y + ty)
    };
  }
  constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {
    this.startPoint = startPoint;
    this.control2 = control2;
    this.control1 = control1;
    this.endPoint = endPoint;
    this.startWidth = startWidth;
    this.endWidth = endWidth;
  }
  length() {
    const steps = 10;
    let length = 0;
    let px;
    let py;
    for (let i = 0; i <= steps; i += 1) {
      const t2 = i / steps;
      const cx = this.point(t2, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
      const cy = this.point(t2, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
      if (i > 0) {
        const xdiff = cx - px;
        const ydiff = cy - py;
        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
      }
      px = cx;
      py = cy;
    }
    return length;
  }
  point(t2, start, c1, c2, end) {
    return start * (1 - t2) * (1 - t2) * (1 - t2) + 3 * c1 * (1 - t2) * (1 - t2) * t2 + 3 * c2 * (1 - t2) * t2 * t2 + end * t2 * t2 * t2;
  }
};
var SignatureEventTarget = class {
  constructor() {
    try {
      this._et = new EventTarget();
    } catch (error) {
      this._et = document;
    }
  }
  addEventListener(type, listener, options) {
    this._et.addEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._et.dispatchEvent(event);
  }
  removeEventListener(type, callback57, options) {
    this._et.removeEventListener(type, callback57, options);
  }
};
function throttle(fn, wait = 250) {
  let previous = 0;
  let timeout = null;
  let result;
  let storedContext;
  let storedArgs;
  const later = () => {
    previous = Date.now();
    timeout = null;
    result = fn.apply(storedContext, storedArgs);
    if (!timeout) {
      storedContext = null;
      storedArgs = [];
    }
  };
  return function wrapper(...args) {
    const now = Date.now();
    const remaining = wait - (now - previous);
    storedContext = this;
    storedArgs = args;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = fn.apply(storedContext, storedArgs);
      if (!timeout) {
        storedContext = null;
        storedArgs = [];
      }
    } else if (!timeout) {
      timeout = window.setTimeout(later, remaining);
    }
    return result;
  };
}
var SignaturePad = class _SignaturePad extends SignatureEventTarget {
  constructor(canvas, options = {}) {
    var _a, _b, _c;
    super();
    this.canvas = canvas;
    this._drawingStroke = false;
    this._isEmpty = true;
    this._lastPoints = [];
    this._data = [];
    this._lastVelocity = 0;
    this._lastWidth = 0;
    this._handleMouseDown = (event) => {
      if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {
        return;
      }
      this._strokeBegin(this._pointerEventToSignatureEvent(event));
    };
    this._handleMouseMove = (event) => {
      if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {
        this._strokeEnd(this._pointerEventToSignatureEvent(event), false);
        return;
      }
      this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));
    };
    this._handleMouseUp = (event) => {
      if (this._isLeftButtonPressed(event)) {
        return;
      }
      this._strokeEnd(this._pointerEventToSignatureEvent(event));
    };
    this._handleTouchStart = (event) => {
      if (event.targetTouches.length !== 1 || this._drawingStroke) {
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      this._strokeBegin(this._touchEventToSignatureEvent(event));
    };
    this._handleTouchMove = (event) => {
      if (event.targetTouches.length !== 1) {
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!this._drawingStroke) {
        this._strokeEnd(this._touchEventToSignatureEvent(event), false);
        return;
      }
      this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));
    };
    this._handleTouchEnd = (event) => {
      if (event.targetTouches.length !== 0) {
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      this.canvas.removeEventListener("touchmove", this._handleTouchMove);
      this._strokeEnd(this._touchEventToSignatureEvent(event));
    };
    this._handlePointerDown = (event) => {
      if (!this._isLeftButtonPressed(event) || this._drawingStroke) {
        return;
      }
      event.preventDefault();
      this._strokeBegin(this._pointerEventToSignatureEvent(event));
    };
    this._handlePointerMove = (event) => {
      if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {
        this._strokeEnd(this._pointerEventToSignatureEvent(event), false);
        return;
      }
      event.preventDefault();
      this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));
    };
    this._handlePointerUp = (event) => {
      if (this._isLeftButtonPressed(event)) {
        return;
      }
      event.preventDefault();
      this._strokeEnd(this._pointerEventToSignatureEvent(event));
    };
    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
    this.minWidth = options.minWidth || 0.5;
    this.maxWidth = options.maxWidth || 2.5;
    this.throttle = (_a = options.throttle) !== null && _a !== void 0 ? _a : 16;
    this.minDistance = (_b = options.minDistance) !== null && _b !== void 0 ? _b : 5;
    this.dotSize = options.dotSize || 0;
    this.penColor = options.penColor || "black";
    this.backgroundColor = options.backgroundColor || "rgba(0,0,0,0)";
    this.compositeOperation = options.compositeOperation || "source-over";
    this.canvasContextOptions = (_c = options.canvasContextOptions) !== null && _c !== void 0 ? _c : {};
    this._strokeMoveUpdate = this.throttle ? throttle(_SignaturePad.prototype._strokeUpdate, this.throttle) : _SignaturePad.prototype._strokeUpdate;
    this._ctx = canvas.getContext("2d", this.canvasContextOptions);
    this.clear();
    this.on();
  }
  clear() {
    const { _ctx: ctx, canvas } = this;
    ctx.fillStyle = this.backgroundColor;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    this._data = [];
    this._reset(this._getPointGroupOptions());
    this._isEmpty = true;
  }
  fromDataURL(dataUrl, options = {}) {
    return new Promise((resolve, reject) => {
      const image2 = new Image();
      const ratio = options.ratio || window.devicePixelRatio || 1;
      const width = options.width || this.canvas.width / ratio;
      const height = options.height || this.canvas.height / ratio;
      const xOffset = options.xOffset || 0;
      const yOffset = options.yOffset || 0;
      this._reset(this._getPointGroupOptions());
      image2.onload = () => {
        this._ctx.drawImage(image2, xOffset, yOffset, width, height);
        resolve();
      };
      image2.onerror = (error) => {
        reject(error);
      };
      image2.crossOrigin = "anonymous";
      image2.src = dataUrl;
      this._isEmpty = false;
    });
  }
  toDataURL(type = "image/png", encoderOptions) {
    switch (type) {
      case "image/svg+xml":
        if (typeof encoderOptions !== "object") {
          encoderOptions = void 0;
        }
        return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;
      default:
        if (typeof encoderOptions !== "number") {
          encoderOptions = void 0;
        }
        return this.canvas.toDataURL(type, encoderOptions);
    }
  }
  on() {
    this.canvas.style.touchAction = "none";
    this.canvas.style.msTouchAction = "none";
    this.canvas.style.userSelect = "none";
    const isIOS = /Macintosh/.test(navigator.userAgent) && "ontouchstart" in document;
    if (window.PointerEvent && !isIOS) {
      this._handlePointerEvents();
    } else {
      this._handleMouseEvents();
      if ("ontouchstart" in window) {
        this._handleTouchEvents();
      }
    }
  }
  off() {
    this.canvas.style.touchAction = "auto";
    this.canvas.style.msTouchAction = "auto";
    this.canvas.style.userSelect = "auto";
    this.canvas.removeEventListener("pointerdown", this._handlePointerDown);
    this.canvas.removeEventListener("mousedown", this._handleMouseDown);
    this.canvas.removeEventListener("touchstart", this._handleTouchStart);
    this._removeMoveUpEventListeners();
  }
  _getListenerFunctions() {
    var _a;
    const canvasWindow = window.document === this.canvas.ownerDocument ? window : (_a = this.canvas.ownerDocument.defaultView) !== null && _a !== void 0 ? _a : this.canvas.ownerDocument;
    return {
      addEventListener: canvasWindow.addEventListener.bind(canvasWindow),
      removeEventListener: canvasWindow.removeEventListener.bind(canvasWindow)
    };
  }
  _removeMoveUpEventListeners() {
    const { removeEventListener } = this._getListenerFunctions();
    removeEventListener("pointermove", this._handlePointerMove);
    removeEventListener("pointerup", this._handlePointerUp);
    removeEventListener("mousemove", this._handleMouseMove);
    removeEventListener("mouseup", this._handleMouseUp);
    removeEventListener("touchmove", this._handleTouchMove);
    removeEventListener("touchend", this._handleTouchEnd);
  }
  isEmpty() {
    return this._isEmpty;
  }
  fromData(pointGroups, { clear = true } = {}) {
    if (clear) {
      this.clear();
    }
    this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
    this._data = this._data.concat(pointGroups);
  }
  toData() {
    return this._data;
  }
  _isLeftButtonPressed(event, only) {
    if (only) {
      return event.buttons === 1;
    }
    return (event.buttons & 1) === 1;
  }
  _pointerEventToSignatureEvent(event) {
    return {
      event,
      type: event.type,
      x: event.clientX,
      y: event.clientY,
      pressure: "pressure" in event ? event.pressure : 0
    };
  }
  _touchEventToSignatureEvent(event) {
    const touch = event.changedTouches[0];
    return {
      event,
      type: event.type,
      x: touch.clientX,
      y: touch.clientY,
      pressure: touch.force
    };
  }
  _getPointGroupOptions(group7) {
    return {
      penColor: group7 && "penColor" in group7 ? group7.penColor : this.penColor,
      dotSize: group7 && "dotSize" in group7 ? group7.dotSize : this.dotSize,
      minWidth: group7 && "minWidth" in group7 ? group7.minWidth : this.minWidth,
      maxWidth: group7 && "maxWidth" in group7 ? group7.maxWidth : this.maxWidth,
      velocityFilterWeight: group7 && "velocityFilterWeight" in group7 ? group7.velocityFilterWeight : this.velocityFilterWeight,
      compositeOperation: group7 && "compositeOperation" in group7 ? group7.compositeOperation : this.compositeOperation
    };
  }
  _strokeBegin(event) {
    const cancelled = !this.dispatchEvent(new CustomEvent("beginStroke", { detail: event, cancelable: true }));
    if (cancelled) {
      return;
    }
    const { addEventListener } = this._getListenerFunctions();
    switch (event.event.type) {
      case "mousedown":
        addEventListener("mousemove", this._handleMouseMove);
        addEventListener("mouseup", this._handleMouseUp);
        break;
      case "touchstart":
        addEventListener("touchmove", this._handleTouchMove);
        addEventListener("touchend", this._handleTouchEnd);
        break;
      case "pointerdown":
        addEventListener("pointermove", this._handlePointerMove);
        addEventListener("pointerup", this._handlePointerUp);
        break;
    }
    this._drawingStroke = true;
    const pointGroupOptions = this._getPointGroupOptions();
    const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });
    this._data.push(newPointGroup);
    this._reset(pointGroupOptions);
    this._strokeUpdate(event);
  }
  _strokeUpdate(event) {
    if (!this._drawingStroke) {
      return;
    }
    if (this._data.length === 0) {
      this._strokeBegin(event);
      return;
    }
    this.dispatchEvent(new CustomEvent("beforeUpdateStroke", { detail: event }));
    const point = this._createPoint(event.x, event.y, event.pressure);
    const lastPointGroup = this._data[this._data.length - 1];
    const lastPoints = lastPointGroup.points;
    const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
    const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;
    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);
    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
      const curve = this._addPoint(point, pointGroupOptions);
      if (!lastPoint) {
        this._drawDot(point, pointGroupOptions);
      } else if (curve) {
        this._drawCurve(curve, pointGroupOptions);
      }
      lastPoints.push({
        time: point.time,
        x: point.x,
        y: point.y,
        pressure: point.pressure
      });
    }
    this.dispatchEvent(new CustomEvent("afterUpdateStroke", { detail: event }));
  }
  _strokeEnd(event, shouldUpdate = true) {
    this._removeMoveUpEventListeners();
    if (!this._drawingStroke) {
      return;
    }
    if (shouldUpdate) {
      this._strokeUpdate(event);
    }
    this._drawingStroke = false;
    this.dispatchEvent(new CustomEvent("endStroke", { detail: event }));
  }
  _handlePointerEvents() {
    this._drawingStroke = false;
    this.canvas.addEventListener("pointerdown", this._handlePointerDown);
  }
  _handleMouseEvents() {
    this._drawingStroke = false;
    this.canvas.addEventListener("mousedown", this._handleMouseDown);
  }
  _handleTouchEvents() {
    this.canvas.addEventListener("touchstart", this._handleTouchStart);
  }
  _reset(options) {
    this._lastPoints = [];
    this._lastVelocity = 0;
    this._lastWidth = (options.minWidth + options.maxWidth) / 2;
    this._ctx.fillStyle = options.penColor;
    this._ctx.globalCompositeOperation = options.compositeOperation;
  }
  _createPoint(x, y, pressure) {
    const rect = this.canvas.getBoundingClientRect();
    return new Point(x - rect.left, y - rect.top, pressure, (/* @__PURE__ */ new Date()).getTime());
  }
  _addPoint(point, options) {
    const { _lastPoints } = this;
    _lastPoints.push(point);
    if (_lastPoints.length > 2) {
      if (_lastPoints.length === 3) {
        _lastPoints.unshift(_lastPoints[0]);
      }
      const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);
      const curve = Bezier.fromPoints(_lastPoints, widths);
      _lastPoints.shift();
      return curve;
    }
    return null;
  }
  _calculateCurveWidths(startPoint, endPoint, options) {
    const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;
    const newWidth = this._strokeWidth(velocity, options);
    const widths = {
      end: newWidth,
      start: this._lastWidth
    };
    this._lastVelocity = velocity;
    this._lastWidth = newWidth;
    return widths;
  }
  _strokeWidth(velocity, options) {
    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);
  }
  _drawCurveSegment(x, y, width) {
    const ctx = this._ctx;
    ctx.moveTo(x, y);
    ctx.arc(x, y, width, 0, 2 * Math.PI, false);
    this._isEmpty = false;
  }
  _drawCurve(curve, options) {
    const ctx = this._ctx;
    const widthDelta = curve.endWidth - curve.startWidth;
    const drawSteps = Math.ceil(curve.length()) * 2;
    ctx.beginPath();
    ctx.fillStyle = options.penColor;
    for (let i = 0; i < drawSteps; i += 1) {
      const t2 = i / drawSteps;
      const tt = t2 * t2;
      const ttt = tt * t2;
      const u = 1 - t2;
      const uu = u * u;
      const uuu = uu * u;
      let x = uuu * curve.startPoint.x;
      x += 3 * uu * t2 * curve.control1.x;
      x += 3 * u * tt * curve.control2.x;
      x += ttt * curve.endPoint.x;
      let y = uuu * curve.startPoint.y;
      y += 3 * uu * t2 * curve.control1.y;
      y += 3 * u * tt * curve.control2.y;
      y += ttt * curve.endPoint.y;
      const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
      this._drawCurveSegment(x, y, width);
    }
    ctx.closePath();
    ctx.fill();
  }
  _drawDot(point, options) {
    const ctx = this._ctx;
    const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;
    ctx.beginPath();
    this._drawCurveSegment(point.x, point.y, width);
    ctx.closePath();
    ctx.fillStyle = options.penColor;
    ctx.fill();
  }
  _fromData(pointGroups, drawCurve, drawDot) {
    for (const group7 of pointGroups) {
      const { points } = group7;
      const pointGroupOptions = this._getPointGroupOptions(group7);
      if (points.length > 1) {
        for (let j = 0; j < points.length; j += 1) {
          const basicPoint = points[j];
          const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
          if (j === 0) {
            this._reset(pointGroupOptions);
          }
          const curve = this._addPoint(point, pointGroupOptions);
          if (curve) {
            drawCurve(curve, pointGroupOptions);
          }
        }
      } else {
        this._reset(pointGroupOptions);
        drawDot(points[0], pointGroupOptions);
      }
    }
  }
  toSVG({ includeBackgroundColor = false } = {}) {
    const pointGroups = this._data;
    const ratio = Math.max(window.devicePixelRatio || 1, 1);
    const minX = 0;
    const minY = 0;
    const maxX = this.canvas.width / ratio;
    const maxY = this.canvas.height / ratio;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    svg.setAttribute("viewBox", `${minX} ${minY} ${maxX} ${maxY}`);
    svg.setAttribute("width", maxX.toString());
    svg.setAttribute("height", maxY.toString());
    if (includeBackgroundColor && this.backgroundColor) {
      const rect = document.createElement("rect");
      rect.setAttribute("width", "100%");
      rect.setAttribute("height", "100%");
      rect.setAttribute("fill", this.backgroundColor);
      svg.appendChild(rect);
    }
    this._fromData(pointGroups, (curve, { penColor }) => {
      const path = document.createElement("path");
      if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
        const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
        path.setAttribute("d", attr);
        path.setAttribute("stroke-width", (curve.endWidth * 2.25).toFixed(3));
        path.setAttribute("stroke", penColor);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-linecap", "round");
        svg.appendChild(path);
      }
    }, (point, { penColor, dotSize, minWidth, maxWidth }) => {
      const circle = document.createElement("circle");
      const size2 = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
      circle.setAttribute("r", size2.toString());
      circle.setAttribute("cx", point.x.toString());
      circle.setAttribute("cy", point.y.toString());
      circle.setAttribute("fill", penColor);
      svg.appendChild(circle);
    });
    return svg.outerHTML;
  }
};
function debounce(func, wait, onStart) {
  var timeout;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!timeout) {
      onStart();
    } else {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      timeout = null;
      func.apply(this, args);
    }, wait);
  };
}
function useSignature(props, context, dependencies2) {
  var {
    fonts,
    colors,
    modes,
    accept,
    maxWidth,
    height,
    readonly,
    maxFontSize,
    minFontSize,
    canClear,
    line,
    placeholder,
    autoload,
    maxSize,
    canUndo,
    columns,
    uploadWidth,
    uploadHeight,
    canDrop
  } = toRefs(props);
  var {
    el$: el$2,
    form$,
    input,
    isDisabled,
    value,
    Placeholder,
    available
  } = dependencies2;
  var mode$ = ref(null);
  var font$ = ref(null);
  var input$ = ref(null);
  var preview$ = ref(null);
  var pad$ = ref(null);
  var file$ = ref(null);
  var upload$ = ref(null);
  var uploadButton$ = ref(null);
  var mode = ref(null);
  var fontFamily = ref(null);
  var fontWeight = ref(null);
  var fontSize = ref(maxFontSize.value);
  var color = ref(null);
  var text5 = ref(null);
  var pad2 = ref(null);
  var image2 = ref(null);
  var created = ref(false);
  var creating = ref(false);
  var dragging = ref(false);
  var drawn = ref(false);
  var drawing = ref(false);
  var redos = ref([]);
  var undosLeft = ref(0);
  var width = ref(0);
  var lastWidth = ref(0);
  var isMouseOver = ref(false);
  var debouncer = ref(0);
  var fontFamilies = computed(() => {
    return fonts.value.map((f) => f.split("@")[0].replace("!", ""));
  });
  var fontWeights = computed(() => {
    return fonts.value.map((f) => f.split("@")[1] || 400);
  });
  var uploaded = computed(() => {
    return typeof value.value === "string";
  });
  var processing = computed(() => {
    return image2.value && !created.value;
  });
  var droppable = computed(() => {
    var div = document.createElement("div");
    return ("draggable" in div || "ondragstart" in div && "ondrop" in div) && "FormData" in window && "FileReader" in window && canDrop.value;
  });
  var resolvedModes = computed(() => {
    return modes.value.filter((m) => ["type", "draw", "upload"].indexOf(m) !== -1).map((mode2, i) => {
      return {
        label: form$.value.translations.vueform.elements.signature[mode2],
        value: mode2,
        index: i
      };
    });
  });
  var resolvedFonts = computed(() => {
    return fontFamilies.value.map((font, i) => {
      var _text$value;
      return {
        label: '<div><span style="font-family: '.concat(font, "; font-weight: ").concat(fontWeights.value[i], '" aria-hidden="true">').concat(((_text$value = text5.value) === null || _text$value === void 0 ? void 0 : _text$value.trim()) || form$.value.translations.vueform.elements.signature.fontPlaceholder, '</span><span style="position: absolute; left: -9999px; opacity: 0;">').concat(font, "</span></div>"),
        value: i,
        index: i
      };
    });
  });
  var fileAccept = computed(() => {
    return accept.value.reduce((prev, curr) => {
      switch (curr) {
        case "jpg":
        case "jpeg":
          prev.push("image/jpeg");
          break;
        case "png":
          prev.push("image/png");
          break;
        case "svg":
          prev.push("image/svg+xml");
          break;
      }
      return prev;
    }, []).join(", ");
  });
  var showLine = computed(() => {
    return mode.value !== "upload" && line.value;
  });
  var showInput = computed(() => {
    return !uploaded.value && mode.value === "type";
  });
  var showPlaceholder = computed(() => {
    return (!text5.value && mode.value === "type" || !drawn.value && mode.value === "draw") && placeholder.value !== false;
  });
  var showUploadContainer = computed(() => {
    return mode.value === "upload";
  });
  var showUpload = computed(() => {
    return mode.value === "upload" && !created.value;
  });
  var showPreview = computed(() => {
    return mode.value === "upload" && created.value;
  });
  var showPad = computed(() => {
    return mode.value === "draw";
  });
  var showUndos = computed(() => {
    return mode.value === "draw" && (redos.value.length || drawn.value) && !drawing.value && canUndo.value;
  });
  var showColors = computed(() => {
    return (mode.value === "upload" && created.value || mode.value === "type" || mode.value === "draw") && !drawing.value && colors.value.length > 1 && !isMouseOver.value;
  });
  var showModes = computed(() => {
    return !drawing.value && modes.value.length > 1;
  });
  var showFonts = computed(() => {
    return mode.value === "type" && resolvedFonts.value.length > 1;
  });
  var showClear = computed(() => {
    return (mode.value === "type" && text5.value || mode.value === "upload" && created.value || mode.value === "draw" && drawn.value || uploaded.value) && !isDisabled.value && !readonly.value && !drawing.value && canClear.value;
  });
  var tabindex = computed(() => {
    return isDisabled.value || readonly.value ? void 0 : 0;
  });
  var placeholderText = computed(() => {
    return Placeholder.value || form$.value.translations.vueform.elements.signature.placeholder;
  });
  var dndText = computed(() => {
    return "Drop an image here or";
  });
  var uploadButtonText = computed(() => {
    return "Select image";
  });
  var imgAltText = computed(() => {
    return form$.value.translations.vueform.elements.signature.imgAlt;
  });
  var imgTitleText = computed(() => {
    return form$.value.translations.vueform.elements.signature.imgTitle;
  });
  var fontText = computed(() => {
    return form$.value.translations.vueform.elements.signature.font;
  });
  var undoText = computed(() => {
    return form$.value.translations.vueform.elements.signature.undo;
  });
  var redoText = computed(() => {
    return form$.value.translations.vueform.elements.signature.redo;
  });
  var modeSelectorAria = computed(() => {
    return {
      "aria-label": form$.value.translations.vueform.elements.signature.modeSelectorAriaLabel
    };
  });
  var fontSelectorAria = computed(() => {
    return {
      "aria-label": form$.value.translations.vueform.elements.signature.fontSelectorAriaLabel
    };
  });
  var wrapperAriaLabel = computed(() => {
    return form$.value.translations.vueform.elements.signature.wrapperAriaLabel;
  });
  var inputAriaLabel = computed(() => {
    return form$.value.translations.vueform.elements.signature.inputAriaLabel;
  });
  var padAriaLabel = computed(() => {
    return form$.value.translations.vueform.elements.signature.padAriaLabel;
  });
  var clearAriaLabel = computed(() => {
    return form$.value.translations.vueform.elements.signature.clearAriaLabel;
  });
  var colorAriaLabel = computed(() => {
    return form$.value.translations.vueform.elements.signature.colorAriaLabel;
  });
  var padWidth = computed(() => {
    return width.value * 2;
  });
  var padHeight = computed(() => {
    return height.value * 2;
  });
  var padStyle = computed(() => {
    return {
      width: "".concat(width.value, "px"),
      height: "".concat(height.value, "px")
    };
  });
  var wrapperStyle = computed(() => {
    var style = {
      height: "".concat(height.value, "px")
    };
    if (maxWidth.value !== "auto") {
      style.maxWidth = "".concat(maxWidth.value, "px");
    }
    return style;
  });
  var inputStyle = computed(() => {
    return {
      fontFamily: fontFamily.value,
      fontWeight: fontWeight.value,
      fontSize: "".concat(fontSize.value, "px"),
      lineHeight: "".concat(fontSize.value, "px"),
      color: color.value,
      "-webkit-font-smoothing": "auto"
    };
  });
  var lineStyle = computed(() => {
    return {
      transform: "translateY(calc(".concat(fontSize.value / 2.2, "px))")
    };
  });
  var initPad = () => {
    if (pad2.value || !pad$.value || modes.value.indexOf("draw") === -1 && modes.value.length || !available.value) {
      return;
    }
    if (!width.value) {
      setWidth();
    }
    nextTick(() => {
      pad2.value = new SignaturePad(pad$.value);
      var ctx = pad$.value.getContext("2d");
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(2, 2);
      setDrawColor();
      pad2.value.addEventListener("beginStroke", (e2) => {
        if (isDisabled.value || readonly.value) {
          e2.preventDefault();
          return;
        }
        isMouseOver.value = true;
        drawn.value = true;
        drawing.value = true;
        redos.value = [];
      });
      pad2.value.addEventListener("endStroke", () => {
        drawing.value = false;
        undosLeft.value++;
        debounceTransform(drawingToImage, 500);
      });
    });
  };
  var resizePad = () => {
    setWidth();
    nextTick(() => {
      var ctx = pad$.value.getContext("2d");
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(2, 2);
      clearDrawnSignature();
    });
  };
  var drawingToImage = () => {
    return new Promise((resolve, reject) => {
      var originalCanvas = pad$.value;
      var originalCtx = originalCanvas.getContext("2d");
      var imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
      var data = imageData.data;
      var minX = originalCanvas.width, minY = originalCanvas.height, maxX = 0, maxY = 0;
      for (var y = 0; y < originalCanvas.height; y++) {
        for (var x = 0; x < originalCanvas.width; x++) {
          var index2 = (y * originalCanvas.width + x) * 4;
          if (data[index2 + 3] > 0) {
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (minX > maxX || minY > maxY) {
        reject(new Error("No drawing found on the canvas."));
        return;
      }
      var drawingWidth = maxX - minX + 1;
      var drawingHeight = maxY - minY + 1;
      var drawingCanvas = document.createElement("canvas");
      var drawingCtx = drawingCanvas.getContext("2d");
      drawingCanvas.width = drawingWidth;
      drawingCanvas.height = drawingHeight;
      drawingCtx.putImageData(imageData, -minX, -minY);
      var resizedCanvas = document.createElement("canvas");
      var resizedCtx = resizedCanvas.getContext("2d");
      var resizedWidth = uploadWidth.value;
      var resizedHeight = uploadHeight.value;
      resizedCanvas.width = resizedWidth;
      resizedCanvas.height = resizedHeight;
      var targetWidth = drawingWidth;
      var targetHeight = drawingHeight;
      if (targetWidth > resizedWidth || targetHeight > resizedHeight) {
        if (targetWidth / targetHeight > resizedWidth / resizedHeight) {
          targetWidth = resizedWidth;
          targetHeight = Math.floor(resizedWidth / drawingWidth * drawingHeight);
        } else {
          targetHeight = resizedHeight;
          targetWidth = Math.floor(resizedHeight / drawingHeight * drawingWidth);
        }
      }
      var offsetX = Math.floor((resizedWidth - targetWidth) / 2);
      var offsetY = Math.floor((resizedHeight - targetHeight) / 2);
      resizedCtx.drawImage(drawingCanvas, 0, 0, drawingWidth, drawingHeight, offsetX, offsetY, targetWidth, targetHeight);
      resizedCanvas.toBlob(function(blob) {
        value.value = blob;
        resolve();
        resizedCanvas.remove();
      }, "image/png");
    });
  };
  var typingToImage = () => {
    return new Promise((resolve, reject) => {
      if (!text5.value) {
        reject(new Error("No signature was typed."));
        return;
      }
      var canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      var displayWidth = uploadWidth.value;
      var displayHeight = uploadHeight.value;
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      nextTick(() => {
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        var fontSize2 = displayHeight / 2;
        ctx.font = "".concat(fontWeight.value, " ").concat(fontSize2, "px ").concat(fontFamily.value);
        var textWidth = ctx.measureText(text5.value).width;
        while (textWidth > displayWidth - 10 && fontSize2 > 10) {
          fontSize2 -= 1;
          ctx.font = "".concat(fontWeight.value, " ").concat(fontSize2, "px ").concat(fontFamily.value);
          textWidth = ctx.measureText(text5.value).width;
        }
        ctx.fillStyle = color.value;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text5.value, displayWidth / 2, displayHeight / 2);
        canvas.toBlob(function(blob) {
          value.value = blob;
          canvas.remove();
          resolve();
        }, "image/png");
      });
    });
  };
  var uploadToImage = () => {
    if (!image2.value) {
      return;
    }
    var file6 = image2.value;
    var reader = new FileReader();
    creating.value = true;
    reader.onload = function(e2) {
      var img = new Image();
      img.onload = function() {
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var data = imageData.data;
        var colorHex = color.value;
        var colorRGB = hexToRgb(colorHex);
        var threshold = 220;
        for (var i = 0; i < data.length; i += 4) {
          var r2 = data[i];
          var g = data[i + 1];
          var b = data[i + 2];
          if (r2 > threshold && g > threshold && b > threshold) {
            data[i + 3] = 0;
          } else {
            data[i] = colorRGB.r;
            data[i + 1] = colorRGB.g;
            data[i + 2] = colorRGB.b;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        var mainCanvas = preview$.value;
        var mainCtx = mainCanvas.getContext("2d");
        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        var targetWidth = uploadWidth.value;
        var targetHeight = uploadHeight.value;
        var newWidth = targetWidth;
        var newHeight = newWidth / (img.width / img.height);
        if (newHeight > targetHeight) {
          newHeight = targetHeight;
          newWidth = newHeight * (img.width / img.height);
        }
        var xOffset = (targetWidth - newWidth) / 2;
        var yOffset = (targetHeight - newHeight) / 2;
        mainCtx.drawImage(canvas, 0, 0, img.width, img.height, xOffset, yOffset, newWidth, newHeight);
        mainCanvas.toBlob(function(blob) {
          value.value = blob;
          created.value = true;
          creating.value = false;
          canvas.remove();
        }, "image/png");
      };
      img.src = e2.target.result;
    };
    reader.readAsDataURL(file6);
  };
  var undo = () => {
    if (!pad2.value) {
      return;
    }
    var data = pad2.value.toData();
    if (!data.length) {
      return;
    }
    redos.value.push(data.pop());
    pad2.value.fromData(data);
    if (!data.length) {
      drawn.value = false;
    }
    undosLeft.value = data.length;
    debounceTransform(drawingToImage, 500);
  };
  var redo = () => {
    if (!pad2.value || !redos.value.length) {
      return;
    }
    var data = pad2.value.toData() || [];
    data.push(redos.value.pop());
    pad2.value.fromData(data);
    drawn.value = true;
    setDrawColor();
    undosLeft.value = data.length;
    debounceTransform(drawingToImage, 500);
  };
  var clearSignature = () => {
    text5.value = null;
    image2.value = null;
    created.value = false;
    value.value = null;
    clearDrawnSignature();
  };
  var clearDrawnSignature = () => {
    var _pad$value;
    (_pad$value = pad2.value) === null || _pad$value === void 0 || _pad$value.clear();
    drawn.value = false;
    redos.value = [];
  };
  var loadFonts = () => {
    fonts.value.forEach((font) => {
      var parts = font.split("@");
      var skip = parts[0].substr(0, 1) === "!";
      if (!skip) {
        var family = parts[0].replace("!", "").replace(/\s/g, "+");
        var weight = parts[1] || 400;
        var id = "font-".concat(family);
        if (!document.getElementById(id)) {
          var link = document.createElement("link");
          link.id = id;
          link.rel = "stylesheet";
          link.href = "https://fonts.googleapis.com/css2?family=".concat(family, ":wght@").concat(weight, "&display=swap");
          document.head.appendChild(link);
        }
      }
    });
  };
  var setDrawColor = () => {
    var {
      r: r2,
      g,
      b
    } = hexToRgb(color.value);
    pad2.value.penColor = "rgb(".concat(r2, ", ").concat(g, ", ").concat(b, ")");
    if (drawn.value) {
      pad2.value.fromData(pad2.value.toData().map((d) => {
        d.penColor = pad2.value.penColor;
        return d;
      }));
    }
  };
  var adjustFontSize = () => {
    if (!text5.value) {
      fontSize.value = maxFontSize.value;
      return;
    }
    var ua = navigator.userAgent.toLowerCase();
    var isSafari = ua.indexOf("safari") != -1 && ua.indexOf("chrome") == -1 && ua.indexOf("android") == -1;
    var inputElement = input$.value;
    var styles = window.getComputedStyle(inputElement);
    var textIndent = parseFloat(styles.textIndent);
    var paddingRight = parseFloat(styles.paddingRight);
    var maxWidth2 = Math.ceil(inputElement.getBoundingClientRect().width) - textIndent;
    var size2 = fontSize.value;
    while (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent > maxWidth2 && size2 > minFontSize.value) {
      size2--;
      inputElement.style.fontSize = size2 + "px";
    }
    while (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent <= maxWidth2 && size2 < maxFontSize.value) {
      inputElement.style.fontSize = size2 + 1 + "px";
      if (inputElement.scrollWidth + (isSafari ? paddingRight : 0) - textIndent > maxWidth2) {
        inputElement.style.fontSize = size2 + "px";
        break;
      }
      size2++;
    }
    fontSize.value = size2;
  };
  var hexToRgb = (hex) => {
    hex = hex.replace(/^#/, "");
    var bigint = parseInt(hex, 16);
    var r2 = bigint >> 16 & 255;
    var g = bigint >> 8 & 255;
    var b = bigint & 255;
    return {
      r: r2,
      g,
      b
    };
  };
  var checkFileExt = (file6) => {
    var accepted2 = accept.value.indexOf("jpg") !== -1 && accept.value.indexOf("jpeg") === -1 ? accept.value.concat(["jpeg"]) : accept.value;
    var valid = file6 && accepted2.indexOf(file6 === null || file6 === void 0 ? void 0 : file6.name.split(".").pop()) !== -1;
    if (!valid) {
      alert(form$.value.__(form$.value.translations.vueform.elements.signature.unsupportedFormat, {
        extensions: accept.value.join(", ")
      }));
      return false;
    }
    return true;
  };
  var checkFileSize = (file6) => {
    if (maxSize.value === -1) {
      return true;
    }
    if (file6.size / 1024 > maxSize.value) {
      alert(form$.value.__(form$.value.translations.vueform.elements.signature.maxSizeError, {
        max: maxSize.value
      }));
      return false;
    }
    return true;
  };
  var setWidth = () => {
    width.value = input.value.getBoundingClientRect().width;
  };
  var setLastWidth = () => {
    lastWidth.value = input.value.getBoundingClientRect().width;
  };
  var setDefaultMode = function setDefaultMode2() {
    var setDropdown = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    mode.value = modes.value[0] || "draw";
    if (setDropdown) {
      mode$.value.selected = resolvedModes.value[0] || {
        label: form$.value.translations.vueform.elements.signature.draw,
        value: "draw",
        index: 0
      };
    }
  };
  var setDefaultFont = function setDefaultFont2() {
    var setDropdown = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    fontFamily.value = fontFamilies.value[0] || "cursive";
    fontWeight.value = fontWeights.value[0] || 400;
    if (setDropdown) {
      font$.value.selected = {};
      font$.value.pointed = {};
    }
  };
  var setDefaultColor = () => {
    color.value = colors.value[0] || "#000000";
  };
  var setFont = (value2) => {
    fontFamily.value = fontFamilies.value[value2.index];
    fontWeight.value = fontWeights.value[value2.index];
  };
  var setImage = (file6) => {
    if (checkFileExt(file6) && checkFileSize(file6)) {
      image2.value = file6;
      uploadToImage(image2.value);
    } else {
      image2.value = null;
      created.value = false;
    }
  };
  var debounceTransform = function debounceTransform2(method) {
    var ms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    if (debouncer.value) {
      clearTimeout(debouncer.value);
    }
    debouncer.value = setTimeout(_asyncToGenerator(function* () {
      try {
        yield method.call();
      } catch (e2) {
        value.value = null;
      }
    }), ms);
  };
  var handleInput = (e2) => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    text5.value = e2.target.value;
  };
  var handleModeSelect = (value2) => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    mode.value = value2.value;
    nextTick(() => {
      if (mode.value === "draw") {
        pad$.value.focus();
      } else if (mode.value === "type") {
        input$.value.focus();
      } else if (mode.value === "upload") {
        uploadButton$.value.focus();
      }
    });
  };
  var handleColorSelect = (value2) => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    color.value = value2;
  };
  var handleFontSelect = (value2) => {
    font$.value.selected = {};
    if (isDisabled.value || readonly.value) {
      return;
    }
    setFont(value2);
  };
  var handleClear = () => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    if (!uploaded.value) {
      if (mode.value === "draw") {
        pad$.value.focus();
      } else if (mode.value === "type") {
        input$.value.focus();
      } else if (mode.value === "upload") {
        uploadButton$.value.focus();
      }
    }
    clearSignature();
    isMouseOver.value = false;
  };
  var handleUndo = () => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    undo();
    isMouseOver.value = false;
  };
  var handleRedo = () => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    redo();
    isMouseOver.value = false;
  };
  var handleSelectClick = () => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    file$.value.click();
  };
  var handleFileSelect = (event) => {
    if (isDisabled.value || readonly.value) {
      return;
    }
    var file6 = event.target.files[0];
    setImage(file6);
    file$.value.value = "";
  };
  var handleDrop = (e2) => {
    if (isDisabled.value || readonly.value || !droppable.value) {
      return;
    }
    var file6 = e2.dataTransfer.files[0];
    setImage(file6);
  };
  var handleMouseLeave = () => {
    isMouseOver.value = false;
  };
  var handleResize = () => {
    if (lastWidth.value === input.value.getBoundingClientRect().width) {
      return;
    }
    resizePad();
    adjustFontSize();
  };
  var handleResizeDebounce = debounce(handleResize, 200, () => {
    setLastWidth();
  });
  setDefaultMode();
  setDefaultFont();
  setDefaultColor();
  onMounted(() => {
    if (autoload.value) {
      loadFonts();
    }
    setWidth();
    if (mode$.value) {
      mode$.value.selected = resolvedModes.value[0] || {
        label: form$.value.translations.vueform.elements.signature.draw,
        value: "draw",
        index: 0
      };
    }
    var evts = ["drag", "dragstart", "dragenter", "dragleave", "dragend"];
    evts.forEach((event) => {
      input.value.addEventListener(event, (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        if (["dragleave", "dragend"].indexOf(event) === -1) {
          return;
        }
        if (isDisabled.value || !droppable.value) {
          return;
        }
        dragging.value = false;
      });
    });
    input.value.addEventListener("dragover", (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (isDisabled.value || !droppable.value) {
        return;
      }
      if (dragging.value !== true) {
        dragging.value = true;
      }
    });
    input.value.addEventListener("drop", (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (isDisabled.value || !droppable.value) {
        return;
      }
      handleDrop(e2);
      dragging.value = false;
    });
    nextTick(() => {
      initPad();
      window.addEventListener("resize", handleResizeDebounce);
    });
    watch(maxFontSize, () => {
      adjustFontSize();
    }, {
      flush: "post"
    });
    watch(modes, () => {
      initPad();
      setDefaultMode(true);
    });
    watch(available, () => {
      nextTick(() => {
        initPad();
      });
    }, {
      flush: "post"
    });
    watch(color, () => {
      if (pad2.value) {
        setDrawColor();
      }
      if (mode.value === "upload" && created.value && !creating.value) {
        uploadToImage();
      }
    });
    watch(columns, () => {
      setLastWidth();
      nextTick(() => {
        handleResize();
        if (mode.value === "upload" && created.value && !creating.value) {
          uploadToImage();
        }
      });
    });
    watch(mode, () => {
      clearSignature();
    });
    watch([height, maxWidth], () => {
      resizePad();
      adjustFontSize();
    }, {
      flush: "post"
    });
    watch([text5, fontFamily], () => {
      nextTick(() => {
        adjustFontSize();
      });
    }, {
      flush: "post"
    });
    watch(text5, () => {
      debounceTransform(typingToImage, 1e3);
    }, {
      flush: "post"
    });
    watch(fonts, () => {
      if (autoload.value) {
        loadFonts();
      }
    });
  });
  onBeforeUnmount(() => {
    window.removeEventListener("resize", handleResizeDebounce);
  });
  return {
    mode$,
    font$,
    input$,
    preview$,
    pad$,
    file$,
    upload$,
    uploadButton$,
    mode,
    fontFamily,
    fontWeight,
    color,
    text: text5,
    fontSize,
    pad: pad2,
    image: image2,
    created,
    creating,
    dragging,
    drawn,
    drawing,
    redos,
    undosLeft,
    width,
    lastWidth,
    fontFamilies,
    fontWeights,
    uploaded,
    processing,
    droppable,
    resolvedModes,
    resolvedFonts,
    fileAccept,
    showLine,
    showInput,
    showPlaceholder,
    showUploadContainer,
    showUpload,
    showPreview,
    showPad,
    showUndos,
    showColors,
    showModes,
    showFonts,
    showClear,
    tabindex,
    placeholderText,
    dndText,
    uploadButtonText,
    imgAltText,
    imgTitleText,
    fontText,
    undoText,
    redoText,
    modeSelectorAria,
    fontSelectorAria,
    wrapperAriaLabel,
    inputAriaLabel,
    padAriaLabel,
    colorAriaLabel,
    clearAriaLabel,
    padWidth,
    padHeight,
    padStyle,
    wrapperStyle,
    inputStyle,
    lineStyle,
    initPad,
    resizePad,
    drawingToImage,
    typingToImage,
    uploadToImage,
    undo,
    redo,
    clearSignature,
    clearDrawnSignature,
    loadFonts,
    setDrawColor,
    adjustFontSize,
    hexToRgb,
    checkFileExt,
    checkFileSize,
    setWidth,
    setLastWidth,
    setDefaultMode,
    setDefaultFont,
    setDefaultColor,
    setFont,
    handleInput,
    handleModeSelect,
    handleColorSelect,
    handleFontSelect,
    handleClear,
    handleUndo,
    handleRedo,
    handleSelectClick,
    handleFileSelect,
    handleDrop,
    handleMouseLeave,
    handleResize,
    handleResizeDebounce
  };
}
var SignatureElement = {
  name: "SignatureElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "text",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    modes: {
      required: false,
      type: [Array],
      default: () => ["draw", "type", "upload"]
    },
    fonts: {
      required: false,
      type: [Array],
      default: () => ["Caveat@400", "Sacramento@400", "Dancing Script@400"]
    },
    autoload: {
      required: false,
      type: [Boolean],
      default: true
    },
    minFontSize: {
      required: false,
      type: [Number],
      default: 10
    },
    maxFontSize: {
      required: false,
      type: [Number],
      default: 60
    },
    colors: {
      required: false,
      type: [Array],
      default: () => ["#000000", "#2558b2", "#f22f30"]
    },
    invertColors: {
      required: false,
      type: [Array],
      default: () => ["#000000"]
    },
    maxWidth: {
      required: false,
      type: [Number, String],
      default: "auto"
    },
    height: {
      required: false,
      type: [Number],
      default: 160
    },
    uploadWidth: {
      required: false,
      type: [Number],
      default: 480
    },
    uploadHeight: {
      required: false,
      type: [Number],
      default: 160
    },
    maxSize: {
      required: false,
      type: [Number],
      default: 2048
    },
    accept: {
      required: false,
      type: [Array],
      default: () => ["jpg", "png", "svg"]
    },
    placeholder: {
      required: false,
      type: [String, Object, Boolean],
      localized: true,
      default: null
    },
    line: {
      required: false,
      type: [Boolean],
      default: true
    },
    canClear: {
      required: false,
      type: [Boolean],
      default: true
    },
    canUndo: {
      required: false,
      type: [Boolean],
      default: true
    },
    canDrop: {
      required: false,
      type: [Boolean],
      default: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$1e, base$Q, base$T, base$C, base$D, base$16, base$E, base$M, base$J, base$t, useSignature, signature, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$s, base$S, base$G, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$7 = function base72(props, context, dependencies2) {
  var {
    lazy
  } = toRefs(props);
  var value = dependencies2.value;
  var handleUpdate = (val) => {
    if (lazy.value) {
      return;
    }
    value.value = val;
  };
  return {
    handleUpdate
  };
};
var SliderElement = {
  name: "SliderElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "slider",
      private: true
    },
    default: {
      required: false,
      type: [Number, Array],
      default: 0
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    min: {
      required: false,
      type: [Number],
      default: 0
    },
    max: {
      required: false,
      type: [Number],
      default: 100
    },
    step: {
      required: false,
      type: [Number],
      default: 1
    },
    tooltips: {
      required: false,
      type: [Boolean],
      default: true
    },
    showTooltip: {
      required: false,
      type: [String],
      default: "always"
    },
    tooltipPosition: {
      required: false,
      type: [String],
      default: null
    },
    merge: {
      required: false,
      type: [Number],
      default: -1
    },
    format: {
      required: false,
      type: [Object, Function],
      default: null
    },
    orientation: {
      required: false,
      type: [String],
      default: "horizontal"
    },
    direction: {
      required: false,
      type: [String],
      default: "ltr"
    },
    lazy: {
      required: false,
      type: [Boolean],
      default: true,
      private: true
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, min, base$W, base$1e, base$Q, base$T, base$D, slider2, base$M, slider$1, base$16, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$u, base$7, base$S, base$G, base$V];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$6 = function base73(props, context, dependencies2) {
  var {
    content
  } = toRefs(props);
  var {
    fieldSlots,
    el$: el$2
  } = dependencies2;
  var isHtml = computed(() => {
    return typeof resolvedContent.value === "string";
  });
  var resolvedContent = computed(() => {
    return typeof content.value === "function" ? content.value(el$2.value) : content.value;
  });
  var componentContent = computed(() => {
    var _content$value, _content$value2;
    if (!((_content$value = content.value) !== null && _content$value !== void 0 && _content$value.render) && !((_content$value2 = content.value) !== null && _content$value2 !== void 0 && _content$value2.template)) {
      return content.value;
    }
    return resolveComponent(content.value);
  });
  var slotContent = computed(() => {
    var _fieldSlots$value$def, _fieldSlots$value$def2;
    if (!((_fieldSlots$value$def = fieldSlots.value.default) !== null && _fieldSlots$value$def !== void 0 && _fieldSlots$value$def.render) && !((_fieldSlots$value$def2 = fieldSlots.value.default) !== null && _fieldSlots$value$def2 !== void 0 && _fieldSlots$value$def2.template)) {
      return fieldSlots.value.default;
    }
    return resolveComponent(fieldSlots.value.default);
  });
  var resolveComponent = (component) => {
    component = _objectSpread2$1({}, component);
    if (!component.props) {
      component.props = ["el$"];
    } else if (Array.isArray(component.props) && component.props.indexOf("el$") === -1) {
      component.props.push("el$");
    } else if (!Array.isArray(component.props) && !component.props.el$) {
      component.props["el$"] = {
        type: Object,
        required: false,
        default: () => ({})
      };
    }
    return component;
  };
  return {
    isHtml,
    componentContent,
    slotContent,
    resolvedContent
  };
};
var StaticElement = {
  name: "StaticElement",
  mixins: [BaseElement, HasView],
  emits: ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "static",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    content: {
      required: false,
      type: [String, Object, Function],
      default: ""
    },
    wrap: {
      required: false,
      type: [Boolean],
      default: true
    },
    tag: {
      required: false,
      type: [String],
      default: void 0
    },
    allowHtml: {
      required: false,
      type: [Boolean],
      default: true
    },
    href: {
      required: false,
      type: [String],
      default: void 0
    },
    target: {
      required: false,
      type: [String],
      default: void 0
    },
    src: {
      required: false,
      type: [String],
      default: void 0
    },
    alt: {
      required: false,
      type: [String],
      default: void 0
    },
    title: {
      required: false,
      type: [String],
      default: void 0
    },
    width: {
      required: false,
      type: [String],
      default: void 0
    },
    height: {
      required: false,
      type: [String],
      default: void 0
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    },
    top: {
      required: false,
      type: [String, Number],
      default: 0
    },
    bottom: {
      required: false,
      type: [String, Number],
      default: 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, static_$1, base$1e, static_$2, base$16, base$11, base$$, base$_, base$1c, base$10, base$Z, base$W, static_$3, base$V, base$6];
    context.slots = ["default", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, static_4(props, context));
  }
};
var base$5 = function base74(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$2 = dependencies2.el$;
  var handleTag = (searchQuery) => {
    fire("tag", searchQuery, el$2.value);
  };
  return {
    handleTag
  };
};
var TagsElement = {
  name: "TagsElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "tag", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "tags",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onTag: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label"
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value"
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: "label"
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true
    },
    breakTags: {
      type: [Boolean],
      required: false,
      default: false
    },
    create: {
      required: false,
      type: [Boolean],
      default: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"]
    },
    allowAbsent: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    object: {
      type: [Boolean],
      required: false,
      default: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1
    },
    max: {
      type: [Number],
      required: false,
      default: -1
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label"
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items"
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false
    },
    groupSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom"
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true
    },
    clearOnSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: false
    },
    delay: {
      type: [Number],
      required: false,
      default: -1
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false
    },
    hideSelected: {
      type: [Boolean],
      required: false,
      default: true
    },
    showOptions: {
      type: [Boolean],
      required: false,
      default: true
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true
    },
    autocomplete: {
      type: [String],
      required: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text"
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, tags$4, base$P, array$1, base$W, base$H, base$1e, tags$5, base$T, base$D, base$E, base$I, tags$1, base$M, tags$2, base$16, array2, tags$3, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$d, base$5, base$c, tags2, base$S, base$G, base$V, base$t];
    context.slots = ["tag", "option", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$4 = function base75(props, context, dependencies2) {
  var {
    autogrow
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var input = dependencies2.input;
  var value = dependencies2.value;
  var autosize = () => {
    if (!autogrow.value) {
      return;
    }
    form$.value.$vueform.services.autosize.update(input.value);
  };
  watch(autogrow, (newValue) => {
    if (newValue) {
      form$.value.$vueform.services.autosize(input.value);
    } else {
      form$.value.$vueform.services.autosize.destroy(input.value);
    }
  });
  watch(value, () => {
    autosize();
  });
  onMounted(() => {
    if (autogrow.value) {
      nextTick(() => {
        form$.value.$vueform.services.autosize(input.value);
      });
    }
  });
  return {
    autosize
  };
};
var multilingual9 = function multilingual10(props, context, dependencies2) {
  var {
    autosize
  } = base$4(props, context, dependencies2);
  var form$ = dependencies2.form$;
  onMounted(() => {
    form$.value.on("language", () => {
      autosize();
    });
  });
  return {
    autosize
  };
};
var TextareaElement = {
  name: "TextareaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "textarea",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autogrow: {
      required: false,
      type: [Boolean],
      default: true
    },
    rows: {
      required: false,
      type: [Number],
      default: 3
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$H, base$1e, base$Q, base$T, base$C, base$w, text$1, base$16, text$2, base$M, base$J, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$m, base$4, base$s, base$b, base$S, base$G, base$V, base$9, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var TextElement = {
  name: "TextElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "text",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    inputType: {
      required: false,
      type: [String],
      default: "text"
    },
    forceNumbers: {
      required: false,
      type: [Boolean],
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$1e, base$Q, base$T, base$C, base$w, text$1, base$16, text$2, base$I, base$M, base$J, text3, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$m, base$s, base$b, base$S, base$G, base$V, base$9, base$H, base$t];
    context.slots = ["label", "info", "required", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var ToggleElement = {
  name: "ToggleElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "toggle",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Boolean],
      default: void 0
      // falseValue
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    labels: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    trueValue: {
      required: false,
      type: [Boolean, String, Number],
      default: true
    },
    falseValue: {
      required: false,
      type: [Boolean, String, Number],
      default: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, boolean, base$W, base$1e, base$Q, base$T, toggle, base$D, base$16, base$E, base$M, base$B, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$u, base$z, toggle$1, base$G, base$V, base$A];
    context.slots = ["default", "label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$3 = function base76(props, context, dependencies2) {
  var {
    endpoint,
    method
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var input = dependencies2.input;
  var focused = ref(false);
  var editorEndpoint = computed(() => {
    return endpoint.value || form$.value.$vueform.config.endpoints.attachment.url;
  });
  var editorMethod = computed(() => {
    return method.value || form$.value.$vueform.config.endpoints.attachment.method;
  });
  onMounted(() => {
    input.value.editor$.addEventListener("focus", () => {
      focused.value = true;
    });
    input.value.editor$.addEventListener("blur", () => {
      focused.value = false;
    });
  });
  return {
    editorEndpoint,
    editorMethod,
    focused
  };
};
var base$2 = function base77(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var listeners = dependencies2.listeners;
  var handleAlert = (message) => {
    fire("alert", message);
    if (!listeners.value.alert) {
      alert(message);
    }
  };
  return {
    handleAlert
  };
};
var EditorElement = {
  name: "EditorElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "editor",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onAlert: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    accept: {
      required: false,
      type: [Array],
      default: () => []
    },
    acceptMimes: {
      required: false,
      type: [Array],
      default: () => []
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null,
      "@default": "config.endpoints.attachment.url"
    },
    method: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.endpoints.attachment.method"
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$L, base$W, base$1e, base$Q, base$T, text$1, base$16, text$2, base$M, base$J, editor2, base$11, base$K, base$$, base$_, base$3, base$1c, base$10, base$Z, base$m, base$2, base$n, base$b, base$S, base$G, editor$1, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$O(props, context));
  }
};
var base$1 = function base78(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var language = computed(() => {
    return form$.value.selectedLanguage;
  });
  var languages = computed(() => {
    return keys_1(form$.value.options.languages);
  });
  return {
    language,
    languages
  };
};
var TTextareaElement = {
  name: "TTextareaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-textarea",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autogrow: {
      required: false,
      type: [Boolean],
      default: true
    },
    rows: {
      required: false,
      type: [Number],
      default: 3
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$W, base$H, base$1e, base$Q, base$T, base$C, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$16, multilingual$3, multilingual$5, multilingual$1, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$m, multilingual9, base$s, base$b, base$S, multilingual$4, base$V, base$9, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var TTextElement = {
  name: "TTextElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "focus", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-text",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: void 0
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    inputType: {
      required: false,
      type: [String],
      default: "text"
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$W, base$H, base$1e, base$Q, base$T, base$C, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$16, multilingual$3, base$I, multilingual$5, multilingual$1, base$11, base$K, base$$, base$_, base$1c, base$10, base$Z, base$m, base$s, base$b, base$S, multilingual$4, base$V, base$9, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var TEditorElement = {
  name: "TEditorElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-editor",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean, Function, Array, Object],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onAlert: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    accept: {
      required: false,
      type: [Array],
      default: null
    },
    acceptMimes: {
      required: false,
      type: [Array],
      default: null
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null,
      "@default": "config.endpoints.attachment.url"
    },
    method: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.endpoints.attachment.method"
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, ctx) {
    var context = _objectSpread2$1({}, ctx);
    context.features = [base$U, base$1b, base$1a, base$X, base$N, base$P, base$W, base$1e, base$Q, base$T, base$1, multilingual$6, multilingual$2, multilingual$7, base$16, multilingual$3, multilingual$5, teditor, base$11, base$K, base$$, base$_, base$3, base$1c, base$10, base$Z, base$m, base$2, base$n, base$b, base$S, multilingual$4, base$V, base$t];
    context.slots = ["label", "info", "required", "description", "before", "between", "after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var CheckboxgroupCheckbox = {
  name: "CheckboxgroupCheckbox",
  props: {
    item: {
      type: [Object, String, Number],
      required: true
    },
    value: {
      type: [String, Number, Boolean],
      required: true
    },
    items: {
      type: [Object, Array],
      required: true
    },
    index: {
      type: [Number],
      required: true
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      item
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var isDisabled = computed(() => {
      var _item$value;
      return el$2.value.disabledItems.map((i) => String(i)).indexOf(String(value.value)) !== -1 || el$2.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
    });
    var checked = computed(() => {
      return el$2.value.value.indexOf(String(value.value)) !== -1 || el$2.value.value.indexOf(Number(value.value)) !== -1;
    });
    var id = computed(() => {
      return "".concat(el$2.value.fieldId, "-").concat(value.value);
    });
    var name2 = computed(() => {
      return "".concat(el$2.value.path, "-").concat(value.value);
    });
    var handleKeydown = (e2) => {
      if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var next = e2.target.nextElementSibling;
        if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "checkbox") {
          next.focus();
        }
      } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var previous = e2.target.previousElementSibling;
        if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "checkbox") {
          previous.focus();
        }
      }
    };
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      isDisabled,
      id,
      name: name2,
      checked,
      handleKeydown
    };
  }
};
var base79 = function base80(props, context, dependencies2) {
  var el$2 = dependencies2.el$;
  var form$ = dependencies2.form$;
  var visible = computed(() => {
    return el$2.value.stage > 0;
  });
  var hasLink = computed(() => {
    return el$2.value.link && el$2.value.clickable;
  });
  var hasError = computed(() => {
    return el$2.value.hasUploadError;
  });
  var link = computed(() => {
    return el$2.value.link;
  });
  var filename = computed(() => {
    var filename2 = el$2.value.filename && typeof el$2.value.filename === "string" ? el$2.value.filename.split("\\").pop().split("/").pop() : el$2.value.filename;
    if (filename2) {
      filename2 = filename2.split("?")[0];
    }
    return filename2;
  });
  var clickable = computed(() => {
    return el$2.value.clickable;
  });
  var uploaded = computed(() => {
    return el$2.value.stage > 1;
  });
  var uploading = computed(() => {
    return el$2.value.uploading;
  });
  var progress = computed(() => {
    return el$2.value.progress;
  });
  var canRemove = computed(() => {
    return (el$2.value.canRemove || el$2.value.uploading) && !el$2.value.isDisabled;
  });
  var canUploadTemp = computed(() => {
    return el$2.value.canUploadTemp;
  });
  var uploadText = computed(() => {
    return form$.value.translations.vueform.elements.file.upload;
  });
  var ariaLabelledby = computed(() => {
    return el$2.value.embed ? void 0 : el$2.value.labelId;
  });
  var upload = () => {
    el$2.value.uploadTemp();
  };
  var remove = () => {
    if (uploading.value) {
      el$2.value.handleAbort();
    } else {
      el$2.value.handleRemove();
    }
  };
  var handleKeyup = function() {
    var _ref = _asyncToGenerator(function* (e2) {
      switch (e2.key) {
        case "Backspace":
        case "Delete":
          remove();
          if (!el$2.value.canSelect) {
            return;
          }
          yield nextTick();
          document.querySelector("#".concat(el$2.value.fieldId)).focus();
          break;
        case "Enter":
          if (el$2.value.auto) {
            return;
          }
          upload();
          break;
      }
    });
    return function handleKeyup2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    visible,
    hasLink,
    hasError,
    link,
    filename,
    clickable,
    uploaded,
    uploading,
    progress,
    canRemove,
    canUploadTemp,
    uploadText,
    ariaLabelledby,
    upload,
    remove,
    handleKeyup
  };
};
var FilePreview = {
  name: "FilePreview",
  props: {
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var {
      visible,
      hasLink,
      hasError,
      link,
      filename,
      clickable,
      uploaded,
      uploading,
      progress,
      canRemove,
      canUploadTemp,
      uploadText,
      ariaLabelledby,
      upload,
      remove,
      handleKeyup
    } = base79(props, context, {
      el$: el$2,
      form$
    });
    var preview = computed(() => {
      return el$2.value.preview;
    });
    var ariaPlaceholder = computed(() => {
      var text5 = el$2.value.embed && el$2.value.View !== "gallery" ? void 0 : filename.value;
      if (hasError.value) {
        if (text5) {
          text5 += ", error";
        } else {
          text5 = "error";
        }
      }
      return text5;
    });
    var ariaRoledescription = computed(() => {
      return el$2.value.embed && el$2.value.View !== "gallery" || uploaded.value || el$2.value.auto ? void 0 : uploadText.value;
    });
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      visible,
      hasLink,
      hasError,
      link,
      filename,
      clickable,
      uploaded,
      uploading,
      progress,
      canRemove,
      canUploadTemp,
      uploadText,
      preview,
      ariaLabelledby,
      ariaPlaceholder,
      ariaRoledescription,
      upload,
      remove,
      handleKeyup
    };
  }
};
var RadiogroupRadio = {
  name: "RadiogroupRadio",
  props: {
    item: {
      type: [Object, String, Number],
      required: true
    },
    value: {
      type: [String, Number, Boolean],
      required: true
    },
    items: {
      type: [Object, Array],
      required: true
    },
    index: {
      type: [Number],
      required: true
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      item
    } = toRefs(props);
    var {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$12(props, context);
    var isDisabled = computed(() => {
      var _item$value;
      return el$2.value.disabledItems.map((i) => String(i)).indexOf(String(value.value)) !== -1 || el$2.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
    });
    var checked = computed(() => {
      return el$2.value.value === String(value.value) || el$2.value.value === Number(value.value);
    });
    var id = computed(() => {
      return "".concat(el$2.value.fieldId, "-").concat(value.value);
    });
    var name2 = computed(() => {
      return el$2.value.path;
    });
    var handleKeydown = (e2) => {
      if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var next = e2.target.nextElementSibling;
        if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "radio") {
          next.focus();
        }
      } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var previous = e2.target.previousElementSibling;
        if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "radio") {
          previous.focus();
        }
      }
    };
    return {
      el$: el$2,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      isDisabled,
      id,
      name: name2,
      checked,
      handleKeydown
    };
  }
};
var index = {
  Vueform: VueformComponent,
  FormErrors,
  FormMessages,
  FormLanguages,
  FormLanguage,
  FormTabs,
  FormTab,
  FormSteps,
  FormStepsControls,
  FormStepsControl,
  FormStep,
  FormElements,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementLabelFloating,
  ElementLabel,
  ElementInfo,
  ElementDescription,
  ElementError,
  ElementMessage,
  ElementRequired,
  ElementText,
  DragAndDrop,
  ElementAddon,
  ElementAddonOptions,
  DatepickerWrapper,
  EditorWrapper,
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupElement,
  DateElement,
  DatesElement,
  FileElement,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  SelectElement,
  SignatureElement,
  SliderElement,
  StaticElement,
  TagsElement,
  TextareaElement,
  TextElement,
  ToggleElement,
  EditorElement,
  TTextareaElement,
  TTextElement,
  TEditorElement,
  CheckboxgroupCheckbox,
  FilePreview,
  RadiogroupRadio
};
var components = Object.freeze({
  __proto__: null,
  "default": index,
  Vueform: VueformComponent,
  FormErrors,
  FormMessages,
  FormLanguages,
  FormLanguage,
  FormTabs,
  FormTab,
  FormSteps,
  FormStepsControls,
  FormStepsControl,
  FormStep,
  FormElements,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementLabelFloating,
  ElementLabel,
  ElementInfo,
  ElementDescription,
  ElementError,
  ElementMessage,
  ElementRequired,
  ElementText,
  DragAndDrop,
  ElementAddon,
  ElementAddonOptions,
  DatepickerWrapper,
  EditorWrapper,
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupElement,
  DateElement,
  DatesElement,
  FileElement,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  SelectElement,
  SignatureElement,
  SliderElement,
  StaticElement,
  TagsElement,
  TextareaElement,
  TextElement,
  ToggleElement,
  EditorElement,
  TTextareaElement,
  TTextElement,
  TEditorElement,
  CheckboxgroupCheckbox,
  FilePreview,
  RadiogroupRadio
});
function element(options) {
  var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!options.name) {
    throw Error("The `name` attribute must be defined to create a new element");
  }
  options = _objectSpread2$1(_objectSpread2$1({}, options), component);
  var name2 = options.name;
  var ComponentName = "".concat(upperFirst_1(camelCase_1(name2)));
  var emits = [].concat(GenericElement.emits).concat(options.emits || []);
  return _objectSpread2$1({
    name: ComponentName,
    components: options.components || {},
    mixins: [].concat(GenericElement.mixins).concat(options.mixins || []),
    emits,
    props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, GenericElement.props), options.props || {}), {}, {
      type: {
        required: false,
        type: [String],
        default: name2,
        private: true
      }
    }),
    setup(props, ctx) {
      var context = _objectSpread2$1(_objectSpread2$1({}, ctx), {}, {
        emits,
        name: ref(ComponentName),
        nullValue: options.nullValue !== void 0 ? options.nullValue : null
      });
      var element2 = GenericElement.setup(props, context);
      context.element = element2;
      var setup = options.setup ? options.setup(props, context) : {};
      return _objectSpread2$1(_objectSpread2$1({}, element2), setup);
    }
  }, omit_1(options, ["setup", "mixins", "emits", "props"]));
}
function defineConfig(config2) {
  return config2;
}
var VueformElement = element;
var defineElement = element;
installer(void 0, {
  Vueform: VueformComponent,
  FormElements
}, {}, {
  moment: moment_default
});
var vueform = installer(void 0, _objectSpread2$1({}, components), _objectSpread2$1({}, rules), {
  moment: moment_default
});
export {
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupCheckbox,
  CheckboxgroupElement,
  DateElement,
  DatepickerWrapper,
  DatesElement,
  DragAndDrop,
  EditorElement,
  EditorWrapper,
  ElementAddon,
  ElementAddonOptions,
  ElementDescription,
  ElementError,
  ElementInfo,
  ElementLabel,
  ElementLabelFloating,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementMessage,
  ElementRequired,
  ElementText,
  FileElement,
  FilePreview,
  FormElements,
  FormErrors,
  FormLanguage,
  FormLanguages,
  FormMessages,
  FormStep,
  FormSteps,
  FormStepsControl,
  FormStepsControls,
  FormTab,
  FormTabs,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  RadiogroupRadio,
  SelectElement,
  SignatureElement,
  SliderElement,
  StaticElement,
  TEditorElement,
  TTextElement,
  TTextareaElement,
  TagsElement,
  TextElement,
  TextareaElement,
  ToggleElement,
  Validator,
  VueformComponent as Vueform,
  VueformElement,
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array$2 as array,
  before,
  before_or_equal,
  between,
  boolean$1 as boolean,
  captcha$2 as captcha,
  completed,
  confirmed,
  date$4 as date,
  date_equals,
  date_format,
  vueform as default,
  defineConfig,
  defineElement,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  element,
  email,
  exists,
  file$5 as file,
  filled,
  gt,
  gte,
  image,
  in_,
  in_array,
  installer,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max,
  mimes,
  mimetypes,
  min$1 as min,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  base$1c as useClasses,
  base$1d as useVueform,
  uuid,
  vueform
};
/*! Bundled license information:

@vueform/vueform/dist/index.mjs:
  (*!
   * Vueform v1.10.10 (https://github.com/vueform/vueform)
   * Copyright (c) 2024 Adam Berecz <adam@vueform.com>
   * Licensed under the MIT License
   *)
  (**!
   * Sortable 1.15.3
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
  (*!
   * Signature Pad v5.0.3 | https://github.com/szimek/signature_pad
   * (c) 2024 Szymon Nowak | Released under the MIT license
   *)
*/
//# sourceMappingURL=@vueform_vueform.js.map
