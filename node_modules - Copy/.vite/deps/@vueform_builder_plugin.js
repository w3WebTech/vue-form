import {
  require_lodash
} from "./chunk-T55TXYO6.js";
import {
  computed,
  inject,
  markRaw,
  nextTick,
  onMounted,
  ref,
  resolveComponent,
  toRefs,
  watch
} from "./chunk-YXU3ALOZ.js";
import {
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@vueform/builder/plugins/elementSelector/index.mjs
var import_lodash = __toESM(require_lodash(), 1);
import TextElement from "C:/Users/HASEE/Desktop/testingforfv/vue-form/vueform-project/node_modules/@vueform/builder/plugins/elementSelector/TextElement.vue";
import TextareaElement from "C:/Users/HASEE/Desktop/testingforfv/vue-form/vueform-project/node_modules/@vueform/builder/plugins/elementSelector/TextareaElement.vue";
import ElementSelectOption from "C:/Users/HASEE/Desktop/testingforfv/vue-form/vueform-project/node_modules/@vueform/builder/plugins/elementSelector/ElementSelectOption.vue";
function elementSelector_default() {
  return [
    () => ({
      config(config) {
        config.theme.templates.TextElement_elementSelector = markRaw(TextElement);
        config.theme.templates.TextareaElement_elementSelector = markRaw(TextareaElement);
        config.theme.classes.TextElement.inputContainer_elementSelector = "relative";
        config.theme.classes.TextareaElement.inputContainer_elementSelector = "relative";
        let TextElement_$inputContainer = config.theme.classes.TextElement.$inputContainer;
        let TextareaElement_$inputContainer = config.theme.classes.TextareaElement.$inputContainer;
        config.theme.classes.TextElement.$inputContainer = (classes, el$) => {
          return TextElement_$inputContainer(classes, el$).concat(
            el$.elementSelector ? classes.inputContainer_elementSelector : null
          );
        };
        config.theme.classes.TextareaElement.$inputContainer = (classes, el$) => {
          return TextareaElement_$inputContainer(classes, el$).concat(
            el$.elementSelector ? classes.inputContainer_elementSelector : null
          );
        };
        return config;
      }
    }),
    () => ({
      apply: ["TextElement", "TextareaElement"],
      props: {
        elementSelector: {
          type: Boolean,
          required: false,
          default: false
        },
        elementSelectorOptions: {
          type: Object,
          required: false,
          default: () => ({})
        }
      },
      setup(props, context, component) {
        const { elementSelector, elementSelectorOptions, builder } = toRefs(props);
        if (!(elementSelector == null ? void 0 : elementSelector.value)) {
          return component;
        }
        const tags = inject("tags");
        const selectingElement = ref(false);
        const elementSelector$ = ref(null);
        const cursorPosition = ref(-1);
        const fields = computed(() => {
          return flattenTree(component.form$.value.builderPagedTree || []);
        });
        const excludeSelf = computed(() => {
          return elementSelectorOptions.value.excludeSelf || false;
        });
        const selectedElement = computed(() => {
          return component.form$.value.selectedElement;
        });
        const elementSelectorForm = computed(() => {
          return {
            schema: {
              field: {
                type: "select",
                inputType: "search",
                canClear: false,
                canDeselect: false,
                search: true,
                items: fields.value,
                autocomplete: "off",
                placeholder: tags.element_selector_placeholder,
                trackBy: "searchLabel",
                caret: false,
                object: true,
                noResultsText: tags.element_selector_no_results,
                addClass: {
                  select: {
                    search: "vfb-field-input",
                    dropdown: "vfb-fields-container vfb-fields-dropdown",
                    option: fields.value.some((f) => f.container && (f == null ? void 0 : f.children.length)) ? "" : "vfb-field-container-no-nesting",
                    optionPointed: "vfb-field-pointed",
                    optionSelected: "vfb-field-selected",
                    optionSelectedPointed: "vfb-field-pointed vfb-field-selected",
                    groupLabel: "vfb-field-group-label-container"
                  }
                },
                slots: {
                  "option": markRaw(ElementSelectOption)
                },
                onChange(n) {
                  selectingElement.value = false;
                  let position = cursorPosition.value + n.path.length;
                  let input = component.input.value;
                  let start = input.value.slice(0, cursorPosition.value);
                  let end = input.value.slice(cursorPosition.value);
                  let value = start;
                  value += n.path;
                  if (["}", "|"].indexOf(end.charAt(0)) === -1) {
                    value += "}";
                  }
                  let scrollToText = value;
                  value += end;
                  component.update(value);
                  component.input.value.focus();
                  nextTick(() => {
                    setCaretPosition(component.input.value, position + 1);
                    if (["text", "search"].indexOf(component.input.value.type) !== -1) {
                      const measureSpan = document.createElement("span");
                      measureSpan.style.visibility = "hidden";
                      measureSpan.style.position = "absolute";
                      measureSpan.style.whiteSpace = "nowrap";
                      measureSpan.style.font = component.input.value.font;
                      document.body.appendChild(measureSpan);
                      measureSpan.textContent = scrollToText;
                      component.input.value.scrollLeft = measureSpan.offsetWidth - component.input.value.clientWidth;
                      document.body.removeChild(measureSpan);
                    } else if (component.autosize) {
                      component.autosize();
                    }
                  });
                },
                onClose(a, b) {
                  selectingElement.value = false;
                  nextTick(() => {
                    setCaretPosition(component.input.value, cursorPosition.value);
                  });
                }
              }
            }
          };
        });
        const setCaretPosition = (el, pos) => {
          if (el) {
            if (el.createTextRange) {
              let range = el.createTextRange();
              range.move("character", pos);
              range.select();
            } else {
              if (el.selectionStart) {
                el.focus();
                el.setSelectionRange(pos, pos);
              } else {
                el.focus();
              }
            }
          }
        };
        const flattenTree = (elements = pagedTree.value, level = 0) => {
          let paths = [];
          import_lodash.default.forEach(elements, (el) => {
            let path = el.root ? "__VUEFORM_ROOT__" : el.path.replace(/\.0\b/g, () => ".*");
            if (excludeSelf.value && path === selectedElement.value.replace(/\.0\b/g, () => ".*")) {
              return;
            }
            let field = {
              ...el,
              path,
              level,
              value: path,
              searchLabel: `${el.primaryLabel || ""} ${el.secondaryLabel || ""}`
            };
            paths.push(field);
            if (["group", "object", "tabs", "steps", "root"].indexOf(el.type) !== -1) {
              paths = paths.concat(flattenTree(el.children || [], level + 1) || []);
            }
            if (el.type === "list" && el.children[0].type === "object") {
              if (selectedElement.value.match(new RegExp(`^${el.path.replace(".", "\\.")}\\.`))) {
                paths = paths.concat(flattenTree(el.children[0].children || [], level + 1) || []);
              }
            }
          });
          return paths;
        };
        const closeOnBackspace = (e) => {
          if (e.key === "Backspace" && e.target.value == "") {
            e.preventDefault();
            selectingElement.value = false;
            nextTick(() => {
              setCaretPosition(component.input.value, cursorPosition.value);
            });
          }
        };
        const handleKeydown = (e) => {
          if (e.key === "{") {
            selectingElement.value = true;
            cursorPosition.value = e.target.selectionStart + 1;
            setTimeout(() => {
              let field$ = elementSelector$.value.el$("field");
              field$.input.focus();
              field$.input.open();
              field$.input.input.addEventListener("keydown", closeOnBackspace);
            }, 0);
          } else {
            context.emit("keydown", e, component.el$);
          }
        };
        return {
          ...component,
          handleKeydown,
          elementSelector$,
          selectingElement,
          elementSelectorForm
        };
      }
    })
  ];
}

// node_modules/@vueform/builder/plugin.mjs
var import_lodash2 = __toESM(require_lodash(), 1);
var asyncForEach = async (array, callback) => {
  for (let index = 0; index < (import_lodash2.default.isPlainObject(array) ? import_lodash2.default.values(array) : array).length; index++) {
    let key = import_lodash2.default.isPlainObject(array) ? import_lodash2.default.keys(array)[index] : index;
    await callback(array[key], key, array);
  }
};
var getElementSchemaByPath = (schema, path) => {
  if (!path) {
    return;
  }
  const pathParts = path.split(".");
  const pathLength = pathParts.length;
  const returnSchema = (schema2, level = 1) => {
    const currentPath = pathParts[level - 1];
    if (pathLength === level) {
      return schema2[currentPath];
    } else if (pathLength > level) {
      let base = schema2[pathParts[level - 1]];
      let childSchema = base.type === "list" ? { 0: base.element } : base.schema;
      return returnSchema(childSchema, level + 1);
    }
  };
  return returnSchema(schema);
};
function plugin_default() {
  return [
    ...elementSelector_default(),
    () => ({
      config(config) {
        config.presets = {
          ...config.presets,
          "preview-form": {},
          "props-form": {
            removeClasses: {
              FormElements: {
                container_sm: ["form-gap-y-gutter-sm"]
              }
            },
            replaceClasses: {
              ToggleElement: {
                wrapper: {
                  "items-start": "vfb-util-props-toggle-wrapper"
                }
              },
              TagsElement: {
                select: {
                  tag: {
                    "whitespace-nowrap": "vfb-util-props-tags"
                  }
                }
              }
            },
            addClasses: {
              ElementLabel: {
                wrapper: "leading-snug"
              },
              SliderElement: {
                container: "vfb-config-slider"
              },
              ToggleElement: {
                container: "vfb-config-toggle"
              },
              ListElement: {
                remove: "vfb-config-list-remove"
              }
            }
          },
          "separator": {
            addClasses: {
              ElementLayout: {
                container: "vfb-util-props-separator"
              }
            }
          },
          "separator-top": {
            addClasses: {
              ElementLayout: {
                container: "vfb-util-props-separator-top"
              }
            }
          },
          "prop-multiline": {
            addClasses: {
              ElementAddon: {
                container: "pt-2 mt-px"
              },
              ElementLabel: {
                container: "vfb-prop-multiline"
              },
              ElementLabel: {
                container: "vfb-prop-multiline"
              }
            },
            replaceClasses: {
              ElementAddon: {
                container: {
                  "items-center": "items-start"
                }
              }
            }
          },
          "prop-toggle": {
            addClasses: {
              ElementLabel: {
                container: "flex items-center"
              }
            }
          },
          "prop-subtitle": {
            addClasses: {
              StaticElement: {
                container: "vfb-util-props-subtitle"
              }
            }
          },
          "prop-subtitle-no-m": {
            addClasses: {
              StaticElement: {
                container: "vfb-util-props-subtitle-no-m"
              }
            }
          },
          "prop-list-subtitle": {
            addClasses: {
              ElementLabel: {
                container: "vfb-util-props-list-subtitle"
              }
            }
          },
          "prop-list": {
            addClasses: {
              ElementLabel: {
                container: "vfb-util-props-list-label"
              },
              ListElement: {
                add: "vfb-util-props-list-add"
              },
              ElementLayout: {
                container: "vfb-util-props-list-layout"
              }
            },
            removeClasses: {
              ListElement: {
                listItem_sm: ["form-gap-gutter-sm"]
              }
            }
          },
          "prop-list-object": {
            removeClasses: {
              ObjectElement: {
                wrapper_sm: ["form-gap-gutter-sm"]
              }
            }
          },
          "prop-list-el": {
            removeClasses: {
              TextElement: {
                inputContainer: ["form-border-width-input"],
                inputContainer_sm: ["form-radius-input-sm"],
                inputContainer_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                inputContainer_success: ["form-bg-input-success", "focused:form-ring"]
              },
              TTextElement: {
                inputContainer: ["form-border-width-input"],
                inputContainer_sm: ["form-radius-input-sm"],
                inputContainer_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                inputContainer_success: ["form-bg-input-success", "focused:form-ring"]
              },
              TextareaElement: {
                inputContainer: ["form-border-width-input"],
                inputContainer_sm: ["form-radius-large-sm"],
                inputContainer_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                inputContainer_success: ["form-bg-input-success", "focused:form-ring"]
              },
              TTextareaElement: {
                inputContainer: ["form-border-width-input"],
                inputContainer_sm: ["form-radius-large-sm"],
                inputContainer_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                inputContainer_success: ["form-bg-input-success", "focused:form-ring"]
              },
              DateElement: {
                inputContainer: ["form-border-width-input"],
                inputContainer_sm: ["form-radius-input-sm"],
                inputContainer_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                inputContainer_success: ["form-bg-input-success", "focused:form-ring"]
              },
              SelectElement: {
                input: ["form-border-width-input"],
                input_sm: ["form-radius-input-sm"],
                input_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                input_success: ["form-bg-input-success", "focused:form-ring"],
                select: {
                  container: ["form-border-width-input"],
                  container_sm: ["form-radius-input-sm"],
                  container_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                  container_success: ["form-bg-input-success", "focused:form-ring"]
                }
              },
              TagsElement: {
                select: {
                  container: ["form-border-width-input"],
                  container_sm: ["form-radius-input-sm"],
                  container_default: ["form-bg-input", "hover:form-bg-input-hover", "focused:form-bg-input-focus", "focused:form-ring"],
                  container_success: ["form-bg-input-success", "focused:form-ring"]
                }
              }
            },
            addClasses: {
              TextElement: {
                inputContainer: "vfb-util-props-list-el-input",
                inputContainer_default: "vfb-util-props-list-el-input-default",
                inputContainer_success: "vfb-util-props-list-el-input-success"
              },
              TTextElement: {
                inputContainer: "vfb-util-props-list-el-input",
                inputContainer_default: "vfb-util-props-list-el-input-default",
                inputContainer_success: "vfb-util-props-list-el-input-success"
              },
              TextareaElement: {
                inputContainer: "vfb-util-props-list-el-input",
                inputContainer_default: "vfb-util-props-list-el-input-default",
                inputContainer_success: "vfb-util-props-list-el-input-success"
              },
              TTextareaElement: {
                inputContainer: "vfb-util-props-list-el-input",
                inputContainer_default: "vfb-util-props-list-el-input-default",
                inputContainer_success: "vfb-util-props-list-el-input-success"
              },
              DateElement: {
                inputContainer: "vfb-util-props-list-el-input",
                inputContainer_default: "vfb-util-props-list-el-input-default",
                inputContainer_success: "vfb-util-props-list-el-input-success"
              },
              SelectElement: {
                input: "vfb-util-props-list-el-select",
                input_default: "vfb-util-props-list-el-select-default",
                input_success: "vfb-util-props-list-el-select-success",
                select: {
                  container: "vfb-util-props-list-el-select-container",
                  container_default: "vfb-util-props-list-el-select-container-default",
                  container_success: "vfb-util-props-list-el-select-container-success"
                }
              },
              TagsElement: {
                select: {
                  container: "vfb-util-props-list-el-select-container",
                  container_default: "vfb-util-props-list-el-select-container-default",
                  container_success: "vfb-util-props-list-el-select-container-success"
                }
              }
            }
          },
          "prop-group": {
            addClasses: {
              GroupElement: {
                container: "vfb-util-props-group"
              }
            }
          },
          "colorpicker": {
            addClasses: {
              TextElement: {
                inputContainer: "vfb-util-colorpicker-input"
              },
              ElementAddon: {
                container: "vfb-util-colorpicker-addon"
              }
            }
          },
          "number": {
            replaceClasses: {
              TextElement: {
                input_sm: {
                  "form-p-input-sm": "vfb-util-number-input"
                }
              },
              ElementAddon: {
                container: {
                  "form-color-addon": "vfb-util-number-addon"
                }
              }
            }
          },
          "tabs-outline": {
            overrideClasses: {
              RadiogroupRadio: {
                wrapper_selected: "vfb-util-tabs-outline-selected",
                wrapper_unselected: "vfb-util-tabs-outline-unselected"
              }
            }
          },
          "tabs-outline-gray": {
            overrideClasses: {
              RadiogroupRadio: {
                wrapper_selected: "vfb-util-tabs-outline-gray-selected",
                wrapper_unselected: "vfb-util-tabs-outline-gray-unselected"
              }
            }
          },
          "tabs-2": {
            addClasses: {
              RadiogroupElement: {
                wrapper: "vfb-util-grid-cols-12"
              },
              RadiogroupRadio: {
                container: "vfb-util-col-span-6"
              }
            }
          },
          "tabs-3": {
            addClasses: {
              RadiogroupElement: {
                wrapper: "vfb-util-grid-cols-12"
              },
              RadiogroupRadio: {
                container: "vfb-util-col-span-4"
              }
            }
          },
          "tabs-4": {
            addClasses: {
              RadiogroupElement: {
                wrapper: "vfb-util-grid-cols-12"
              },
              RadiogroupRadio: {
                container: "vfb-util-col-span-3"
              }
            }
          },
          "tabs-6": {
            addClasses: {
              RadiogroupElement: {
                wrapper: "vfb-util-grid-cols-12"
              },
              RadiogroupRadio: {
                container: "vfb-util-col-span-2"
              }
            }
          },
          "tabs-12": {
            addClasses: {
              RadiogroupElement: {
                wrapper: "vfb-util-grid-cols-12"
              },
              RadiogroupRadio: {
                container: "vfb-util-col-span-1"
              }
            }
          },
          "tabs-tiny": {
            addClasses: {
              RadiogroupRadio: {
                text: "vfb-util-tabs-tiny-text"
              },
              CheckboxgroupCheckbox: {
                text: "vfb-util-tabs-tiny-text"
              }
            },
            replaceClasses: {
              RadiogroupRadio: {
                wrapper_sm: {
                  "form-text-sm": "vfb-util-tabs-tiny"
                }
              },
              CheckboxgroupCheckbox: {
                wrapper_sm: {
                  "form-text-sm": "vfb-util-tabs-tiny"
                }
              },
              ElementLabel: {
                wrapper: {
                  "leading-snug": "leading-none"
                }
              }
            }
          },
          "tabs-small": {
            replaceClasses: {
              RadiogroupRadio: {
                wrapper_sm: {
                  "form-text-sm": "vfb-util-tabs-small"
                }
              }
            }
          }
        };
        return config;
      }
    }),
    () => ({
      apply: ["Vueform"],
      emits: [
        "rename-page",
        "add-page",
        "remove-page",
        "move-page",
        "move-to-page",
        "move-element",
        "add-element",
        "remove-pages",
        "select-page",
        "event"
      ],
      props: {
        selectedElement: {
          required: false,
          type: String
        },
        selectedPage: {
          type: String,
          required: false
        },
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        builder: {
          required: false,
          type: Boolean,
          default: false
        },
        nesting: {
          required: false,
          type: Boolean,
          default: false
        },
        draggedSchema: {
          required: false,
          type: Object
        },
        elementTypes: {
          required: false,
          type: Object,
          default: () => ({})
        },
        builderTree: {
          required: false,
          type: Array,
          default: () => []
        },
        builderFlatTree: {
          required: false,
          type: Array,
          default: () => []
        },
        builderPagedTree: {
          required: false,
          type: Array,
          default: () => []
        },
        device: {
          required: false,
          type: String
        },
        modelDuplicates: {
          required: false,
          type: Array
        }
      },
      setup(props, context, component) {
        const { builder, schema, draggedSchema, tabs, steps } = toRefs(props);
        if (!builder.value) {
          return component;
        }
        const subscribeOnce = inject("subscribeOnce");
        const tags = inject("tags");
        const droppingFirst = ref(false);
        const hasTabs = computed(() => {
          return tabs.value && Object.keys(tabs.value).length;
        });
        const hasSteps = computed(() => {
          return steps.value && Object.keys(steps.value).length;
        });
        const isEmpty = computed(() => {
          var _a, _b, _c, _d, _e, _f;
          if (hasTabs.value) {
            return !((_c = (_b = (_a = component.tabs$.value) == null ? void 0 : _a.current$) == null ? void 0 : _b.elements) == null ? void 0 : _c.length);
          }
          if (hasSteps.value) {
            return !((_f = (_e = (_d = component.steps$.value) == null ? void 0 : _d.current$) == null ? void 0 : _e.elements) == null ? void 0 : _f.length);
          }
          return !Object.keys(schema.value).length;
        });
        const currentPage$ = computed(() => {
          return hasTabs.value ? component.tabs$.value.current$ : hasSteps.value ? component.steps$.value.current$ : void 0;
        });
        const hasPages = computed(() => {
          return hasTabs.value || hasSteps.value;
        });
        const pageType = computed(() => {
          return hasTabs.value ? "tab" : hasSteps.value ? "step" : void 0;
        });
        const reset = (setDefault = true) => {
          import_lodash2.default.each(component.elements$.value, (e$) => {
            if (e$.isStatic) {
              return;
            }
            e$.reset(setDefault);
          });
          if (component.steps$.value !== null) {
            component.steps$.value.reset();
          }
          if (component.tabs$.value !== null) {
            component.tabs$.value.reset();
          }
          component.fire("reset");
        };
        const submit = async () => {
          if (component.isDisabled.value) {
            return;
          }
          await component.validate();
          if (component.invalid.value) {
            component.scrollToFirstInvalid();
            return;
          }
          component.preparing.value = true;
          try {
            await component.prepareElements();
            if (typeof component.options.value.prepare === "function") {
              await component.options.value.prepare(component.form$.value);
            }
          } catch (error) {
            component.fire("error", error, { type: "prepare" }, component.form$.value);
            console.error(error);
            return;
          } finally {
            component.preparing.value = false;
          }
          component.fire("submit", component.form$.value);
        };
        const handleSelectPage = (name) => {
          context.emit("select-page", name);
        };
        const handleRenamePage = (page, value) => {
          context.emit("rename-page", page, value);
        };
        const handleRemovePage = (value) => {
          context.emit("remove-page", value);
        };
        const handleAddPage = () => {
          context.emit("add-page");
        };
        const handleRemovePages = () => {
          context.emit("remove-pages");
        };
        const handleMovePage = (page, position, target) => {
          context.emit("move-page", page, position, target);
        };
        const handleMoveToPage = (page, schema2, parentPath) => {
          context.emit("move-to-page", page, schema2, parentPath);
        };
        const handleDragOver = (e) => {
          e.preventDefault();
          if (draggedSchema.value && ["tabs", "steps"].indexOf(draggedSchema.value.type) === -1) {
            droppingFirst.value = true;
          }
        };
        const handleDragLeave = () => {
          droppingFirst.value = false;
        };
        const handleDrop = (e) => {
          var _a;
          let schema2 = e.dataTransfer.getData("schema");
          let path = e.dataTransfer.getData("path");
          if (path && currentPage$.value) {
            let currentPage = currentPage$.value.name;
            if (path && path.match(/\./)) {
              subscribeOnce("moved-element", (newPath) => {
                nextTick(() => {
                  context.emit("move-to-page", currentPage, newPath);
                });
              });
              let to = (_a = currentPage$.value.elements) == null ? void 0 : _a.pop();
              component.el$(path).$emit("move-element", path, "after", to);
            } else if (path) {
              context.emit("move-to-page", currentPage, path);
            } else {
              subscribeOnce("added-element", (schema3, path2) => {
                nextTick(() => {
                  context.emit("move-to-page", currentPage, path2);
                });
              });
              context.emit("add-element", JSON.parse(schema2), "after");
            }
          } else if (schema2) {
            context.emit("add-element", JSON.parse(schema2), "after");
          }
          droppingFirst.value = false;
        };
        return {
          ...component,
          tags,
          isEmpty,
          droppingFirst,
          hasPages,
          pageType,
          reset,
          submit,
          handleSelectPage,
          handleRenamePage,
          handleRemovePage,
          handleAddPage,
          handleRemovePages,
          handleMovePage,
          handleMoveToPage,
          handleDragOver,
          handleDragLeave,
          handleDrop
        };
      }
    }),
    () => ({
      apply: ["Vueform"],
      emits: [
        "update-builder",
        "download",
        "closed-changed",
        "announce"
      ],
      props: {
        pluginSettings: {
          required: false,
          type: Boolean,
          default: false
        },
        name: {
          type: String,
          required: false
        },
        sections: {
          required: false,
          type: Object
        },
        fieldOptions: {
          required: false,
          type: Object,
          default: () => ({})
        },
        closed: {
          required: false,
          type: Array,
          default: () => []
        },
        k: {
          required: false,
          type: String,
          default: "key"
        },
        lazy: {
          required: false,
          type: Boolean,
          default: false
        },
        excludeFields: {
          required: false,
          type: Array,
          default: () => []
        },
        builderConfig: {
          required: false,
          type: Object,
          default: () => ({})
        },
        rows: {
          required: false,
          type: Array,
          default: () => []
        }
      },
      setup(props, context, component) {
        const { pluginSettings } = toRefs(props);
        if (!pluginSettings.value) {
          return {
            ...component
          };
        }
        const form = component;
        const {
          sections,
          fieldOptions,
          closed,
          name,
          lazy,
          excludeFields
        } = toRefs(props);
        const icon = resolveComponent("BuilderIcon");
        const tooltip = resolveComponent("BuilderTooltip");
        const config$ = inject("builderConfig$");
        const storage$ = inject("storage$");
        const settingsLocale = inject("settingsLocale");
        const tags = inject("tags");
        const vueform = ref({
          size: "sm",
          displayErrors: false,
          forceLabels: false,
          presets: ["props-form"]
        });
        const closedSections = ref([...closed.value]);
        const onceOpened = ref([
          ...Object.keys(sections.value).filter((s) => sections.value[s].collapsible === false || closed.value.indexOf(s) === -1)
        ]);
        const formLoading = ref(false);
        const watchers = ref([]);
        const watchersLog = ref([]);
        const lastLoad = ref({});
        const loadingSections = ref([]);
        const resolvedFields = computed(() => {
          let fields = [];
          Object.keys(sections.value).forEach((sectionName) => {
            const section = sections.value[sectionName];
            Object.keys(section.fields).forEach((fieldName) => {
              const field = section.fields[fieldName];
              if (excludeFields.value.indexOf(`${sectionName}.${fieldName}`) === -1) {
                fields.push(new field.type({
                  ...fieldOptions.value,
                  extend: field.extend || {},
                  loading: formLoading,
                  emit: context.emit,
                  icon,
                  tooltip,
                  section: section.name,
                  field,
                  closedSections,
                  closeAll,
                  openAll,
                  config$: config$.value,
                  tags,
                  settingsLocale: settingsLocale.value
                }));
              }
            });
          });
          return fields;
        });
        const resolvedSections = computed(() => {
          let tempSections = {};
          Object.keys(sections.value).forEach((sectionName) => {
            const section = sections.value[sectionName];
            let s = {};
            Object.keys(section.fields).forEach((fieldName) => {
              const field = section.fields[fieldName];
              let f = new field.type({
                ...fieldOptions.value,
                extend: field.extend || {},
                loading: formLoading,
                emit: context.emit,
                icon,
                tooltip,
                section: sectionName,
                field,
                closedSections,
                closeAll,
                openAll,
                config$: config$.value,
                tags,
                settingsLocale: settingsLocale.value
              });
              if (excludeFields.value.indexOf(`${sectionName}.${fieldName}`) === -1) {
                s = {
                  ...s,
                  ...f.finalSchema
                };
              }
            });
            tempSections[sectionName] = {
              ...section,
              schema: s
            };
          });
          return tempSections;
        });
        const loadSettings = async (data, section) => {
          if (!section) {
            lastLoad.value = import_lodash2.default.cloneDeep(data);
          }
          await nextTick();
          let load = {};
          formLoading.value = true;
          let fields = resolvedFields.value;
          if (section) {
            fields = fields.filter((f) => f.section === section);
          }
          await asyncForEach(fields, async (field) => {
            load = {
              ...load,
              ...await field.load(data, form) || {}
            };
            if (field.watchers) {
              Object.keys(field.watchers).forEach((elementPath) => {
                field.watchers[elementPath].forEach((watcher) => {
                  let target2 = Array.isArray(watcher[0]) ? watcher[0] : [watcher[0]];
                  target2 = target2.map((t) => computed(() => import_lodash2.default.get(form.data.value, t)));
                  let watcherFunction = (value, old) => {
                    watcher[1](
                      form.el$(elementPath),
                      Array.isArray(watcher[0]) ? value : value[0],
                      Array.isArray(watcher[0]) ? old : old[0]
                    );
                  };
                  let unwatch = watch(target2, watcherFunction);
                  watchers.value.push(unwatch);
                  watchersLog.value.push({
                    target: target2,
                    elementPath,
                    watcherFunction
                  });
                });
              });
            }
          });
          let target = section ? form.el$(section) : form;
          let elements$ = section ? target.children$ : target.elements$.value;
          target.load(load, true);
          Object.keys(elements$).forEach((elementName) => {
            let element$ = elements$[elementName];
            if (!element$.isStatic) {
              element$.messageBag.clear();
            }
          });
          setTimeout(() => {
            formLoading.value = false;
          }, 0);
        };
        const clearSettings = () => {
          formLoading.value = true;
          clearWatchers();
          form.clear();
          setTimeout(() => {
            formLoading.value = false;
          }, 0);
        };
        const clearWatchers = () => {
          watchers.value.forEach((unwatch) => unwatch());
          watchers.value = [];
          watchersLog.value = [];
        };
        const close = (section) => {
          closedSections.value.push(section);
          context.emit("announce", "COLLAPSED");
        };
        const open = async (section) => {
          if (onceOpened.value.indexOf(section) === -1) {
            loadingSections.value.push(section);
            setTimeout(() => {
              onceOpened.value = onceOpened.value.concat([section]);
              closedSections.value = closedSections.value.filter((s) => s !== section);
              nextTick(() => {
                document.querySelectorAll(".vfb-panels-container textarea[data-autogrow]").forEach((textarea) => {
                  component.form$.value.$vueform.services.autosize.update(textarea);
                });
              });
              context.emit("announce", "EXPANDED");
            }, 0);
          } else {
            closedSections.value = closedSections.value.filter((s) => s !== section);
            context.emit("announce", "EXPANDED");
          }
        };
        const toggle = (section) => {
          if (closedSections.value.indexOf(section) !== -1) {
            open(section);
          } else {
            close(section);
          }
        };
        const closeAll = () => {
          closedSections.value = [
            ...Object.keys(sections.value).filter((s) => sections.value[s].collapsible !== false)
          ];
        };
        const openAll = () => {
          closedSections.value = [];
          let neverOpened = Object.keys(sections.value).filter((s) => onceOpened.value.indexOf(s) === -1);
          neverOpened.forEach((section) => {
            loadingSections.value.push(section);
          });
          setTimeout(() => {
            onceOpened.value = [
              ...Object.keys(sections.value).filter((s) => sections.value[s].collapsible !== false)
            ];
          }, 0);
        };
        const handleFormSubmit = () => {
          if ("activeElement" in document) {
            document.activeElement.blur();
          }
        };
        watch(closedSections, (n) => {
          if (!lazy.value) {
            storage$.value.set(`${name.value}-closed`, JSON.stringify(n));
            context.emit("closed-changed", n);
          }
        }, { deep: true });
        watch(name, (n) => {
          if (n && storage$.value.get(`${n}-closed`)) {
            closedSections.value = JSON.parse(storage$.value.get(`${n}-closed`));
          }
        }, { immediate: false });
        watch(onceOpened, async (n, o) => {
          if (!lazy.value) {
            import_lodash2.default.difference(n, o).forEach((section) => {
              loadingSections.value = loadingSections.value.filter((s) => s !== section);
            });
            return;
          }
          await nextTick();
          await asyncForEach(import_lodash2.default.difference(n, o), async (section) => {
            loadingSections.value.push(section);
            await loadSettings(lastLoad.value, section);
            loadingSections.value = loadingSections.value.filter((s) => s !== section);
          });
        }, { immediate: false });
        onMounted(() => {
          if (lazy.value) {
            return;
          }
          if (storage$.value.get(`${name.value}-closed`)) {
            closedSections.value = JSON.parse(storage$.value.get(`${name.value}-closed`));
          }
        });
        return {
          ...form,
          tags,
          vueform,
          onceOpened,
          closedSections,
          resolvedSections,
          loadSettings,
          clearSettings,
          clearWatchers,
          toggle,
          closeAll,
          openAll,
          handleFormSubmit,
          watchers,
          watchersLog,
          loadingSections
        };
      }
    }),
    () => ({
      apply: ["FormElements"],
      props: {
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        draggedSchema: {
          required: false,
          type: Object
        }
      }
    }),
    () => ({
      apply: ["FormTabs", "FormSteps"],
      emits: [
        "rename-page",
        "add-page",
        "remove-pages",
        "remove-page",
        "move-page",
        "move-to-page",
        "add-element",
        "select-page",
        "start-moving"
      ],
      props: {
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        draggedSchema: {
          required: false,
          type: Object
        },
        moving: {
          required: false,
          type: [Boolean, Object],
          default: false
        },
        pointer: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const announce = inject("announce");
        const tags = inject("tags");
        const wrapper = ref(null);
        const handleSelectPage = (name) => {
          context.emit("select-page", name);
        };
        const handleRenamePage = (page, value) => {
          context.emit("rename-page", page, value);
        };
        const handleAddClick = () => {
          context.emit("add-page");
          nextTick(() => {
            component.last$.value.edit();
          });
        };
        const handleRemoveClick = () => {
          context.emit("remove-pages");
          context.emit("select-page", null);
          announce("REMOVED");
        };
        const handleRemovePage = (value) => {
          context.emit("remove-page", value);
        };
        const handleMovePage = (page, position, target) => {
          context.emit("move-page", page, position, target);
        };
        const handleMoveToPage = (page, schema, parentPath) => {
          context.emit("move-to-page", page, schema, parentPath);
        };
        const handleAddElement = (schema, position, targetPath) => {
          context.emit("add-element", schema, position, targetPath);
        };
        const handleStartMoving = (page, source) => {
          context.emit("start-moving", page, source);
        };
        return {
          ...component,
          tags,
          wrapper,
          handleRenamePage,
          handleAddClick,
          handleRemoveClick,
          handleRemovePage,
          handleMovePage,
          handleMoveToPage,
          handleAddElement,
          handleSelectPage,
          handleStartMoving
        };
      }
    }),
    () => ({
      apply: ["FormTab"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const tags = inject("tags");
        const removeConfirm = computed(() => tags.tabs_remove_confirm);
        const pageLabel = computed(() => {
          return component.tabLabel.value;
        });
        const pages$ = computed(() => {
          var _a;
          return (_a = component.tabs$.value) == null ? void 0 : _a.tabs$;
        });
        const goTo = (name) => {
          component.form$.value.tabs$.goTo(name);
        };
        return {
          ...component,
          tags,
          removeConfirm,
          pageLabel,
          pages$,
          goTo
        };
      }
    }),
    () => ({
      apply: ["FormStep"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const tags = inject("tags");
        const removeConfirm = computed(() => tags.steps_remove_confirm);
        const pageLabel = computed(() => {
          return component.stepLabel.value;
        });
        const pages$ = computed(() => {
          var _a;
          return (_a = component.steps$.value) == null ? void 0 : _a.steps$;
        });
        const goTo = (name) => {
          component.form$.value.steps$.goTo(name);
        };
        return {
          ...component,
          tags,
          removeConfirm,
          pageLabel,
          pages$,
          goTo
        };
      }
    }),
    () => ({
      apply: ["FormTab", "FormStep"],
      props: {
        builder: {
          type: Object,
          required: false
        },
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        draggedSchema: {
          required: false,
          type: Object
        },
        moving: {
          required: false,
          type: [Boolean, Object],
          default: false
        },
        pointer: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      emits: [
        "rename-page",
        "remove-page",
        "move-page",
        "move-to-page",
        "add-element",
        "select-page",
        "start-moving"
      ],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const { name, draggingPage, moving, pointer } = toRefs(props);
        const subscribeOnce = inject("subscribeOnce");
        const announce = inject("announce");
        const editing = ref(false);
        const editLabel = ref(null);
        const input = ref(null);
        const highlighted = ref(null);
        const beingDragged = computed(() => {
          return draggingPage.value === name.value;
        });
        const selectedPage = computed(() => {
          return component.form$.value.selectedPage;
        });
        const isSelected = computed(() => {
          return name.value === selectedPage.value;
        });
        const beingMoved = computed(() => {
          if (!moving.value) {
            return false;
          }
          return moving.value.source === "preview" && moving.value.type === "page" && moving.value.path === name.value;
        });
        const pointed = computed(() => {
          return moving.value.source === "preview" && pointer.value.path === name.value && (moving.value.type === "page" || pointer.value.type === "page");
        });
        const index = computed(() => {
          return parseInt(name.value.replace("page", ""));
        });
        const count = computed(() => {
          return Object.keys(component.form$.value[`${pageType.value}s`]).length;
        });
        const pageType = computed(() => {
          return component.form$.value.pageType;
        });
        const edit = () => {
          editing.value = true;
          editLabel.value = component.pageLabel.value;
          nextTick(() => {
            input.value.select();
          });
        };
        const save = () => {
          editing.value = false;
          context.emit("rename-page", name.value, editLabel.value);
        };
        const cancel = () => {
          editing.value = false;
        };
        const focus = (path) => {
          component.form$.value.$el.querySelector(`[data-page="${path}"]`).focus();
        };
        const handleClick = (e) => {
          e.stopPropagation();
          if (component.form$.value.editorMode && !e.ctrlKey && !e.metaKey) {
            context.emit("select-page", name.value);
            component.form$.value.$emit("select-element", null);
          }
          component.select();
        };
        const handleKeyDown = (e) => {
          if (component.form$.value.editorMode) {
            if (["Enter"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              context.emit("select-page", name.value);
              component.form$.value.$emit("select-element", null);
              setTimeout(() => {
                e.target.closest(".vfb-builder").querySelector(".vfb-config-panel-container-page").focus();
              }, 1e3);
              announce("CONFIG_PANEL_OPENED");
            } else if ([" "].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              announce("PAGE_GRABBED", {
                page: component.pageLabel.value
              });
              context.emit("start-moving", {
                path: name.value,
                source: "preview",
                type: "page"
              });
            } else if (["ArrowRight"].indexOf(e.key) !== -1) {
              e.preventDefault();
              if (count.value > index.value + 1) {
                focus(`page${index.value + 1}`);
              }
            } else if (["ArrowLeft"].indexOf(e.key) !== -1) {
              e.preventDefault();
              if (index.value > 0) {
                focus(`page${index.value - 1}`);
              }
            } else if (["Delete"].indexOf(e.key) !== -1) {
              e.preventDefault();
              handleRemoveClick();
            }
          }
          if (["Enter", " "].indexOf(e.key) !== -1) {
            component.select();
          }
        };
        const handleDoubleClick = () => {
          if (!component.form$.value.editorMode) {
            return;
          }
          edit();
        };
        const handleEditClick = () => {
          context.emit("select-page", name.value);
        };
        const handleConditionsClick = () => {
        };
        const handleRemoveClick = () => {
          if (Object.keys(component.children$.value).length && Object.keys(component.pages$.value).length > 1 && !confirm(component.removeConfirm.value)) {
            return;
          }
          context.emit("remove-page", name.value);
        };
        const handleClearClick = () => {
        };
        const handleInputBlur = () => {
          if (!editing.value) {
            return;
          }
          save();
        };
        const handleInputKeyDown = (e) => {
          if (e.key === "Enter") {
            save();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            cancel();
          }
        };
        const handleDragStart = (e) => {
          e.dataTransfer.setData("page", name.value);
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.dropEffect = "move";
        };
        const handleDragEnd = () => {
        };
        const handleDragOver = (e, position) => {
          e.preventDefault();
          highlighted.value = position;
          if (position === "middle") {
            component.goTo(name.value);
            if (selectedPage.value !== name.value) {
              context.emit("select-page", name.value);
            }
          }
        };
        const handleDragLeave = () => {
          highlighted.value = null;
        };
        const handleDrop = (e, position) => {
          var _a;
          highlighted.value = null;
          let page = e.dataTransfer.getData("page") || void 0;
          if (page) {
            context.emit("move-page", page, position, name.value);
            return;
          }
          let path = e.dataTransfer.getData("path") || void 0;
          if (path && path.match(/\./)) {
            subscribeOnce("moved-element", (newPath) => {
              nextTick(() => {
                context.emit("move-to-page", name.value, newPath);
              });
            });
            let to = (_a = component.form$.value.tabs$.current$.elements) == null ? void 0 : _a.pop();
            component.form$.value.el$(path).$emit("move-element", path, "after", to);
          } else if (path) {
            context.emit("move-to-page", name.value, path);
          } else {
            let schema = JSON.parse(e.dataTransfer.getData("schema"));
            subscribeOnce("added-element", (schema2, path2) => {
              nextTick(() => {
                context.emit("move-to-page", name.value, path2);
              });
            });
            context.emit("add-element", schema, "after");
          }
        };
        return {
          ...component,
          handleKeyDown,
          handleDoubleClick,
          handleEditClick,
          handleConditionsClick,
          handleRemoveClick,
          handleClearClick,
          handleInputBlur,
          handleInputKeyDown,
          handleDragStart,
          handleDragEnd,
          handleDragOver,
          handleDragLeave,
          handleDrop,
          handleClick,
          edit,
          pointed,
          beingMoved,
          isSelected,
          selectedPage,
          beingDragged,
          highlighted,
          editing,
          editLabel,
          input
        };
      }
    }),
    () => ({
      apply: ["FormStepsControls"],
      emits: [
        "select-page"
      ],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const isSelected = computed(() => {
          return !!component.form$.value.selectedPage;
        });
        const handleClick = () => {
          if (component.form$.value.editorMode) {
            nextTick(() => {
              context.emit("select-page", component.form$.value.steps$.current$.name);
            });
          }
        };
        return {
          ...component,
          isSelected,
          handleClick
        };
      }
    }),
    () => ({
      apply: ["HiddenElement"],
      props: {
        classes: {
          required: false,
          type: Object,
          default: () => ({})
        },
        columnsClasses: {
          required: false,
          type: Object,
          default: () => ({
            container: "col-span-12",
            innerContainer: "col-span-12",
            wrapper: "col-span-12"
          })
        },
        visible: {
          required: false,
          type: Boolean,
          default: true
        }
      }
    }),
    () => ({
      apply: ["StaticElement"],
      props: {
        sourcePath: {
          type: String,
          required: false
        },
        emptyText: {
          type: String,
          required: false
        },
        handleEvent: {
          type: Function,
          required: false
        },
        conditionType: {
          type: String,
          required: false
        }
      }
    }),
    () => ({
      apply: ["FileElement"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const axios = {
          request: (options) => {
            return new Promise((resolve) => {
              let { data } = options;
              return resolve(options.url == "/vueform/file/remove" ? true : {
                data: data.get([...data.keys()][0]).name
              });
            });
          },
          CancelToken: { source: () => ({ token: "token" }) },
          token: null,
          isCancel: () => {
            return false;
          },
          __CUSTOM__: true
        };
        watch(component.axios, (n) => {
          if (!n.__CUSTOM__) {
            component.axios.value = axios;
          }
        });
        return {
          ...component,
          axios
        };
      }
    }),
    () => ({
      apply: ["ListElement"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const { element, initial } = toRefs(props);
        const tags = inject("tags");
        const hasPrototype = computed(() => {
          var _a;
          return component.isObject.value && component.prototype.value.schema || !component.isObject.value && element && ((_a = element.value) == null ? void 0 : _a.type);
        });
        const childName = computed(() => {
          var _a, _b, _c;
          if (!element || !((_a = element.value) == null ? void 0 : _a.type) || !((_c = (_b = element.value) == null ? void 0 : _b.builder) == null ? void 0 : _c.type)) {
            return;
          }
          return tags.list_repeat_child_name;
        });
        const reset = (setDefault = true) => {
          component.value.value = setDefault ? import_lodash2.default.cloneDeep(component.defaultValue.value) : import_lodash2.default.cloneDeep(component.nullValue.value);
          component.resetValidators();
          let instances = component.form$.value.editorMode ? 1 : initial.value;
          if (!component.value.value.length && instances > 0) {
            for (let i = 0; i < instances; i++) {
              component.add();
            }
            nextTick(() => {
              component.children$Array.value.forEach((child$) => {
                child$.reset();
              });
            });
          }
          nextTick(() => {
            component.refreshOrderStore(component.value.value);
          });
        };
        return {
          ...component,
          hasPrototype,
          childName,
          reset
        };
      }
    }),
    () => ({
      apply: ["ObjectElement", "GroupElement"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const reset = (setDefault = true) => {
          import_lodash2.default.each(component.children$.value, (element$) => {
            if (element$.isStatic) {
              return;
            }
            element$.reset(setDefault);
          });
        };
        return {
          ...component,
          reset
        };
      }
    }),
    () => ({
      apply: ["ObjectElement", "GroupElement", "ListElement"],
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const nestingLevel = computed(() => {
          return component.el$.value.path.split(".").length - 1;
        });
        return {
          ...component,
          nestingLevel
        };
      }
    }),
    () => ({
      apply: ["FormElements", "Vueform", "GroupElement", "ObjectElement", "ListElement"],
      emits: [
        "add-element",
        "move-element",
        "select-element",
        "clone-element",
        "remove-element",
        "resize-element",
        "set-dragged-schema",
        "announce",
        "start-moving"
      ],
      props: {
        editorMode: {
          required: false,
          type: Boolean,
          default: false
        },
        moving: {
          required: false,
          type: [Boolean, Object],
          default: false
        },
        pointer: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const handleAddElement = (schema, position, targetPath) => {
          context.emit("add-element", schema, position, targetPath);
        };
        const handleMoveElement = (from, position, to) => {
          context.emit("move-element", from, position, to);
        };
        const handleSelectElement = (path) => {
          context.emit("select-element", path);
        };
        const handleCloneElement = (path) => {
          context.emit("clone-element", path);
        };
        const handleRemoveElement = (path) => {
          context.emit("remove-element", path);
        };
        const handleResizeElement = (path, width) => {
          context.emit("resize-element", path, width);
        };
        const handleSetDraggedSchema = (schema) => {
          context.emit("set-dragged-schema", schema);
        };
        const handleAnnounce = (msg, params) => {
          context.emit("announce", msg, params);
        };
        const handleStartMoving = (path, source) => {
          context.emit("start-moving", path, source);
        };
        return {
          ...component,
          handleAddElement,
          handleMoveElement,
          handleSelectElement,
          handleCloneElement,
          handleRemoveElement,
          handleResizeElement,
          handleSetDraggedSchema,
          handleAnnounce,
          handleStartMoving
        };
      }
    }),
    () => ({
      apply: /^[a-zA-Z]*Element$/,
      emits: [
        "add-element",
        "move-element",
        "select-element",
        "clone-element",
        "remove-element",
        "resize-element",
        "set-dragged-schema",
        "announce",
        "start-moving"
      ],
      props: {
        builder: {
          required: false,
          type: Object
        },
        droppable: {
          required: false,
          type: Boolean,
          default: true
        },
        cloneable: {
          required: false,
          type: Boolean,
          default: true
        },
        displayName: {
          required: false,
          type: String
        },
        allowSiblings: {
          required: false,
          type: Boolean,
          default: true
        },
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        draggedSchema: {
          required: false,
          type: Object
        },
        moving: {
          required: false,
          type: [Boolean, Object],
          default: false
        },
        pointer: {
          required: false,
          type: Object,
          default: () => ({})
        }
      },
      setup(props, context, component) {
        if (!component.form$.value.builder) {
          return component;
        }
        const { droppable, draggingElement, moving, pointer } = toRefs(props);
        const highlighted = ref(false);
        const beingDragged = computed(() => {
          return draggingElement.value === component.path.value;
        });
        const Droppable = computed(() => {
          return !beingDragged.value && droppable.value;
        });
        const pointed = computed(() => {
          var _a;
          return moving.value && moving.value.source === "preview" && ((_a = pointer.value) == null ? void 0 : _a.path) === component.path.value;
        });
        const announce = (msg, params) => {
          context.emit("announce", msg, params);
        };
        return {
          ...component,
          announce,
          highlighted,
          beingDragged,
          Droppable,
          pointed
        };
      }
    }),
    () => ({
      apply: "ElementLayout",
      emits: [
        "add-element",
        "select-element",
        "clone-element",
        "remove-element",
        "resize-element",
        "announce"
      ],
      props: {
        draggingElement: {
          required: false,
          type: [null, String, Boolean]
        },
        draggingPage: {
          required: false,
          type: [null, String, Boolean]
        },
        draggedSchema: {
          required: false,
          type: Object
        }
      },
      setup(props, context, component) {
        var _a, _b;
        if (!component.form$.value.builder) {
          return component;
        }
        const config$ = inject("builderConfig$");
        const tags = inject("tags");
        const hovered = ref(false);
        const focused = ref(false);
        const startingWidth = ref(0);
        const elementWidth = ref(null);
        const lastWidth = ref(0);
        const editing = ref(false);
        const resizing = ref(false);
        const multiResizing = ref(false);
        let deviceSizeMap = ref({
          default: "default",
          tablet: (_a = config$.value.breakpoints) == null ? void 0 : _a.tablet.breakpoint,
          desktop: (_b = config$.value.breakpoints) == null ? void 0 : _b.desktop.breakpoint
        });
        const nextElement$ = ref(null);
        const autoflow = computed(() => {
          return config$.value.autoflow;
        });
        const defaultWidths = computed(() => {
          return component.form$.value.columns || {};
        });
        const names = computed(() => {
          return component.form$.value.builderConfig.names;
        });
        const device = computed(() => {
          return component.el$.value.form$.device || "default";
        });
        const size = computed(() => {
          return deviceSizeMap.value[device.value];
        });
        const rows = computed(() => {
          return component.form$.value.rows;
        });
        const sizes = computed(() => {
          return Object.values(deviceSizeMap.value);
        });
        const moving = computed(() => {
          if (!component.el$.value.moving) {
            return false;
          }
          let moving2 = component.el$.value.moving;
          return moving2.source === "preview" && moving2.type === "element" && moving2.path === path.value;
        });
        const path = computed(() => {
          return component.el$.value.path;
        });
        const flatTree = computed(() => {
          return component.el$.value.form$.flatTree || [];
        });
        const selectedElement = computed(() => {
          return component.form$.value.selectedElement;
        });
        const elementIndex = computed(() => {
          return flatTree.value.indexOf(path.value);
        });
        const isSelected = computed(() => {
          return selectedElement.value === path.value;
        });
        const highlighted = computed({
          get() {
            return component.el$.value.highlighted;
          },
          set(val) {
            component.el$.value.highlighted = val;
          }
        });
        const childRestrictions = computed(() => {
          let childRestrictions2 = getChildRestrictions(component.el$.value);
          return childRestrictions2;
        });
        const canRemove = computed(() => {
          var _a2;
          return !childRestrictions.value.remove && ((_a2 = component.el$.value.builder) == null ? void 0 : _a2.remove) !== false;
        });
        const canClone = computed(() => {
          var _a2;
          return !childRestrictions.value.clone && ((_a2 = component.el$.value.builder) == null ? void 0 : _a2.clone) !== false && component.el$.value.cloneable;
        });
        const canEdit = computed(() => {
          var _a2;
          return ((_a2 = component.el$.value.builder) == null ? void 0 : _a2.edit) !== false;
        });
        const canMove = computed(() => {
          var _a2;
          return !childRestrictions.value.move && ((_a2 = component.el$.value.builder) == null ? void 0 : _a2.move) !== false;
        });
        const canResize = computed(() => {
          var _a2;
          return !childRestrictions.value.resize && ((_a2 = component.el$.value.builder) == null ? void 0 : _a2.resize) !== false && (autoflow.value || !component.el$.value.isObjectType && !component.el$.value.isGroupType && !component.el$.value.isListType);
        });
        const canMultiResize = computed(() => {
          return autoflow.value && row.value.indexOf(path.value) !== row.value.length - 1;
        });
        const canDragInside = computed(() => {
          if (["object", "group"].indexOf(component.el$.value.type) !== -1) {
            return !Object.keys(component.el$.value.children).length && (!component.el$.value.draggedSchema || ["tabs", "steps"].indexOf(component.el$.value.draggedSchema.type) === -1);
          } else if (["list"].indexOf(component.el$.value.type) !== -1) {
            return !component.el$.value.hasPrototype && (!component.el$.value.draggedSchema || ["list", "tabs", "steps"].indexOf(component.el$.value.draggedSchema.type) === -1);
          }
          return false;
        });
        const canDragSibling = computed(() => {
          return !component.el$.value.draggedSchema || ["tabs", "steps"].indexOf(component.el$.value.draggedSchema.type) === -1;
        });
        const hideDragLine = computed(() => {
          return false;
        });
        const ariaLabel = computed(() => {
          return path.value.replace(/\./g, " / ");
        });
        const pageType = computed(() => {
          return component.form$.value.pageType;
        });
        const duplicates = computed(() => {
          return component.form$.value.modelDuplicates.filter((d) => d.dataPath === component.el$.value.dataPath);
        });
        const hasWarning = computed(() => {
          return duplicates.value.length;
        });
        const currentColumns = computed(() => {
          var _a2, _b2, _c;
          if (!component.el$.value.columnsClassesService) {
            return 12;
          }
          let columns = component.el$.value.columnsClassesService.cols;
          let currentColumns2;
          const part = autoflow.value ? "container" : "wrapper";
          const defaultColumn = ((_b2 = (_a2 = defaultWidths.value) == null ? void 0 : _a2[size]) == null ? void 0 : _b2[part]) || ((_c = defaultWidths.value) == null ? void 0 : _c[part]) || 12;
          if (columns[size.value]) {
            currentColumns2 = columns[size.value][part] || defaultColumn;
          } else {
            let sizeList = [...sizes.value].reverse();
            let index = sizeList.indexOf(size.value);
            sizeList.forEach((s, i) => {
              if (i > index && !currentColumns2) {
                if (columns[s]) {
                  currentColumns2 = columns[s][part];
                }
              }
            });
            if (!currentColumns2) {
              currentColumns2 = columns.default[part] || defaultColumn;
            }
          }
          return currentColumns2;
        });
        const row = computed(() => {
          return rows.value.find((r) => r.indexOf(path.value) !== -1) || [];
        });
        const getChildRestrictions = (schema) => {
          let restrictions = {
            remove: false,
            clone: false,
            move: false,
            edit: false,
            resize: false
          };
          if (!schema || ["object", "group", "list"].indexOf(schema.type) === -1) {
            return restrictions;
          }
          let children = ["object", "group"].indexOf(schema.type) !== -1 ? schema.schema || {} : schema.element ? { [0]: schema.element } : {};
          Object.values(children).forEach((childSchema) => {
            var _a2, _b2, _c, _d, _e;
            if (Object.values(restrictions).some((r) => !r)) {
              let childRestrictions2 = ["object", "group", "list"].indexOf(childSchema.type) !== -1 ? getChildRestrictions(childSchema) : {
                remove: ((_a2 = childSchema.builder) == null ? void 0 : _a2.remove) === false,
                clone: ((_b2 = childSchema.builder) == null ? void 0 : _b2.clone) === false,
                move: ((_c = childSchema.builder) == null ? void 0 : _c.move) === false,
                edit: ((_d = childSchema.builder) == null ? void 0 : _d.edit) === false,
                resize: ((_e = childSchema.builder) == null ? void 0 : _e.resize) === false
              };
              Object.keys(restrictions).forEach((key) => {
                if (childRestrictions2[key]) {
                  restrictions[key] = true;
                }
              });
            }
          });
          return restrictions;
        };
        const startEditing = () => {
          announce("ELEMENT_GRABBED", {
            element: ariaLabel.value
          });
          editing.value = true;
        };
        const stopEditing = () => {
          editing.value = false;
        };
        const startMoving = () => {
          component.el$.value.$emit("start-moving", {
            path: path.value,
            source: "preview",
            type: "element"
          });
        };
        const stopMoving = () => {
          stopEditing();
        };
        const startResizing = () => {
          lastWidth.value = currentColumns.value;
          startingWidth.value = lastWidth.value;
          resizing.value = true;
          getElementDOM(path.value).focus();
        };
        const stopResizing = (save) => {
          stopEditing();
          resizing.value = false;
          let msg;
          let params = {};
          if (startingWidth.value !== lastWidth.value && save) {
            msg = "SAVED_WIDTH";
            params = {
              width: lastWidth.value
            };
            saveColums();
          } else {
            msg = "CANCEL_WIDTH";
            params = {
              width: startingWidth.value
            };
            if (!save && lastWidth.value !== startingWidth.value) {
              updateWidth(startingWidth.value, false);
            }
          }
          announce(msg, params);
        };
        const saveResizing = () => {
          stopResizing(true);
        };
        const cancelResizing = () => {
          stopResizing(false);
        };
        const updateWidth = (width, shouldAnnounce = true) => {
          if (width === lastWidth.value) {
            return;
          }
          lastWidth.value = width;
          let columns = component.el$.value.columns;
          if (size.value === "default") {
            if (columns && typeof columns === "object") {
              if (columns.container || columns.label || columns.wrapper) {
                columns[autoflow.value ? "container" : "wrapper"] = width;
              } else {
                if (!columns.default) {
                  columns.default = {};
                }
                columns.default[autoflow.value ? "container" : "wrapper"] = width;
              }
            } else {
              columns = { [autoflow.value ? "container" : "wrapper"]: width };
            }
          } else {
            if (columns && typeof columns === "object") {
              if (!columns[size.value]) {
                if (columns.container || columns.label || columns.wrapper) {
                  columns = {
                    default: columns,
                    [size.value]: {
                      [autoflow.value ? "container" : "wrapper"]: width
                    }
                  };
                } else {
                  columns[size.value] = {
                    [autoflow.value ? "container" : "wrapper"]: width
                  };
                }
              } else {
                columns[size.value][autoflow.value ? "container" : "wrapper"] = width;
              }
            } else {
              columns = {
                [size.value]: {
                  [autoflow.value ? "container" : "wrapper"]: width
                }
              };
            }
          }
          component.el$.value.updateColumns(columns);
          if (shouldAnnounce) {
            announce("WIDTH_CHANGED", { width });
          }
        };
        const saveColums = () => {
          component.el$.value.$emit("resize-element", path.value, lastWidth.value);
        };
        const getSiblingPath = (distance) => {
          let index = flatTree.value.indexOf(path.value);
          let sibling = flatTree.value[index + distance] || (distance > 0 ? flatTree.value[flatTree.value.length - 1] : flatTree.value[0]);
          if (!sibling) {
            return;
          }
          return sibling;
        };
        const getElementDOM = (path2) => {
          return component.el$.value.form$.$el.querySelector(`[data-path="${path2}"]`);
        };
        const focusElement = (path2) => {
          let dom = getElementDOM(path2);
          dom == null ? void 0 : dom.focus();
          if (isInOtherPage(path2)) {
            goToPageThatContains(path2);
            nextTick(() => {
              var _a2;
              (_a2 = getElementDOM(path2)) == null ? void 0 : _a2.focus();
            });
          }
        };
        const isInOtherPage = (path2) => {
          return window.getComputedStyle(getElementDOM(path2)).getPropertyValue("display") === "none" && component.form$.value.hasPages;
        };
        const goToPageThatContains = (path2) => {
          let page = Object.keys(component.form$.value[`${pageType.value}s`]).find((name) => {
            let page2 = component.form$.value[`${pageType.value}s`][name];
            let rootPath = path2.split(".")[0];
            return page2.elements.indexOf(rootPath) !== -1;
          });
          component.form$.value[`${pageType.value}s$`].goTo(page);
        };
        const announce = (msg, params) => {
          component.el$.value.announce(msg, params);
        };
        const getNextElementInRow = () => {
          return component.form$.value.el$(row.value[row.value.indexOf(path.value) + 1]);
        };
        const handleOverlayClick = () => {
          if (!canEdit.value) {
            return;
          }
          component.el$.value.$emit("select-element", path.value);
          component.form$.value.$emit("select-page", null);
        };
        const handleCloneClick = () => {
          component.el$.value.$emit("clone-element", path.value);
        };
        const handleRemoveClick = () => {
          component.el$.value.$emit("remove-element", path.value);
        };
        const handleDragStart = function(e) {
          e.dataTransfer.effectAllowed = "move";
          let schema = getElementSchemaByPath(component.form$.value.options.schema, path.value);
          e.dataTransfer.setData("schema", JSON.stringify(schema));
          e.dataTransfer.setData("path", path.value);
          component.el$.value.$emit("set-dragged-schema", schema);
        };
        const handleDragEnd = (e) => {
          component.el$.value.$emit("set-dragged-schema", null);
        };
        const handleDragOver = (e, position) => {
          e.preventDefault();
          if (!component.el$.value.Droppable || component.el$.value.beingDragged) {
            return;
          }
          highlighted.value = position;
        };
        const handleDragLeave = (e) => {
          setTimeout(() => {
            highlighted.value = null;
          }, 0);
        };
        const handleDrop = (e, position) => {
          e.preventDefault();
          if (!component.el$.value.Droppable) {
            return;
          }
          highlighted.value = null;
          const originalPath = e.dataTransfer.getData("path") || void 0;
          if (originalPath) {
            component.el$.value.$emit("move-element", originalPath, position, path.value);
          } else {
            const schema = JSON.parse(e.dataTransfer.getData("schema"));
            component.el$.value.$emit("add-element", schema, position, path.value);
          }
        };
        const handleResizeDragStart = (e) => {
          e.dataTransfer.effectAllowed = "move";
          lastWidth.value = 0;
          let path2 = e.path || (e == null ? void 0 : e.composedPath());
          const target = path2[1];
          const container = autoflow.value ? path2[2] : path2[5];
          elementWidth.value = {
            from: target.getBoundingClientRect().x,
            to: target.getBoundingClientRect().x + container.getBoundingClientRect().width
          };
          resizing.value = true;
        };
        const handleResizeDrag = (e) => {
          let end = elementWidth.value.to - elementWidth.value.from;
          let current = e.x - elementWidth.value.from;
          let width = Math.round(current / end * 12);
          if (width < 1) {
            width = 1;
          }
          if (width > 12) {
            width = 12;
          }
          if (!(e.x === 0 && e.y === 0)) {
            updateWidth(width, false);
          }
        };
        const handleResizeDragEnd = (e) => {
          resizing.value = false;
          saveColums();
        };
        const handleResizeMultiDragMouseDown = (e) => {
          nextElement$.value = getNextElementInRow();
          if (!nextElement$.value) {
            return;
          }
          focused.value = true;
          nextElement$.value.container.focused = true;
        };
        const handleResizeMultiDragMouseUp = (e) => {
          focused.value = false;
          nextElement$.value.container.focused = false;
        };
        const handleResizeMultiDragStart = (e) => {
          nextElement$.value = getNextElementInRow();
          if (!nextElement$.value) {
            return;
          }
          e.dataTransfer.effectAllowed = "move";
          lastWidth.value = currentColumns.value;
          startingWidth.value = lastWidth.value;
          nextElement$.value.container.startingWidth = nextElement$.value.container.currentColumns;
          focused.value = true;
          nextElement$.value.container.focused = true;
          let path2 = e.path || (e == null ? void 0 : e.composedPath());
          const target = path2[1];
          const container = path2[2];
          elementWidth.value = {
            from: target.getBoundingClientRect().x,
            to: target.getBoundingClientRect().x + container.getBoundingClientRect().width
          };
          multiResizing.value = true;
        };
        const handleResizeMultiDrag = (e) => {
          if (!nextElement$.value) {
            return;
          }
          focused.value = true;
          nextElement$.value.container.focused = true;
          let end = elementWidth.value.to - elementWidth.value.from;
          let current = e.x - elementWidth.value.from;
          let width = Math.round(current / end * 12);
          if (width < 1) {
            width = 1;
          }
          if (width > 11) {
            width = 11;
          }
          if (!(e.x === 0 && e.y === 0)) {
            updateWidth(width, false);
            const otherChange = nextElement$.value.container.startingWidth + (width - startingWidth.value) * -1;
            nextElement$.value.container.updateWidth(otherChange > 1 ? otherChange : 1);
          }
        };
        const handleResizeMultiDragEnd = (e) => {
          if (!nextElement$.value) {
            return;
          }
          focused.value = false;
          nextElement$.value.container.focused = false;
          multiResizing.value = false;
          saveColums();
          const otherChange = nextElement$.value.container.startingWidth + (lastWidth.value - startingWidth.value) * -1;
          nextElement$.value.$emit("resize-element", nextElement$.value.path, otherChange > 1 ? otherChange : 1);
        };
        const handleFocus = () => {
          focused.value = true;
        };
        const handleBlur = () => {
          focused.value = false;
        };
        const decreaseColumns = (shiftKey) => {
          let value = lastWidth.value - 1;
          if (shiftKey) {
            value = lastWidth.value > 6 ? 6 : 1;
          }
          updateWidth(value);
        };
        const increaseColumns = (shiftKey) => {
          let value = lastWidth.value + 1;
          if (shiftKey) {
            value = lastWidth.value < 6 ? 6 : 12;
          }
          updateWidth(value);
        };
        const handleKeydown = (e) => {
          if (!focused.value && !resizing.value) {
            return;
          }
          if (resizing.value) {
            if (e.key === "ArrowLeft" && lastWidth.value > 1) {
              e.preventDefault();
              e.stopPropagation();
              decreaseColumns(e.shiftKey);
            } else if (e.key === "ArrowRight" && lastWidth.value < 12) {
              e.preventDefault();
              e.stopPropagation();
              increaseColumns(e.shiftKey);
            } else if ([" ", "Enter"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              saveResizing();
            } else if (["Escape"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              cancelResizing();
            } else if (["Tab"].indexOf(e.key) !== -1) {
              cancelResizing();
            }
          } else if (editing.value) {
            if (["ArrowLeft", "ArrowRight"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              if (!canResize.value) {
                return;
              }
              startResizing();
              if (e.key === "ArrowLeft" && lastWidth.value > 1) {
                decreaseColumns(e.shiftKey);
              } else if (e.key === "ArrowRight" && lastWidth.value < 12) {
                increaseColumns(e.shiftKey);
              }
            } else if (["ArrowUp", "ArrowDown"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              if (!canMove.value) {
                return;
              }
              startMoving();
            } else if ([" ", "Escape"].indexOf(e.key) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              stopEditing();
            } else if (["Tab"].indexOf(e.key) !== -1) {
              stopEditing();
            }
          } else {
            if (e.key === "Enter") {
              e.preventDefault();
              e.stopPropagation();
              if (!canEdit.value) {
                return;
              }
              handleOverlayClick();
              announce("CONFIG_PANEL_OPENED");
              setTimeout(() => {
                e.target.closest(".vfb-builder").querySelector(".vfb-config-panel-container-element").focus();
              }, 1e3);
            } else if (e.key === " ") {
              e.preventDefault();
              e.stopPropagation();
              if (!canMove.value && !canResize.value) {
                return;
              }
              startEditing();
            } else if (e.key === "Delete") {
              e.preventDefault();
              e.stopPropagation();
              if (!canRemove.value) {
                return;
              }
              handleRemoveClick();
              if (flatTree.value[elementIndex.value + 1]) {
                focusElement(getSiblingPath(1));
              } else if (flatTree.value[elementIndex.value - 1]) {
                focusElement(getSiblingPath(-1));
              } else {
                e.target.closest(".vfb-builder").querySelector(".vfb-preview-wrapper").focus();
              }
            } else if (e.key === "ArrowDown" && e.shiftKey) {
              e.preventDefault();
              e.stopPropagation();
              let last = component.el$.value.form$.$el.querySelector(".vfb-preview-form > div > .vfb-preview-element-container:last-of-type");
              if (last) {
                last.focus();
              }
            } else if (e.key === "ArrowUp" && e.shiftKey) {
              e.preventDefault();
              e.stopPropagation();
              let first = component.el$.value.form$.$el.querySelector(".vfb-preview-form > div > .vfb-preview-element-container:first-of-type");
              if (first) {
                first.focus();
              }
            } else if (e.key === "ArrowDown") {
              e.preventDefault();
              e.stopPropagation();
              focusElement(getSiblingPath(1));
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              e.stopPropagation();
              focusElement(getSiblingPath(-1));
            }
          }
        };
        watch(moving, (n, o) => {
          if (!n) {
            stopMoving();
          }
        });
        return {
          ...component,
          tags,
          autoflow,
          names,
          ariaLabel,
          editing,
          resizing,
          multiResizing,
          moving,
          highlighted,
          hovered,
          focused,
          startingWidth,
          elementWidth,
          lastWidth,
          isSelected,
          canRemove,
          canClone,
          canEdit,
          canMove,
          canResize,
          canDragInside,
          canDragSibling,
          canMultiResize,
          hideDragLine,
          lastWidth,
          childRestrictions,
          hasWarning,
          currentColumns,
          updateWidth,
          handleOverlayClick,
          handleCloneClick,
          handleRemoveClick,
          handleFocus,
          handleBlur,
          handleKeydown,
          handleDragOver,
          handleDragLeave,
          handleDrop,
          handleDragStart,
          handleDragEnd,
          handleResizeDragStart,
          handleResizeDrag,
          handleResizeDragEnd,
          handleResizeMultiDragStart,
          handleResizeMultiDrag,
          handleResizeMultiDragEnd,
          handleResizeMultiDragMouseDown,
          handleResizeMultiDragMouseUp
        };
      }
    })
  ];
}
export {
  plugin_default as default
};
//# sourceMappingURL=@vueform_builder_plugin.js.map
